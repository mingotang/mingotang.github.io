<!DOCTYPE html><html lang=""><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python 3 Basic · Mingo的博客</title><meta name="description" content="Welcome to my personal blog"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">Home</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   Blog</a></li><li class="nav-list-item"><a href="https://github.com/mingotang" target="_blank" class="nav-link">github</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/users/12bf64a47246" target="_blank" class="nav-link">jianshu</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2017/10/07/Python-3-Basic/" class="post-title-link">Python 3 Basic</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/Notes/" class="post-tag-link">Notes</a></li></ul><div class="post-time">Saturday, October 7th 2017</div></div><div class="post-content"><hr>
<blockquote>
<p><a href="https://docs.python.org/3.5/index.html" target="_blank" rel="external">Python 3.5.3 documentation</a></p>
</blockquote>
<h2 id="Python-3-教程"><a href="#Python-3-教程" class="headerlink" title="Python 3 教程"></a><a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="external">Python 3 教程</a></h2><p><img src="http://www.runoob.com/wp-content/uploads/2014/05/python3.png" alt="python3"></p>
<p>Python的3.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。为了不带入过多的累赘，Python<br>3.0在设计的时候没有考虑向下兼容。</p>
<p>Python 介绍及安装教程我们在<a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="external">Python2.X版本的教程</a>中已有介绍，这里就不再赘述。</p>
<p>你也可以点击<a href="http://www.runoob.com/python-2x-3x.html" target="_blank" rel="external">Python2.x与3.x版本区别</a>来查看两者的不同。</p>
<p>本教程主要针对Python 3.x版本的学习，如果你使用的是Python<br>2.x版本请移步至<a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="external">Python2.X版本的教程</a>。</p>
<hr>
<p>查看python版本</p>
<p>我们可以使用以下命令来查看我们使用的Python版本：</p>
<pre><code>python -V
</code></pre><p>以上命令执行结果如下：</p>
<pre><code>Python 3.3.2
</code></pre><p>你也可以进入Python的交互式编程模式，查看版本：</p>
<pre><code>Python 3.3.2 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)] on win32
Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license()&quot; for more information.
&gt;&gt;&gt;
</code></pre><hr>
<p>第一个Python3.x程序</p>
<p>对于大多数程序语言，第一个入门编程代码便是”Hello<br>World！”，以下代码为使用Python输出”Hello World！”：</p>
<pre><code>#!/usr/bin/python3
print(&quot;Hello, World!&quot;)
</code></pre><p>你可以将以上代码保存在hello.py文件中并使用python命令执行该脚本文件。</p>
<pre><code>$ python3 hello.py
</code></pre><p>以上命令输出结果为：</p>
<pre><code>Hello, World!
</code></pre><hr>
<h2 id="Python3-基础语法"><a href="#Python3-基础语法" class="headerlink" title="Python3 基础语法"></a>Python3 基础语法</h2><p>编码</p>
<p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode<br>字符串。 当然你也可以为源码文件指定不同的编码：</p>
<pre><code># -*- coding: cp-1252 -*-
</code></pre><hr>
<p>标识符</p>
<ul>
<li>第一个字符必须是字母表中字母或下划线’_‘。</li>
<li>标识符的其他的部分有字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>在Python 3中，非-ASCII 标识符也是允许的了。</p>
<hr>
<p>python保留字</p>
<p>保留字即关键字，我们不能把它们用作任何标识符名称。Python的标准库提供了一个keyword module，可以输出当前版本的所有关键字：</p>
<pre><code>&gt;&gt;&gt; import keyword
&gt;&gt;&gt; keyword.kwlist
[&apos;False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;]
</code></pre><hr>
<p>注释</p>
<p>Python中单行注释以 <strong>#</strong> 开头，实例如下：</p>
<pre><code>#!/usr/bin/python3

# 第一个注释
print (&quot;Hello, Python!&quot;) # 第二个注释
</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>Hello, Python!
</code></pre><p>多行注释可以用多个 # 号：</p>
<pre><code>#!/usr/bin/python3

# 第一个注释
# 第二个注释

print (&quot;Hello, Python!&quot;)
</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>Hello, Python!
</code></pre><hr>
<p>行与缩进</p>
<p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号({})。</p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：</p>
<pre><code>if True:
    print (&quot;True&quot;)
else:
    print (&quot;False&quot;)
</code></pre><p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p>
<pre><code>if True:
    print (&quot;Answer&quot;)
    print (&quot;True&quot;)
else:
    print (&quot;Answer&quot;)
  print (&quot;False&quot;)    # 缩进不一致，会导致运行错误
</code></pre><p>以上程序由于缩进不一致，执行后会出现类似以下错误：</p>
<pre><code> File &quot;test.py&quot;, line 6
    print (&quot;False&quot;)    # 缩进不一致，会导致运行错误
                                      ^
IndentationError: unindent does not match any outer indentation level
</code></pre><hr>
<p>多行语句</p>
<p>Python通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠(\)来实现多行语句，例如：</p>
<pre><code>total = item_one + \
        item_two + \
        item_three
</code></pre><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠(\)，例如：</p>
<pre><code>total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;,
        &apos;item_four&apos;, &apos;item_five&apos;]
</code></pre><hr>
<p>数据类型</p>
<p>python中数有四种类型：整数、长整数、浮点数和复数。</p>
<ul>
<li>整数， 如 1</li>
<li>长整数 是比较大的整数</li>
<li>浮点数 如 1.23、3E-2</li>
<li>复数 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<hr>
<p>字符串</p>
<ul>
<li>python中单引号和双引号使用完全相同。</li>
<li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li>
<li>转义符 ‘\‘</li>
<li>自然字符串， 通过在字符串前加r或R。 如 r”this is a line with \n”<br>则\n会显示，并不是换行。</li>
<li>python允许处理unicode字符串，加前缀u或U， 如 u”this is an unicode string”。</li>
<li>字符串是不可变的。</li>
<li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li>
</ul>
<!-- -->
<pre><code>word = &apos;字符串&apos;
sentence = &quot;这是一个句子。&quot;
paragraph = &quot;&quot;&quot;这是一个段落，
可以由多行组成&quot;&quot;&quot;
</code></pre><hr>
<p>空行</p>
<p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：</strong>空行也是程序代码的一部分。</p>
<hr>
<p>等待用户输入</p>
<p>执行下面的程序在按回车键后就会等待用户输入：</p>
<pre><code>#!/usr/bin/python3

input(&quot;\n\n按下 enter 键后退出。&quot;)
</code></pre><p>以上代码中<br>，”\n\n”在结果输出前会输出两个新的空行。一旦用户按下键时，程序将退出。</p>
<hr>
<p>同一行显示多条语句</p>
<p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：</p>
<pre><code>#!/usr/bin/python3

import sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\n&apos;)
</code></pre><p>执行以上代码，输入结果为：</p>
<pre><code>$ python3 test.py
runoob
</code></pre><hr>
<p>多个语句构成代码组</p>
<p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( :<br>)结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<p>如下实例：</p>
<pre><code>if expression :
   suite
elif expression :
   suite
else :
   suite
</code></pre><hr>
<p>命令行参数</p>
<p>很多程序可以执行一些操作来查看一些基本信，Python可以使用-h参数查看各参数帮助信息：</p>
<pre><code>$ python -h
usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...
Options and arguments (and corresponding environment variables):
-c cmd : program passed in as string (terminates option list)
-d     : debug output from parser (also PYTHONDEBUG=x)
-E     : ignore environment variables (such as PYTHONPATH)
-h     : print this help message and exit

[ etc. ]
</code></pre><p>我们在使用脚本形式执行 Python<br>时，可以接收命令行输入的参数，具体使用可以参照 <a href="http://www.runoob.com/python3/python3-command-line-arguments.html" target="_blank" rel="external">Python 3<br>命令行参数</a>。</p>
<hr>
<h2 id="Python3-基本数据类型"><a href="#Python3-基本数据类型" class="headerlink" title="Python3 基本数据类型"></a>Python3 基本数据类型</h2><p>Python中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p>
<p>等号（=）用来给变量赋值。</p>
<p>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：</p>
<pre><code>#!/usr/bin/python3

counter = 100          # 整型变量
miles   = 1000.0       # 浮点型变量
name    = &quot;runoob&quot;     # 字符串

print (counter)
print (miles)
print (name)
</code></pre><p>执行以上程序会输出如下结果：</p>
<pre><code>100
1000.0
runoob
</code></pre><hr>
<p>多个变量赋值</p>
<p>Python允许你同时为多个变量赋值。例如：</p>
<pre><code>a = b = c = 1
</code></pre><p>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</p>
<p>您也可以为多个对象指定多个变量。例如：</p>
<pre><code>a, b, c = 1, 2, &quot;runoob&quot;
</code></pre><p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “runoob”<br>分配给变量 c。</p>
<hr>
<p>标准数据类型</p>
<p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<hr>
<p>Number（数字）</p>
<p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的<br>Long。</p>
<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>
<p>内置的type()函数可以用来查询变量所指的对象类型。</p>
<pre><code>&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j
&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))
&lt;class &apos;int&apos;&gt; &lt;class &apos;float&apos;&gt; &lt;class &apos;bool&apos;&gt; &lt;class &apos;complex&apos;&gt;
</code></pre><blockquote>
<p><strong>注意：</strong>在Python2中是没有布尔型的，它用数字0表示False，用1表示True。到Python3中，把True和False定义成关键字了，但它们的值还是1和0，它们可以和数字相加。</p>
</blockquote>
<p>当你指定一个值时，Number 对象就会被创建：</p>
<pre><code>var1 = 1
var2 = 10
</code></pre><p>您也可以使用del语句删除一些对象引用。</p>
<p>del语句的语法是：</p>
<pre><code>del var1[,var2[,var3[....,varN]]]]
</code></pre><p>您可以通过使用del语句删除单个或多个对象。例如：</p>
<pre><code>del var
del var_a, var_b
</code></pre><hr>
<p>数值运算</p>
<pre><code>&gt;&gt;&gt; 5 + 4  # 加法
9
&gt;&gt;&gt; 4.3 - 2 # 减法
2.3
&gt;&gt;&gt; 3 * 7  # 乘法
21
&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数
0.5
&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数
0
&gt;&gt;&gt; 17 % 3 # 取余
2
&gt;&gt;&gt; 2 ** 5 # 乘方
32
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>1、Python可以同时为多个变量赋值，如a, b = 1, 2。</li>
<li>2、一个变量可以通过赋值指向不同类型的对象。</li>
<li>3、数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。</li>
<li>4、在混合计算时，Python会把整型转换成为浮点数。</li>
</ul>
<hr>
<p>数值类型实例</p>
<table>
<thead>
<tr>
<th>int</th>
<th>float</th>
<th>complex</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>0.0</td>
<td>3.14j</td>
</tr>
<tr>
<td>100</td>
<td>15.20</td>
<td>45.j</td>
</tr>
<tr>
<td>-786</td>
<td>-21.9</td>
<td>9.322e-36j</td>
</tr>
<tr>
<td>080</td>
<td>32.3+e18</td>
<td>.876j</td>
</tr>
<tr>
<td>-0490</td>
<td>-90.</td>
<td>-.6545+0J</td>
</tr>
<tr>
<td>-0x260</td>
<td>-32.54e100</td>
<td>3e+26J</td>
</tr>
<tr>
<td>0x69</td>
<td>70.2-E12</td>
<td>4.53e-7j</td>
</tr>
</tbody>
</table>
<p>Python还支持复数，复数由实数部分和虚数部分构成，可以用a +<br>bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p>
<hr>
<p>String（字符串）</p>
<p>Python中的字符串用单引号(‘)或双引号(“)括起来，同时使用反斜杠(\)转义特殊字符。</p>
<p>字符串的截取的语法格式如下：</p>
<pre><code>变量[头下标:尾下标]
</code></pre><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p>加号 (+) 是字符串的连接符， 星号 (*)表示复制当前字符串，紧跟的数字为复制的次数。实例如下：</p>
<pre><code>#!/usr/bin/python3

str = &apos;Runoob&apos;

print (str)          # 输出字符串
print (str[0:-1])    # 输出第一个个到倒数第二个的所有字符
print (str[0])       # 输出字符串第一个字符
print (str[2:5])     # 输出从第三个开始到第五个的字符
print (str[2:])      # 输出从第三个开始的后的所有字符
print (str * 2)      # 输出字符串两次
print (str + &quot;TEST&quot;) # 连接字符串
</code></pre><p>执行以上程序会输出如下结果：</p>
<pre><code>Runoob
Runoo
R
noo
noob
RunoobRunoob
RunoobTEST
</code></pre><p>Python使用反斜杠(\)转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串：</p>
<pre><code>&gt;&gt;&gt; print(&apos;Ru\noob&apos;)
Ru
oob
&gt;&gt;&gt; print(r&apos;Ru\noob&apos;)
Ru\noob
&gt;&gt;&gt;
</code></pre><p>另外，反斜杠(\)可以作为续行符，表示下一行是上一行的延续。也可以使用<br><strong>“””…”””</strong> 或者 <strong>‘’’…’’’</strong> 跨越多行。</p>
<p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p>
<pre><code>&gt;&gt;&gt; word = &apos;Python&apos;
&gt;&gt;&gt; print(word[0], word[5])
P n
&gt;&gt;&gt; print(word[-1], word[-6])
n P
</code></pre><p>与 C 字符串不同的是，Python字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li>
<li>2、字符串可以用+运算符连接在一起，用*运算符重复。</li>
<li>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li>
<li>4、Python中的字符串不能改变。</li>
</ul>
<hr>
<p>List（列表）</p>
<p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在方括号([])之间、用逗号分隔开的元素列表。</p>
<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>列表截取的语法格式如下：</p>
<pre><code>变量[头下标:尾下标]
</code></pre><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p>加号（+）是列表连接运算符，星号（*）是重复操作。如下实例：</p>
<pre><code>#!/usr/bin/python3

list = [ &apos;abcd&apos;, 786 , 2.23, &apos;runoob&apos;, 70.2 ]
tinylist = [123, &apos;runoob&apos;]

print (list)            # 输出完整列表
print (list[0])         # 输出列表第一个元素
print (list[1:3])       # 从第二个开始输出到第三个元素
print (list[2:])        # 输出从第三个元素开始的所有元素
print (tinylist * 2)    # 输出两次列表
print (list + tinylist) # 连接列表
</code></pre><p>以上实例输出结果：</p>
<pre><code>[&apos;abcd&apos;, 786, 2.23, &apos;runoob&apos;, 70.2]
abcd
[786, 2.23]
[2.23, &apos;runoob&apos;, 70.2]
[123, &apos;runoob&apos;, 123, &apos;runoob&apos;]
[&apos;abcd&apos;, 786, 2.23, &apos;runoob&apos;, 70.2, 123, &apos;runoob&apos;]
</code></pre><p>与Python字符串不一样的是，列表中的元素是可以改变的：</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; a[0] = 9
&gt;&gt;&gt; a[2:5] = [13, 14, 15]
&gt;&gt;&gt; a
[9, 2, 13, 14, 15, 6]
&gt;&gt;&gt; a[2:5] = []   # 删除
&gt;&gt;&gt; a
[9, 2, 6]
</code></pre><p>List内置了有很多方法，例如append()、pop()等等，这在后面会讲到。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、List写在方括号之间，元素用逗号隔开。</li>
<li>2、和字符串一样，list可以被索引和切片。</li>
<li>3、List可以使用+操作符进行拼接。</li>
<li>4、List中的元素是可以改变的。</li>
</ul>
<hr>
<p>Tuple（元组）</p>
<p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号(<strong>()</strong>)里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<pre><code>#!/usr/bin/python3

tuple = ( &apos;abcd&apos;, 786 , 2.23, &apos;runoob&apos;, 70.2  )
tinytuple = (123, &apos;runoob&apos;)

print (tuple)             # 输出完整元组
print (tuple[0])          # 输出元组的第一个元素
print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
print (tuple[2:])         # 输出从第三个元素开始的所有元素
print (tinytuple * 2)     # 输出两次元组
print (tuple + tinytuple) # 连接元组
</code></pre><p>以上实例输出结果：</p>
<pre><code>(&apos;abcd&apos;, 786, 2.23, &apos;runoob&apos;, 70.2)
abcd
(786, 2.23)
(2.23, &apos;runoob&apos;, 70.2)
(123, &apos;runoob&apos;, 123, &apos;runoob&apos;)
(&apos;abcd&apos;, 786, 2.23, &apos;runoob&apos;, 70.2, 123, &apos;runoob&apos;)
</code></pre><p>元组与字符串类似，可以被索引且下标索引从0开始，-1为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p>
<p>其实，可以把字符串看作一种特殊的元组。</p>
<pre><code>&gt;&gt;&gt; tup = (1, 2, 3, 4, 5, 6)
&gt;&gt;&gt; print(tup[0])
1
&gt;&gt;&gt; print(tup[1:5])
(2, 3, 4, 5)
&gt;&gt;&gt; tup[0] = 11  # 修改元组元素的操作是非法的
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &apos;tuple&apos; object does not support item assignment
&gt;&gt;&gt;
</code></pre><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<pre><code>tup1 = ()    # 空元组
tup2 = (20,) # 一个元素，需要在元素后添加逗号
</code></pre><p>string、list和tuple都属于sequence（序列）。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、与字符串一样，元组的元素不能修改。</li>
<li>2、元组也可以被索引和切片，方法一样。</li>
<li>3、注意构造包含0或1个元素的元组的特殊语法规则。</li>
<li>4、元组也可以使用+操作符进行拼接。</li>
</ul>
<hr>
<p>Set（集合）</p>
<p>集合（set）是一个无序不重复元素的序列。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号({})或者 set()函数创建集合，注意：创建一个空集合必须用<br>set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<pre><code>#!/usr/bin/python3

student = ({&apos;Tom&apos;, &apos;Jim&apos;, &apos;Mary&apos;, &apos;Tom&apos;, &apos;Jack&apos;, &apos;Rose&apos;})

print(student)   # 输出集合，重复的元素被自动去掉

# 成员测试
if(&apos;Rose&apos; in student) :
    print(&apos;Rose 在集合中&apos;)
else :
    print(&apos;Rose 不在集合中&apos;)


# set可以进行集合运算
a = set(&apos;abracadabra&apos;)
b = set(&apos;alacazam&apos;)

print(a)

print(a - b)     # a和b的差集

print(a | b)     # a和b的并集

print(a &amp; b)     # a和b的交集

print(a ^ b)     # a和b中不同时存在的元素
</code></pre><p>以上实例输出结果：</p>
<pre><code>{&apos;Mary&apos;, &apos;Jim&apos;, &apos;Rose&apos;, &apos;Jack&apos;, &apos;Tom&apos;}
Rose 在集合中
{&apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;}
{&apos;b&apos;, &apos;d&apos;, &apos;r&apos;}
{&apos;l&apos;, &apos;r&apos;, &apos;a&apos;, &apos;c&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;}
{&apos;a&apos;, &apos;c&apos;}
{&apos;l&apos;, &apos;r&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;}
</code></pre><hr>
<p>Dictionary（字典）</p>
<p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用”{ }”标识，它是一个无序的<strong>键(key) :<br>值(value)</strong>对集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<pre><code>#!/usr/bin/python3

dict = {}
dict[&apos;one&apos;] = &quot;1 - 菜鸟教程&quot;
dict[2]     = &quot;2 - 菜鸟工具&quot;

tinydict = {&apos;name&apos;: &apos;runoob&apos;,&apos;code&apos;:1, &apos;site&apos;: &apos;www.runoob.com&apos;}


print (dict[&apos;one&apos;])       # 输出键为 &apos;one&apos; 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - 菜鸟教程
2 - 菜鸟工具
{&apos;name&apos;: &apos;runoob&apos;, &apos;site&apos;: &apos;www.runoob.com&apos;, &apos;code&apos;: 1}
dict_keys([&apos;name&apos;, &apos;site&apos;, &apos;code&apos;])
dict_values([&apos;runoob&apos;, &apos;www.runoob.com&apos;, 1])
</code></pre><p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p>
<pre><code>&gt;&gt;&gt; dict([(&apos;Runoob&apos;, 1), (&apos;Google&apos;, 2), (&apos;Taobao&apos;, 3)])
{&apos;Taobao&apos;: 3, &apos;Runoob&apos;: 1, &apos;Google&apos;: 2}

&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}

&gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3)
{&apos;Taobao&apos;: 3, &apos;Runoob&apos;: 1, &apos;Google&apos;: 2}
</code></pre><p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、字典是一种映射类型，它的元素是键值对。</li>
<li>2、字典的关键字必须为不可变类型，且不能重复。</li>
<li>3、创建空字典使用 <strong>{ }</strong>。</li>
</ul>
<hr>
<p>数据类型转换</p>
<p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int(x [,base])</td>
<td style="text-align:left">将x转换为一个整数</td>
</tr>
<tr>
<td style="text-align:left">float(x)</td>
<td style="text-align:left">将x转换到一个浮点数</td>
</tr>
<tr>
<td style="text-align:left">complex(real [,imag])</td>
<td style="text-align:left">创建一个复数</td>
</tr>
<tr>
<td style="text-align:left">str(x)</td>
<td style="text-align:left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td style="text-align:left">repr(x)</td>
<td style="text-align:left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td style="text-align:left">eval(str)</td>
<td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td style="text-align:left">tuple(s)</td>
<td style="text-align:left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td style="text-align:left">list(s)</td>
<td style="text-align:left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td style="text-align:left">set(s)</td>
<td style="text-align:left">转换为可变集合</td>
</tr>
<tr>
<td style="text-align:left">dict(d)</td>
<td style="text-align:left">创建一个字典。d 必须是一个序列   (key,value)元组。</td>
</tr>
<tr>
<td style="text-align:left">frozenset(s)</td>
<td style="text-align:left">转换为不可变集合</td>
</tr>
<tr>
<td style="text-align:left">chr(x)</td>
<td style="text-align:left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td style="text-align:left">unichr(x)</td>
<td style="text-align:left">将一个整数转换为Unicode字符</td>
</tr>
<tr>
<td style="text-align:left">ord(x)</td>
<td style="text-align:left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td style="text-align:left">hex(x)</td>
<td style="text-align:left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td style="text-align:left">oct(x)</td>
<td style="text-align:left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Python3-解释器"><a href="#Python3-解释器" class="headerlink" title="Python3 解释器"></a>Python3 解释器</h2><p>Linux/Unix的系统上，一般默认的 python 版本为 2.x，我们可以将 python3.x<br>安装在 <strong>/usr/local/python3</strong> 目录中。</p>
<p>安装完成后，我们可以将路径 <strong>/usr/local/python3/bin</strong> 添加到您的<br>Linux/Unix 操作系统的环境变量中，这样您就可以通过 shell<br>终端输入下面的命令来启动 Python3 。</p>
<pre><code>$ PATH=$PATH:/usr/local/python3/bin/python3    # 设置环境变量
$ python3 --version
Python 3.4.0
</code></pre><p>在Window系统下你可以通过以下命令来设置Python的环境变量，假设你的Python安装在<br>C:\Python34 下:</p>
<pre><code>set path=%path%;C:\python34
</code></pre><hr>
<p>交互式编程</p>
<p>我们可以在命令提示符中输入”Python”命令来启动Python解释器：</p>
<pre><code>$ python3
</code></pre><p>执行以上命令后，出现如下窗口信息：</p>
<pre><code>$ python3
Python 3.4.0 (default, Apr 11 2014, 13:05:11)
[GCC 4.8.2] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre><p>在 python 提示符中输入以下语句，然后按回车键查看运行效果：</p>
<pre><code>print (&quot;Hello, Python!&quot;);
</code></pre><p>以上命令执行结果如下：</p>
<pre><code>Hello, Python!
</code></pre><p>当键入一个多行结构时，续行是必须的。我们可以看下如下 if 语句：</p>
<pre><code>&gt;&gt;&gt; flag = True
&gt;&gt;&gt; if flag :
...     print(&quot;flag 条件为 True!&quot;)
...
flag 条件为 True!
</code></pre><hr>
<p>脚本式编程</p>
<p>将如下代码拷贝至 <strong>hello.py</strong>文件中：</p>
<pre><code>print (&quot;Hello, Python!&quot;);
</code></pre><p>通过以下命令执行该脚本：</p>
<pre><code>python3 hello.py
</code></pre><p>输出结果为：</p>
<pre><code>Hello, Python!
</code></pre><p>在Linux/Unix系统中，你可以在脚本顶部添加以下命令让Python脚本可以像SHELL脚本一样可直接执行：</p>
<pre><code>#! /usr/bin/env python3
</code></pre><p>然后修改脚本权限，使其有执行权限，命令如下：</p>
<pre><code>$ chmod +x hello.py
</code></pre><p>执行以下命令：</p>
<pre><code>./hello.py
</code></pre><p>输出结果为：</p>
<pre><code>Hello, Python!
</code></pre><hr>
<h2 id="Python3-注释"><a href="#Python3-注释" class="headerlink" title="Python3 注释"></a>Python3 注释</h2><p>确保对模块, 函数, 方法和行内注释使用正确的风格</p>
<p>Python中的注释有单行注释和多行注释：</p>
<p>Python中单行注释以#开头，例如：：</p>
<pre><code># 这是一个注释
print(&quot;Hello, World!&quot;)
</code></pre><p>多行注释用三个单引号（’’’）或者三个双引号（”””）将注释括起来，例如:</p>
<p>1、单引号（’’’）</p>
<pre><code>#!/usr/bin/python3
&apos;&apos;&apos;
这是多行注释，用三个单引号
这是多行注释，用三个单引号
这是多行注释，用三个单引号
&apos;&apos;&apos;
print(&quot;Hello, World!&quot;)
</code></pre><p>2、双引号（’’’）</p>
<pre><code>#!/usr/bin/python3
&quot;&quot;&quot;
这是多行注释，用三个单引号
这是多行注释，用三个单引号
这是多行注释，用三个单引号
&quot;&quot;&quot;
print(&quot;Hello, World!&quot;)
</code></pre><hr>
<h2 id="Python3-运算符"><a href="#Python3-运算符" class="headerlink" title="Python3 运算符"></a>Python3 运算符</h2><p>什么是运算符？</p>
<p>本章节主要说明Python的运算符。举个简单的例子 <strong>4 +5 = 9</strong> 。<br>例子中，<strong>4</strong> 和 <strong>5</strong> 被称为<strong>操作数</strong>，”<strong>+</strong>“ 称为运算符。</p>
<p>Python语言支持以下类型的运算符:</p>
<ul>
<li><a href="#ysf1">算术运算符</a></li>
<li><a href="#ysf2">比较（关系）运算符</a></li>
<li><a href="#ysf3">赋值运算符</a></li>
<li><a href="#ysf4">逻辑运算符</a></li>
<li><a href="#ysf5">位运算符</a></li>
<li><a href="#ysf6">成员运算符</a></li>
<li><a href="#ysf7">身份运算符</a></li>
<li><a href="#ysf8">运算符优先级</a></li>
</ul>
<p>接下来让我们一个个来学习Python的运算符。</p>
<hr>
<p>算术运算符</p>
<p>以下假设变量a为10，变量b为21：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td style="text-align:left">加 - 两个对象相加</td>
<td style="text-align:left">a + b 输出结果 31</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:left">减 - 得到负数或是一个数减去另一个数</td>
<td style="text-align:left">a - b 输出结果 -11</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td style="text-align:left">a * b 输出结果 210</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:left">除 - x 除以 y</td>
<td style="text-align:left">b / a 输出结果 2.1</td>
</tr>
<tr>
<td>%</td>
<td style="text-align:left">取模 - 返回除法的余数</td>
<td style="text-align:left">b % a 输出结果 1</td>
</tr>
<tr>
<td>**</td>
<td style="text-align:left">幂 - 返回x的y次幂</td>
<td style="text-align:left">a**b 为10的21次方</td>
</tr>
<tr>
<td>//</td>
<td style="text-align:left">取整除 - 返回商的整数部分</td>
<td style="text-align:left">9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有算术运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 21
b = 10
c = 0

c = a + b
print (&quot;1 - c 的值为：&quot;, c)

c = a - b
print (&quot;2 - c 的值为：&quot;, c)

c = a * b
print (&quot;3 - c 的值为：&quot;, c)

c = a / b
print (&quot;4 - c 的值为：&quot;, c)

c = a % b
print (&quot;5 - c 的值为：&quot;, c)

# 修改变量 a 、b 、c
a = 2
b = 3
c = a**b
print (&quot;6 - c 的值为：&quot;, c)

a = 10
b = 5
c = a//b
print (&quot;7 - c 的值为：&quot;, c)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - c 的值为： 31
2 - c 的值为： 11
3 - c 的值为： 210
4 - c 的值为： 2.1
5 - c 的值为： 1
6 - c 的值为： 8
7 - c 的值为： 2
</code></pre><hr>
<p>比较运算符</p>
<p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">等于 - 比较对象是否相等</td>
<td style="text-align:left">(a == b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不等于 - 比较两个对象是否不相等</td>
<td style="text-align:left">(a != b) 返回 true.</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于 - 返回x是否大于y</td>
<td style="text-align:left">(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td>
<td style="text-align:left">(a &lt; b) 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于 - 返回x是否大于等于y。</td>
<td style="text-align:left">(a &gt;= b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于 - 返回x是否小于等于y。</td>
<td style="text-align:left">(a &lt;= b) 返回 true。</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有比较运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 21
b = 10
c = 0

if ( a == b ):
   print (&quot;1 - a 等于 b&quot;)
else:
   print (&quot;1 - a 不等于 b&quot;)

if ( a != b ):
   print (&quot;2 - a 不等于 b&quot;)
else:
   print (&quot;2 - a 等于 b&quot;)

if ( a &lt; b ):
   print (&quot;3 - a 小于 b&quot;)
else:
   print (&quot;3 - a 大于等于 b&quot;)

if ( a &gt; b ):
   print (&quot;4 - a 大于 b&quot;)
else:
   print (&quot;4 - a 小于等于 b&quot;)

# 修改变量 a 和 b 的值
a = 5;
b = 20;
if ( a &lt;= b ):
   print (&quot;5 - a 小于等于 b&quot;)
else:
   print (&quot;5 - a 大于  b&quot;)

if ( b &gt;= a ):
   print (&quot;6 - b 大于等于 a&quot;)
else:
   print (&quot;6 - b 小于 a&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - a 不等于 b
2 - a 不等于 b
3 - a 大于等于 b
4 - a 大于 b
5 - a 小于等于 b
6 - b 大于等于 a
</code></pre><hr>
<p>赋值运算符</p>
<p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">简单的赋值运算符</td>
<td style="text-align:left">c = a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
</tbody>
</table>
<p>  +=       加法赋值运算符     c += a 等效于 c = c + a<br>  -=       减法赋值运算符     c -= a 等效于 c = c - a<br>  *=      乘法赋值运算符     c *= a 等效于 c = c * a<br>  /=       除法赋值运算符     c /= a 等效于 c = c / a<br>  %=       取模赋值运算符     c %= a 等效于 c = c % a<br>  **=    幂赋值运算符       c **= a 等效于 c = c ** a<br>  //=      取整除赋值运算符   c //= a 等效于 c = c // a</p>
<p>以下实例演示了Python所有赋值运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 21
b = 10
c = 0

c = a + b
print (&quot;1 - c 的值为：&quot;, c)

c += a
print (&quot;2 - c 的值为：&quot;, c)

c *= a
print (&quot;3 - c 的值为：&quot;, c)

c /= a
print (&quot;4 - c 的值为：&quot;, c)

c = 2
c %= a
print (&quot;5 - c 的值为：&quot;, c)

c **= a
print (&quot;6 - c 的值为：&quot;, c)

c //= a
print (&quot;7 - c 的值为：&quot;, c)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - c 的值为： 31
2 - c 的值为： 52
3 - c 的值为： 1092
4 - c 的值为： 52.0
5 - c 的值为： 2
6 - c 的值为： 2097152
7 - c 的值为： 99864
</code></pre><hr>
<p>位运算符</p>
<p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p>
<p>下表中变量 a 为 60，b 为 13二进制格式如下：</p>
<pre><code>a = 0011 1100

b = 0000 1101

-----------------

a&amp;b = 0000 1100

a|b = 0011 1101

a^b = 0011 0001

~a  = 1100 0011
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
<td style="text-align:left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td>(a \</td>
<td>b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">按位异或运算符：当两对应的二进位相异时，结果为1</td>
<td style="text-align:left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1</td>
<td style="text-align:left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td style="text-align:left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td>
<td style="text-align:left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有位运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 60            # 60 = 0011 1100
b = 13            # 13 = 0000 1101
c = 0

c = a &amp; b;        # 12 = 0000 1100
print (&quot;1 - c 的值为：&quot;, c)

c = a | b;        # 61 = 0011 1101
print (&quot;2 - c 的值为：&quot;, c)

c = a ^ b;        # 49 = 0011 0001
print (&quot;3 - c 的值为：&quot;, c)

c = ~a;           # -61 = 1100 0011
print (&quot;4 - c 的值为：&quot;, c)

c = a &lt;&lt; 2;       # 240 = 1111 0000
print (&quot;5 - c 的值为：&quot;, c)

c = a &gt;&gt; 2;       # 15 = 0000 1111
print (&quot;6 - c 的值为：&quot;, c)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - c 的值为： 12
2 - c 的值为： 61
3 - c 的值为： 49
4 - c 的值为： -61
5 - c 的值为： 240
6 - c 的值为： 15
</code></pre><hr>
<p>逻辑运算符</p>
<p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">逻辑表达式</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">and</td>
<td style="text-align:left">x and y</td>
<td style="text-align:left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td>
<td style="text-align:left">(a and b) 返回 20。</td>
</tr>
<tr>
<td style="text-align:left">or</td>
<td style="text-align:left">x or y</td>
<td style="text-align:left">布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。</td>
<td style="text-align:left">(a or b) 返回 10。</td>
</tr>
<tr>
<td style="text-align:left">not</td>
<td style="text-align:left">not x</td>
<td style="text-align:left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td style="text-align:left">not(a and b) 返回 False</td>
</tr>
</tbody>
</table>
<p>以上实例输出结果：</p>
<pre><code>#!/usr/bin/python3

a = 10
b = 20

if ( a and b ):
   print (&quot;1 - 变量 a 和 b 都为 true&quot;)
else:
   print (&quot;1 - 变量 a 和 b 有一个不为 true&quot;)

if ( a or b ):
   print (&quot;2 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)
else:
   print (&quot;2 - 变量 a 和 b 都不为 true&quot;)

# 修改变量 a 的值
a = 0
if ( a and b ):
   print (&quot;3 - 变量 a 和 b 都为 true&quot;)
else:
   print (&quot;3 - 变量 a 和 b 有一个不为 true&quot;)

if ( a or b ):
   print (&quot;4 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)
else:
   print (&quot;4 - 变量 a 和 b 都不为 true&quot;)

if not( a and b ):
   print (&quot;5 - 变量 a 和 b 都为 false，或其中一个变量为 false&quot;)
else:
   print (&quot;5 - 变量 a 和 b 都为 true&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - 变量 a 和 b 都为 true
2 - 变量 a 和 b 都为 true，或其中一个变量为 true
3 - 变量 a 和 b 有一个不为 true
4 - 变量 a 和 b 都为 true，或其中一个变量为 true
5 - 变量 a 和 b 都为 false，或其中一个变量为 false
</code></pre><hr>
<p>成员运算符</p>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">in</td>
<td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td style="text-align:left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td style="text-align:left">not in</td>
<td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td style="text-align:left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有成员运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 10
b = 20
list = [1, 2, 3, 4, 5 ];

if ( a in list ):
   print (&quot;1 - 变量 a 在给定的列表中 list 中&quot;)
else:
   print (&quot;1 - 变量 a 不在给定的列表中 list 中&quot;)

if ( b not in list ):
   print (&quot;2 - 变量 b 不在给定的列表中 list 中&quot;)
else:
   print (&quot;2 - 变量 b 在给定的列表中 list 中&quot;)

# 修改变量 a 的值
a = 2
if ( a in list ):
   print (&quot;3 - 变量 a 在给定的列表中 list 中&quot;)
else:
   print (&quot;3 - 变量 a 不在给定的列表中 list 中&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - 变量 a 不在给定的列表中 list 中
2 - 变量 b 不在给定的列表中 list 中
3 - 变量 a 在给定的列表中 list 中
</code></pre><hr>
<p>身份运算符</p>
<p>身份运算符用于比较两个对象的存储单元</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">is</td>
<td style="text-align:left">is是判断两个标识符是不是引用自一个对象</td>
<td style="text-align:left">x is y, 如果 id(x) 等于 id(y) , <strong>is</strong> 返回结果 1</td>
</tr>
<tr>
<td style="text-align:left">is not</td>
<td style="text-align:left">is not是判断两个标识符是不是引用自不同对象</td>
<td style="text-align:left">x is not y, 如果 id(x) 不等于 id(y). <strong>is not</strong> 返回结果 1</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有身份运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 20
b = 20

if ( a is b ):
   print (&quot;1 - a 和 b 有相同的标识&quot;)
else:
   print (&quot;1 - a 和 b 没有相同的标识&quot;)

if ( id(a) == id(b) ):
   print (&quot;2 - a 和 b 有相同的标识&quot;)
else:
   print (&quot;2 - a 和 b 没有相同的标识&quot;)

# 修改变量 b 的值
b = 30
if ( a is b ):
   print (&quot;3 - a 和 b 有相同的标识&quot;)
else:
   print (&quot;3 - a 和 b 没有相同的标识&quot;)

if ( a is not b ):
   print (&quot;4 - a 和 b 没有相同的标识&quot;)
else:
   print (&quot;4 - a 和 b 有相同的标识&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - a 和 b 有相同的标识
2 - a 和 b 有相同的标识
3 - a 和 b 没有相同的标识
4 - a 和 b 没有相同的标识
</code></pre><hr>
<p>运算符优先级</p>
<p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">**</td>
<td style="text-align:center">指数 (最高优先级)</td>
</tr>
<tr>
<td style="text-align:center">~ + -</td>
<td style="text-align:center">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td style="text-align:center">* / % //</td>
<td style="text-align:center">乘，除，取模和取整除</td>
</tr>
<tr>
<td style="text-align:center">+ -</td>
<td style="text-align:center">加法减法</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt; &lt;&lt;</td>
<td style="text-align:center">右移，左移运算符</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位 ‘AND’</td>
</tr>
<tr>
<td style="text-align:center">^ \</td>
<td style="text-align:center"></td>
<td>位运算符</td>
</tr>
<tr>
<td style="text-align:center">&lt;= &lt; &gt; &gt;=</td>
<td style="text-align:center">比较运算符</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt; == !=</td>
<td style="text-align:center">等于运算符</td>
</tr>
<tr>
<td style="text-align:center">= %= /= //= -= += *= **=</td>
<td style="text-align:center">赋值运算符</td>
</tr>
<tr>
<td style="text-align:center">is is not</td>
<td style="text-align:center">身份运算符</td>
</tr>
<tr>
<td style="text-align:center">in not in</td>
<td style="text-align:center">成员运算符</td>
</tr>
<tr>
<td style="text-align:center">not or and</td>
<td style="text-align:center">逻辑运算符</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有运算符优先级的操作：</p>
<pre><code>#!/usr/bin/python3

a = 20
b = 10
c = 15
d = 5
e = 0

e = (a + b) * c / d       #( 30 * 15 ) / 5
print (&quot;(a + b) * c / d 运算结果为：&quot;,  e)

e = ((a + b) * c) / d     # (30 * 15 ) / 5
print (&quot;((a + b) * c) / d 运算结果为：&quot;,  e)

e = (a + b) * (c / d);    # (30) * (15/5)
print (&quot;(a + b) * (c / d) 运算结果为：&quot;,  e)

e = a + (b * c) / d;      #  20 + (150/5)
print (&quot;a + (b * c) / d 运算结果为：&quot;,  e)
</code></pre><p>以上实例输出结果：</p>
<pre><code>(a + b) * c / d 运算结果为： 90.0
((a + b) * c) / d 运算结果为： 90.0
(a + b) * (c / d) 运算结果为： 90.0
a + (b * c) / d 运算结果为： 50.0
</code></pre><hr>
<h2 id="Python3-数字-Number"><a href="#Python3-数字-Number" class="headerlink" title="Python3 数字(Number)"></a>Python3 数字(Number)</h2><p>Python 数字数据类型用于存储数值。</p>
<p>数据类型是不允许改变的, 这就意味着如果改变数字数据类型得值，将重新分配内存空间。</p>
<p>以下实例在变量赋值时 Number 对象将被创建：</p>
<pre><code>var1 = 1
var2 = 10
</code></pre><p>您也可以使用del语句删除一些数字对象的引用。</p>
<p>del语句的语法是：</p>
<pre><code>del var1[,var2[,var3[....,varN]]]]
</code></pre><p>您可以通过使用del语句删除单个或多个对象的引用，例如：</p>
<pre><code>del var
del var_a, var_b
</code></pre><p>Python 支持三种不同的数值类型：</p>
<ul>
<li><strong>整型(Int)</strong> -<br>通常被称为是整型或整数，是正或负整数，不带小数点。Python3<br>整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有<br>Python2 的 Long 类型。</li>
<li><strong>浮点型(float)</strong> -<br>浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2<br>= 2.5 x 10^2^ = 250）</li>
<li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a +<br>bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<p>我们可以使用十六进制和八进制来代表整数：</p>
<pre><code>&gt;&gt;&gt; number = 0xA0F # 十六进制
&gt;&gt;&gt; number
2575

&gt;&gt;&gt; number=0o37 # 八进制
&gt;&gt;&gt; number
31
</code></pre><table>
<thead>
<tr>
<th>int</th>
<th style="text-align:center">float</th>
<th style="text-align:center">complex</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">3.14j</td>
</tr>
<tr>
<td>100</td>
<td style="text-align:center">15.20</td>
<td style="text-align:center">45.j</td>
</tr>
<tr>
<td>-786</td>
<td style="text-align:center">-21.9</td>
<td style="text-align:center">9.322e-36j</td>
</tr>
<tr>
<td>080</td>
<td style="text-align:center">32.3+e18</td>
<td style="text-align:center">.876j</td>
</tr>
<tr>
<td>-0490</td>
<td style="text-align:center">-90.</td>
<td style="text-align:center">-.6545+0J</td>
</tr>
<tr>
<td>-0x260</td>
<td style="text-align:center">-32.54e100</td>
<td style="text-align:center">3e+26J</td>
</tr>
<tr>
<td>0x69</td>
<td style="text-align:center">70.2-E12</td>
<td style="text-align:center">4.53e-7j</td>
</tr>
</tbody>
</table>
<ul>
<li>Python支持复数，复数由实数部分和虚数部分构成，可以用a +<br>bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<hr>
<p>Python 数字类型转换</p>
<p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<ul>
<li><p><strong>int(x)</strong> 将x转换为一个整数。</p>
</li>
<li><p><strong>float(x)</strong> 将x转换到一个浮点数。</p>
</li>
<li><p><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</p>
</li>
<li><p><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为<br>y。x 和 y 是数字表达式。</p>
</li>
</ul>
<p>以下实例将浮点数变量 a 转换为整数：</p>
<pre><code>&gt;&gt;&gt; a = 1.0
&gt;&gt;&gt; int(a)
1
</code></pre><hr>
<p>Python 数字运算</p>
<p>Python<br>解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。</p>
<p>表达式的语法很直白： +, -, * 和 /<br>和其它语言（如Pascal或C）里一样。例如：</p>
<pre><code>&gt;&gt;&gt; 2 + 2
4
&gt;&gt;&gt; 50 - 5*6
20
&gt;&gt;&gt; (50 - 5*6) / 4
5.0
&gt;&gt;&gt; 8 / 5  # 总是返回一个浮点数
1.6
</code></pre><p><strong>注意：</strong>在不同的机器上浮点运算的结果可能会不一样。</p>
<p>在整数除法中，除法（/）总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符<strong>//</strong> ：</p>
<pre><code>&gt;&gt;&gt; 17 / 3  # 整数除法返回浮点型
5.666666666666667
&gt;&gt;&gt;
&gt;&gt;&gt; 17 // 3  # 整数除法返回向下取整后的结果
5
&gt;&gt;&gt; 17 % 3  # ％操作符返回除法的余数
2
&gt;&gt;&gt; 5 * 3 + 2
17
</code></pre><p>等号（=）用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。</p>
<pre><code>&gt;&gt;&gt; width = 20
&gt;&gt;&gt; height = 5*9
&gt;&gt;&gt; width * height
900
</code></pre><p>Python 可以使用 <strong>**</strong> 操作来进行幂运算：</p>
<pre><code>&gt;&gt;&gt; 5 ** 2  # 5 的平方
25
&gt;&gt;&gt; 2 ** 7  # 2的7次方
128
</code></pre><p>变量在使用前必须先”定义”（即赋予变量一个值），否则会出现错误：</p>
<pre><code>&gt;&gt;&gt; n   # 尝试访问一个未定义的变量
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &apos;n&apos; is not defined
</code></pre><p>不同类型的数混合运算时会将整数转换为浮点数：</p>
<pre><code>&gt;&gt;&gt; 3 * 3.75 / 1.5
7.5
&gt;&gt;&gt; 7.0 / 2
3.5
</code></pre><p>在交互模式中，最后被输出的表达式结果被赋值给变量 <strong>_</strong> 。例如：</p>
<pre><code>&gt;&gt;&gt; tax = 12.5 / 100
&gt;&gt;&gt; price = 100.50
&gt;&gt;&gt; price * tax
12.5625
&gt;&gt;&gt; price + _
113.0625
&gt;&gt;&gt; round(_, 2)
113.06
</code></pre><p>此处， <strong>_</strong> 变量应被用户视为只读变量。</p>
<hr>
<p>数学函数</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abs(x)</td>
<td style="text-align:left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td style="text-align:left">ceil(x)</td>
<td style="text-align:left">返回数字的上入整数，如math.ceil(4.1)返回 5</td>
</tr>
<tr>
<td style="text-align:left">cmp(x, y)</td>
<td style="text-align:left">如果 x &lt; y 返回 -1, 如果 x ==y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃</strong> 。使用 <strong>使用(x&gt;y)-(x&lt;y)</strong> 替换。</td>
</tr>
<tr>
<td style="text-align:left">exp(x)</td>
<td style="text-align:left">返回e的x次幂(e^x^),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td style="text-align:left">fabs(x)</td>
<td style="text-align:left">返回数字的绝对值，如math.fabs(-10)  返回10.0</td>
</tr>
<tr>
<td style="text-align:left">floor(x)</td>
<td style="text-align:left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td style="text-align:left">log(x)</td>
<td style="text-align:left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td style="text-align:left">log10(x)</td>
<td style="text-align:left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
</tbody>
</table>
<p>+———————————–+———————————–+<br>| <a href="/python3/python3-func-nu |                                   |
| mber-max.html">max(x1,                          | 返回给定参数的最大值，参数可以为序列。 |<br>| x2,…)</a>                    |                                   |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-nu |                                   |
| mber-min.html">min(x1,                          | 返回给定参数的最小值，参数可以为序列。 |<br>| x2,…)</a>                    |                                   |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-n | 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮 |
| umber-modf.html">modf(x)</a>                  | 点型表示。                        |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-number- |                                   |
| pow.html">pow(x,                           | x**y 运算后的值。               |<br>| y)</a>                         |                                   |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-nu |                                   |
| mber-round.html">round(x                          | 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 |<br>| [,n])</a>                  |                                   |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-n | 返回数字x的平方根，数字可以为负数，返回类型为实数，如math.s |
| umber-sqrt.html">sqrt(x)</a>                  | qrt(4)返回                        |<br>|                                   | 2+0j                              |<br>+———————————–+———————————–+</p>
<hr>
<p>随机数函数</p>
<p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p>
<p>Python包含以下常用随机数函数：<br>| 函数     |        描述|<br>|:—|:—|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-choice.html" target="_blank" rel="external">choice(seq)</a>                                |从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-randrange.html" target="_blank" rel="external">randrange ([start,] stop [,step])</a>  | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-random.html" target="_blank" rel="external">random()</a>                            |       随机生成下一个实数，它在[0,1)范围内。|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-seed.html" target="_blank" rel="external">seed([x])</a>    |                              改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-shuffle.html" target="_blank" rel="external">shuffle(lst)</a>        |                      将序列的所有元素随机排序|<br> | <a href="http://www.runoob.com/python3/python3-func-number-uniform.html" target="_blank" rel="external">uniform(x, y)</a>                        |     随机生成下一个实数，它在[x,y]范围内。|</p>
<hr>
<p>三角函数</p>
<p>Python包括以下三角函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-acos.html" target="_blank" rel="external">acos(x)</a></td>
<td style="text-align:left">返回x的反余弦弧度值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-asin.html" target="_blank" rel="external">asin(x)</a></td>
<td style="text-align:left">返回x的反正弦弧度值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-atan.html" target="_blank" rel="external">atan(x)</a></td>
<td style="text-align:left">返回x的反正切弧度值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-atan2.html" target="_blank" rel="external">atan2(y, x)</a></td>
<td style="text-align:left">返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-cos.html" target="_blank" rel="external">cos(x)</a></td>
<td style="text-align:left">返回x的弧度的余弦值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-hypot.html" target="_blank" rel="external">hypot(x, y)</a></td>
<td style="text-align:left">返回欧几里德范数 sqrt(x*x + y*y)。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-sin.html" target="_blank" rel="external">sin(x)</a></td>
<td style="text-align:left">返回的x弧度的正弦值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-tan.html" target="_blank" rel="external">tan(x)</a></td>
<td style="text-align:left">返回x弧度的正切值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-degrees.html" target="_blank" rel="external">degrees(x)</a></td>
<td style="text-align:left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-radians.html" target="_blank" rel="external">radians(x)</a></td>
<td style="text-align:left">将角度转换为弧度</td>
</tr>
</tbody>
</table>
<hr>
<p>数学常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pi</td>
<td>数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td>e</td>
<td>数学常量 e，e即自然常数（自然常数）。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Python3-字符串"><a href="#Python3-字符串" class="headerlink" title="Python3 字符串"></a>Python3 字符串</h2><p>字符串是 Python 中最常用的数据类型。我们可以使用引号(‘或”)来创建字符串。</p>
<p>创建字符串很简单，只要为变量分配一个值即可。例如：</p>
<pre><code>var1 = &apos;Hello World!&apos;
var2 = &quot;Runoob&quot;
</code></pre><hr>
<p>访问字符串中的值</p>
<p>Python 不支持单字符类型，单字符也在Python也是作为一个字符串使用。</p>
<p>Python 访问子字符串，可以使用方括号来截取字符串，如下实例：</p>
<pre><code>#!/usr/bin/python3

var1 = &apos;Hello World!&apos;
var2 = &quot;Runoob&quot;

print (&quot;var1[0]: &quot;, var1[0])
print (&quot;var2[1:5]: &quot;, var2[1:5])
</code></pre><p>以上实例执行结果：</p>
<pre><code>var1[0]:  H
var2[1:5]:  unoo
</code></pre><hr>
<p>字符串更新</p>
<p>你可以对已存在的字符串进行修改，并赋值给另一个变量，如下实例：</p>
<pre><code>#!/usr/bin/python3

var1 = &apos;Hello World!&apos;

print (&quot;已更新字符串 : &quot;, var1[:6] + &apos;Runoob!&apos;)
</code></pre><p>以上实例执行结果</p>
<pre><code>已更新字符串 :  Hello Runoob!
</code></pre><hr>
<p>转义字符</p>
<p>在需要在字符中使用特殊字符时，python用反斜杠(\)转义字符。如下表：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(在行尾时)</td>
<td>续行符</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠符号</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>响铃</td>
</tr>
<tr>
<td>\b</td>
<td>退格(Backspace)</td>
</tr>
<tr>
<td>\e</td>
<td>转义</td>
</tr>
<tr>
<td>\000</td>
<td>空</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\oyy</td>
<td>八进制数，yy代表的字符，例如：\o12代表换行</td>
</tr>
<tr>
<td>\xyy</td>
<td>十六进制数，yy代表的字符，例如：\x0a代表换行</td>
</tr>
<tr>
<td>\other</td>
<td>其它的字符以普通格式输出</td>
</tr>
</tbody>
</table>
<hr>
<p>字符串运算符</p>
<p>下表实例变量a值为字符串 “Hello”，b变量值为 “Python”：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">字符串连接</td>
<td style="text-align:left">a + b 输出结果： HelloPython</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">重复输出字符串</td>
<td style="text-align:left">a*2 输出结果：HelloHello</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:left">通过索引获取字符串中字符</td>
<td style="text-align:left">a[1] 输出结果 <strong>e</strong></td>
</tr>
<tr>
<td style="text-align:center">[ : ]</td>
<td style="text-align:left">截取字符串中的一部分</td>
<td style="text-align:left">a[1:4] 输出结果 <strong>ell</strong></td>
</tr>
<tr>
<td style="text-align:center">in</td>
<td style="text-align:left">成员运算符 - 如果字符串中包含给定的字符返回 True</td>
<td style="text-align:left"><strong>H in a</strong> 输出结果 1</td>
</tr>
<tr>
<td style="text-align:center">not in</td>
<td style="text-align:left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td>
<td style="text-align:left"><strong>M not in a</strong> 输出结果 1</td>
</tr>
<tr>
<td style="text-align:center">r/R</td>
<td style="text-align:left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td>
<td style="text-align:left"><strong>print r’\n’</strong> prints \n 和 <strong>print R’\n’</strong> prints \n</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">格式字符串</td>
<td style="text-align:left">请看下一节内容。</td>
</tr>
</tbody>
</table>
<p>实例</p>
<pre><code>#!/usr/bin/python3

a = &quot;Hello&quot;
b = &quot;Python&quot;

print(&quot;a + b 输出结果：&quot;, a + b)
print(&quot;a * 2 输出结果：&quot;, a * 2)
print(&quot;a[1] 输出结果：&quot;, a[1])
print(&quot;a[1:4] 输出结果：&quot;, a[1:4])

if( &quot;H&quot; in a) :
    print(&quot;H 在变量 a 中&quot;)
else :
    print(&quot;H 不在变量 a 中&quot;)

if( &quot;M&quot; not in a) :
    print(&quot;M 不在变量 a 中&quot;)
else :
    print(&quot;M 在变量 a 中&quot;)

print (r&apos;\n&apos;)
print (R&apos;\n&apos;)
</code></pre><p>以上实例输出结果为：</p>
<pre><code>a + b 输出结果： HelloPython
a * 2 输出结果： HelloHello
a[1] 输出结果： e
a[1:4] 输出结果： ell
H 在变量 a 中
M 不在变量 a 中
\n
\n
</code></pre><hr>
<p>字符串格式化</p>
<p>Python 支持格式化字符串的输出。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符<br>%s 的字符串中。</p>
<p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p>
<p>如下实例：</p>
<pre><code>#!/usr/bin/python3

print (&quot;我叫 %s 今年 %d 岁!&quot; % (&apos;小明&apos;, 10))
</code></pre><p>以上实例输出结果：</p>
<pre><code>我叫 小明 今年 10 岁!
</code></pre><p>python字符串格式化符号:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">格式化字符及其ASCII码</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">格式化字符串</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">格式化整数</td>
</tr>
<tr>
<td style="text-align:center">%u</td>
<td style="text-align:center">格式化无符号整型</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:center">格式化无符号八进制数</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">格式化无符号十六进制数</td>
</tr>
<tr>
<td style="text-align:center">%X</td>
<td style="text-align:center">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td style="text-align:center">%e</td>
<td style="text-align:center">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:center">%E</td>
<td style="text-align:center">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:center">%g</td>
<td style="text-align:center">%f和%e的简写</td>
</tr>
<tr>
<td style="text-align:center">%G</td>
<td style="text-align:center">%f 和 %E 的简写</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">用十六进制数格式化变量的地址</td>
</tr>
</tbody>
</table>
<p>格式化操作符辅助指令:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:left">用做左对齐</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td style="text-align:center">&lt;sp&gt;</td>
<td style="text-align:left">在正数前面显示空格</td>
</tr>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或</td>
<td>者’0X’(取决于用的是’x’还是’X’)</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">显示的数字前面填充’0’而不是默认的空格</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">‘%%’输出一个单一的’%’</td>
</tr>
<tr>
<td style="text-align:center">(var)</td>
<td style="text-align:left">映射变量(字典参数)</td>
</tr>
<tr>
<td style="text-align:center">m.n.</td>
<td style="text-align:left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody>
</table>
<hr>
<p>三引号</p>
<p>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">para_str = <span class="string">"""这是一个多行字符串的实例</span></div><div class="line"><span class="string">多行字符串可以使用制表符</span></div><div class="line"><span class="string">TAB ( \t )。</span></div><div class="line"><span class="string">也可以使用换行符 [ \n ]。</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">print</span> (para_str)</div></pre></td></tr></table></figure></p>
<p>以上实例执行结果为：</p>
<pre><code>这是一个多行字符串的实例
多行字符串可以使用制表符
TAB (    )。
也可以使用换行符 [
 ]。
</code></pre><p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。</p>
<p>一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">errHTML = <span class="string">'''</span></div><div class="line"><span class="string">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span></div><div class="line"><span class="string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span></div><div class="line"><span class="string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span></div><div class="line"><span class="string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span></div><div class="line"><span class="string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span></div><div class="line"><span class="string">ONCLICK="window.history.back()"&gt;&lt;/FORM&gt;</span></div><div class="line"><span class="string">&lt;/BODY&gt;&lt;/HTML&gt;</span></div><div class="line"><span class="string">'''</span></div><div class="line">cursor.execute(<span class="string">'''</span></div><div class="line"><span class="string">CREATE TABLE users (  </span></div><div class="line"><span class="string">login VARCHAR(8),</span></div><div class="line"><span class="string">uid INTEGER,</span></div><div class="line"><span class="string">prid INTEGER)</span></div><div class="line"><span class="string">'''</span>)</div></pre></td></tr></table></figure>
<hr>
<p>Unicode 字符串</p>
<p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀<strong>u</strong>。</p>
<p>在Python3中，所有的字符串都是Unicode字符串。</p>
<hr>
<p>Python 的字符串内建函数</p>
<p>Python 的字符串常用内建函数如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="http://www.runoob.com/python3/python3-string-capitalize.html" target="_blank" rel="external">capitalize()</a> 将字符串的第一个字符转换为大写</td>
</tr>
<tr>
<td>2</td>
<td><a href="http://www.runoob.com/python3/python3-string-center.html" target="_blank" rel="external">center(width,fillchar)</a> 返回一个指定的宽度 width居中的字符串，fillchar为填充的字符，默认为空格。</td>
</tr>
<tr>
<td>3</td>
<td><a href="http://www.runoob.com/python3/python3-string-count.html" target="_blank" rel="external">count(str, beg=0,end=len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str出现的次数</td>
</tr>
<tr>
<td>4</td>
<td><a href="http://www.runoob.com/python3/python3-string-decode.html" target="_blank" rel="external">bytes.decode(encoding=”utf-8”, errors=”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由str.encode() 来编码返回。</td>
</tr>
<tr>
<td>5</td>
<td><a href="http://www.runoob.com/python3/python3-string-encode.html" target="_blank" rel="external">encode(encoding=’UTF-8’,errors=’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError的异常，除非 errors 指定的是’ignore’或者’replace’</td>
</tr>
<tr>
<td>6</td>
<td>[endswith(suffix, beg=0,</td>
</tr>
<tr>
<td></td>
<td>end=len(string))](<a href="http://www.runoob.com/python3/python" target="_blank" rel="external">http://www.runoob.com/python3/python</a></td>
</tr>
<tr>
<td></td>
<td>3-string-endswith.html)\</td>
</tr>
<tr>
<td></td>
<td>检查字符串是否以 obj</td>
</tr>
<tr>
<td></td>
<td>结束，如果beg 或者 end</td>
</tr>
<tr>
<td></td>
<td>指定则检查指定的范围内是否以 obj</td>
</tr>
<tr>
<td></td>
<td>结束，如果是，返回 True,否则返回</td>
</tr>
<tr>
<td></td>
<td>False.</td>
</tr>
<tr>
<td>7</td>
<td>[expandtabs(tabsize=8)](<a href="http://www.runoob.com/python3/" target="_blank" rel="external">http://www.runoob.com/python3/</a></td>
</tr>
<tr>
<td></td>
<td>python3-string-expandtabs.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>把字符串 string 中的 tab</td>
</tr>
<tr>
<td></td>
<td>符号转为空格，tab</td>
</tr>
<tr>
<td></td>
<td>符号默认的空格数是 8 。</td>
</tr>
<tr>
<td>8</td>
<td>[find(str, beg=0</td>
</tr>
<tr>
<td></td>
<td>end=len(string))](<a href="http://www.runoob.com/python3/python" target="_blank" rel="external">http://www.runoob.com/python3/python</a></td>
</tr>
<tr>
<td></td>
<td>3-string-find.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>检测 str 是否包含在字符串中</td>
</tr>
<tr>
<td></td>
<td>中，如果 beg 和 end</td>
</tr>
<tr>
<td></td>
<td>指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则</td>
</tr>
<tr>
<td></td>
<td>返回-1</td>
</tr>
<tr>
<td>9</td>
<td>[index(str, beg=0,</td>
</tr>
<tr>
<td></td>
<td>end=len(string))](<a href="http://www.runoob.com/python3/python" target="_blank" rel="external">http://www.runoob.com/python3/python</a></td>
</tr>
<tr>
<td></td>
<td>3-string-index.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td>10</td>
<td>[isalnum()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isalnum.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串至少有一个字符并且所有字符都是字母或数字则返</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>回 True,否则返回 False</td>
</tr>
<tr>
<td>11</td>
<td>[isalpha()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isalpha.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串至少有一个字符并且所有字符都是字母则返回</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>True, 否则返回 False</td>
</tr>
<tr>
<td>12</td>
<td>[isdigit()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isdigit.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串只包含数字则返回 True</td>
</tr>
<tr>
<td></td>
<td>否则返回 False..</td>
</tr>
<tr>
<td>13</td>
<td>[islower()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-islower.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写</td>
</tr>
<tr>
<td></td>
<td>的)字符都是小写，则返回</td>
</tr>
<tr>
<td></td>
<td>True，否则返回 False</td>
</tr>
<tr>
<td>14</td>
<td>[isnumeric()](<a href="http://www.runoob.com/python3/python3-st" target="_blank" rel="external">http://www.runoob.com/python3/python3-st</a></td>
</tr>
<tr>
<td></td>
<td>ring-isnumeric.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串中只包含数字字符，则返回</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>True，否则返回 False</td>
</tr>
<tr>
<td>15</td>
<td>[isspace()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isspace.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串中只包含空格，则返回</td>
</tr>
<tr>
<td></td>
<td>True，否则返回 False.</td>
</tr>
<tr>
<td>16</td>
<td>[istitle()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-istitle.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串是标题化的(见</td>
</tr>
<tr>
<td></td>
<td>title())则返回 True，否则返回</td>
</tr>
<tr>
<td></td>
<td>False</td>
</tr>
<tr>
<td>17</td>
<td>[isupper()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isupper.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写</td>
</tr>
<tr>
<td></td>
<td>的)字符都是大写，则返回</td>
</tr>
<tr>
<td></td>
<td>True，否则返回 False</td>
</tr>
<tr>
<td>18</td>
<td>[join(seq)](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-join.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>以指定字符串作为分隔符，将 seq</td>
</tr>
<tr>
<td></td>
<td>中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr>
<td>19</td>
<td>[len(string)](<a href="http://www.runoob.com/python3/python3-st" target="_blank" rel="external">http://www.runoob.com/python3/python3-st</a></td>
</tr>
<tr>
<td></td>
<td>ring-len.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回字符串长度</td>
</tr>
<tr>
<td>20</td>
<td>[ljust(width[,</td>
</tr>
<tr>
<td></td>
<td>fillchar])](<a href="http://www.runoob.com/python3/python3-str" target="_blank" rel="external">http://www.runoob.com/python3/python3-str</a></td>
</tr>
<tr>
<td></td>
<td>ing-ljust.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回一个原字符串左对齐,并使用</td>
</tr>
<tr>
<td></td>
<td>fillchar 填充至长度 width</td>
</tr>
<tr>
<td></td>
<td>的新字符串，fillchar 默认为空格。</td>
</tr>
<tr>
<td>21</td>
<td>[lower()](<a href="http://www.runoob.com/python3/python3-string" target="_blank" rel="external">http://www.runoob.com/python3/python3-string</a></td>
</tr>
<tr>
<td></td>
<td>-lower.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>转换字符串中所有大写字符为小写.</td>
</tr>
<tr>
<td>22</td>
<td>[lstrip()](<a href="http://www.runoob.com/python3/python3-strin" target="_blank" rel="external">http://www.runoob.com/python3/python3-strin</a></td>
</tr>
<tr>
<td></td>
<td>g-lstrip.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>截掉字符串左边的空格</td>
</tr>
<tr>
<td>23</td>
<td>[maketrans()](<a href="http://www.runoob.com/python3/python3-st" target="_blank" rel="external">http://www.runoob.com/python3/python3-st</a></td>
</tr>
<tr>
<td></td>
<td>ring-maketrans.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参</td>
</tr>
<tr>
<td></td>
<td>数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标</td>
</tr>
<tr>
<td></td>
<td>。</td>
</tr>
<tr>
<td>24</td>
<td>[max(str)](<a href="http://www.runoob.com/python3/python3-strin" target="_blank" rel="external">http://www.runoob.com/python3/python3-strin</a></td>
</tr>
<tr>
<td></td>
<td>g-max.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回字符串 str 中最大的字母。</td>
</tr>
<tr>
<td>25</td>
<td>[min(str)](<a href="http://www.runoob.com/python3/python3-strin" target="_blank" rel="external">http://www.runoob.com/python3/python3-strin</a></td>
</tr>
<tr>
<td></td>
<td>g-min.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回字符串 str 中最小的字母。</td>
</tr>
<tr>
<td>26</td>
<td>[replace(old, new [,</td>
</tr>
<tr>
<td></td>
<td>max])](<a href="http://www.runoob.com/python3/python3-string-r" target="_blank" rel="external">http://www.runoob.com/python3/python3-string-r</a></td>
</tr>
<tr>
<td></td>
<td>eplace.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>把 将字符串中的 str1 替换成</td>
</tr>
<tr>
<td></td>
<td>str2,如果 max 指定，则替换不超过</td>
</tr>
<tr>
<td></td>
<td>max 次。</td>
</tr>
<tr>
<td>27</td>
<td>[rfind(str,</td>
</tr>
<tr>
<td></td>
<td>beg=0,end=len(string))](<a href="http://www.runoob.com/python3/" target="_blank" rel="external">http://www.runoob.com/python3/</a></td>
</tr>
<tr>
<td></td>
<td>python3-string-rfind.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>类似于</td>
</tr>
<tr>
<td></td>
<td>find()函数，不过是从右边开始查找.</td>
</tr>
<tr>
<td>28</td>
<td>[rindex( str, beg=0,</td>
</tr>
<tr>
<td></td>
<td>end=len(string))](<a href="http://www.runoob.com/python3/python" target="_blank" rel="external">http://www.runoob.com/python3/python</a></td>
</tr>
<tr>
<td></td>
<td>3-string-rindex.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>类似于 index()，不过是从右边开始.</td>
</tr>
<tr>
<td>29</td>
<td>[rjust(width,[,</td>
</tr>
<tr>
<td></td>
<td>fillchar])](<a href="http://www.runoob.com/python3/python3-str" target="_blank" rel="external">http://www.runoob.com/python3/python3-str</a></td>
</tr>
<tr>
<td></td>
<td>ing-rjust.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长</td>
</tr>
<tr>
<td></td>
<td>度</td>
</tr>
<tr>
<td></td>
<td>width 的新字符串</td>
</tr>
<tr>
<td>30</td>
<td>[rstrip()](<a href="http://www.runoob.com/python3/python3-strin" target="_blank" rel="external">http://www.runoob.com/python3/python3-strin</a></td>
</tr>
<tr>
<td></td>
<td>g-rstrip.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>删除字符串字符串末尾的空格.</td>
</tr>
<tr>
<td>31</td>
<td>[split(str=””,</td>
</tr>
<tr>
<td></td>
<td>num=string.count(str))](<a href="http://www.runoob.com/python3/" target="_blank" rel="external">http://www.runoob.com/python3/</a></td>
</tr>
<tr>
<td></td>
<td>python3-string-split.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>num=string.count(str)) 以 str</td>
</tr>
<tr>
<td></td>
<td>为分隔符截取字符串，如果 num</td>
</tr>
<tr>
<td></td>
<td>有指定值，则仅截取 num 个子字符串</td>
</tr>
<tr>
<td>32</td>
<td>[splitlines([keepends])]<a href="http://www.runoob.com(/pytho" target="_blank" rel="external">http://www.runoob.com(/pytho</a></td>
</tr>
<tr>
<td></td>
<td>n3/python3-string-splitlines.html</td>
</tr>
<tr>
<td></td>
<td>)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>按照行(‘\r’, ‘\r\n’,</td>
</tr>
<tr>
<td></td>
<td>\n’)分隔，返回一个包含各行作为元素的列表，如果参数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>keepends 为</td>
</tr>
<tr>
<td></td>
<td>False，不包含换行符，如果为</td>
</tr>
<tr>
<td></td>
<td>True，则保留换行符。</td>
</tr>
<tr>
<td>33</td>
<td>[startswith(str,</td>
</tr>
<tr>
<td></td>
<td>beg=0,end=len(string))](<a href="http://www.runoob.com/python3/" target="_blank" rel="external">http://www.runoob.com/python3/</a></td>
</tr>
<tr>
<td></td>
<td>python3-string-startswith.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>检查字符串是否是以 obj</td>
</tr>
<tr>
<td></td>
<td>开头，是则返回 True，否则返回</td>
</tr>
<tr>
<td></td>
<td>False。如果beg 和 end</td>
</tr>
<tr>
<td></td>
<td>指定值，则在指定范围内检查。</td>
</tr>
<tr>
<td>34</td>
<td>[strip([chars])](<a href="http://www.runoob.com/python3/pytho" target="_blank" rel="external">http://www.runoob.com/python3/pytho</a></td>
</tr>
<tr>
<td></td>
<td>n3-string-strip.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>在字符串上执行 lstrip()和</td>
</tr>
<tr>
<td></td>
<td>rstrip()</td>
</tr>
<tr>
<td>35</td>
<td>[swapcase()](<a href="http://www.runoob.com/python3/python3-str" target="_blank" rel="external">http://www.runoob.com/python3/python3-str</a></td>
</tr>
<tr>
<td></td>
<td>ing-swapcase.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>将字符串中大写转换为小写，小写转换为大写</td>
</tr>
<tr>
<td>36</td>
<td>[title()](<a href="http://www.runoob.com/python3/python3-string" target="_blank" rel="external">http://www.runoob.com/python3/python3-string</a></td>
</tr>
<tr>
<td></td>
<td>-title.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为</td>
</tr>
<tr>
<td></td>
<td>小写(见</td>
</tr>
<tr>
<td></td>
<td>istitle())</td>
</tr>
<tr>
<td>37</td>
<td>[translate(table,</td>
</tr>
<tr>
<td></td>
<td>deletechars=””)](<a href="http://www.runoob.com/python3/python3" target="_blank" rel="external">http://www.runoob.com/python3/python3</a></td>
</tr>
<tr>
<td></td>
<td>-string-translate.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>根据 str 给出的表(包含 256</td>
</tr>
<tr>
<td></td>
<td>个字符)转换 string 的字符,</td>
</tr>
<tr>
<td></td>
<td>要过滤掉的字符放到 deletechars</td>
</tr>
<tr>
<td></td>
<td>参数中</td>
</tr>
<tr>
<td>38</td>
<td>[upper()](<a href="http://www.runoob.com/python3/python3-string" target="_blank" rel="external">http://www.runoob.com/python3/python3-string</a></td>
</tr>
<tr>
<td></td>
<td>-upper.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>转换字符串中的小写字母为大写</td>
</tr>
<tr>
<td>39</td>
<td>[zfill</td>
</tr>
<tr>
<td></td>
<td>(width)](<a href="http://www.runoob.com/python3/python3-string-" target="_blank" rel="external">http://www.runoob.com/python3/python3-string-</a></td>
</tr>
<tr>
<td></td>
<td>zfill.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回长度为 width</td>
</tr>
<tr>
<td></td>
<td>的字符串，原字符串右对齐，前面填充0</td>
</tr>
<tr>
<td>40</td>
<td>[isdecimal()](<a href="http://www.runoob.com/python3/python3-st" target="_blank" rel="external">http://www.runoob.com/python3/python3-st</a></td>
</tr>
<tr>
<td></td>
<td>ring-isdecimal.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>检查字符串是否只包含十进制字符，如果是返回</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>true，否则返回 false。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Python3-列表"><a href="#Python3-列表" class="headerlink" title="Python3 列表"></a>Python3 列表</h2><p>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 -<br>它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。</p>
<p>Python有6个序列的内置类型，但最常见的是列表和元组。</p>
<p>序列都可以进行的操作包括索引，切片，加，乘，检查成员。</p>
<p>此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
<p>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。</p>
<p>列表的数据项不需要具有相同的类型</p>
<p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</p>
<pre><code>list1 = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000];
list2 = [1, 2, 3, 4, 5 ];
list3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
</code></pre><p>与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。</p>
<hr>
<p>访问列表中的值</p>
<p>使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示：</p>
<pre><code>#!/usr/bin/python3

list1 = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000];
list2 = [1, 2, 3, 4, 5, 6, 7 ];

print (&quot;list1[0]: &quot;, list1[0])
print (&quot;list2[1:5]: &quot;, list2[1:5])
</code></pre><p>以上实例输出结果：</p>
<pre><code>list1[0]:  Google
list2[1:5]:  [2, 3, 4, 5]
</code></pre><hr>
<p>更新列表</p>
<p>你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示：</p>
<pre><code>#!/usr/bin/python3

list = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000]

print (&quot;第三个元素为 : &quot;, list[2])
list[2] = 2001
print (&quot;更新后的第三个元素为 : &quot;, list[2])
</code></pre><p>以上实例输出结果：</p>
<pre><code>第三个元素为 :  1997
更新后的第三个元素为 :  2001
</code></pre><hr>
<p> 删除列表元素</p>
<p>可以使用 del 语句来删除列表的的元素，如下实例：</p>
<pre><code>#!/usr/bin/python3

list = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000]

print (list)
del list[2]
print (&quot;删除第三个元素 : &quot;, list)
</code></pre><p>以上实例输出结果：</p>
<pre><code>删除第三个元素 :  [&apos;Google&apos;, &apos;Runoob&apos;, 2000]
</code></pre><hr>
<p>列表脚本操作符</p>
<p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，*<br>号用于重复列表。</p>
<p>如下所示：</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len([1, 2, 3])</td>
<td>3</td>
<td>长度</td>
</tr>
<tr>
<td>[1, 2, 3] + [4, 5, 6]</td>
<td>[1, 2, 3, 4, 5, 6]</td>
<td>组合</td>
</tr>
<tr>
<td>[‘Hi!’] * 4</td>
<td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td>重复</td>
</tr>
<tr>
<td>3 in [1, 2, 3]</td>
<td>True</td>
<td>元素是否存在于列表中</td>
</tr>
<tr>
<td>for x in [1, 2, 3]: print x,</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody>
</table>
<hr>
<p>列表截取与拼接</p>
<p>Python的列表截取与字符串操作类型，如下所示：</p>
<pre><code>L=[&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;]
</code></pre><p>操作：</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>L[2]</td>
<td>‘Taobao’</td>
<td>读取第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td>‘Runoob’</td>
<td>从右侧开始读取倒数第二个元素: count from the right</td>
</tr>
<tr>
<td>L[1:]</td>
<td>[‘Runoob’, ‘Taobao’]</td>
<td>输出从第二个元素开始后的所有元素</td>
</tr>
</tbody>
</table>
<pre><code>&gt;&gt;&gt; L=[&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;]
&gt;&gt;&gt; L[2]
&apos;Taobao&apos;
&gt;&gt;&gt; L[-2]
&apos;Runoob&apos;
&gt;&gt;&gt; L[1:]
[&apos;Runoob&apos;, &apos;Taobao&apos;]
&gt;&gt;&gt;
</code></pre><p>列表还支持拼接操作：</p>
<pre><code>&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]
&gt;&gt;&gt; squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre><hr>
<p>嵌套列表</p>
<p>使用嵌套列表即在列表里创建其它列表，例如：</p>
<pre><code>&gt;&gt;&gt; a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
&gt;&gt;&gt; n = [1, 2, 3]
&gt;&gt;&gt; x = [a, n]
&gt;&gt;&gt; x
[[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]]
&gt;&gt;&gt; x[0]
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
&gt;&gt;&gt; x[0][1]
&apos;b&apos;
</code></pre><hr>
<p>列表函数&amp;方法</p>
<p>Python包含以下函数:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="python3-att-list-len.html">len(list)</a>         列表元素个数</td>
</tr>
<tr>
<td>2</td>
<td><a href="python3-att-list-max.html">max(list)</a>        返回列表元素最大值</td>
</tr>
<tr>
<td>3</td>
<td><a href="python3-att-list-min.html">min(list)</a>         返回列表元素最小值</td>
</tr>
<tr>
<td>4</td>
<td><a href="python3-att-list-list.html">list(seq)</a>         将元组转换为列表</td>
</tr>
</tbody>
</table>
<p>Python包含以下方法:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="python3-att-list-append.html">list.append(obj)</a>  在列表末尾添加新的对象</td>
</tr>
<tr>
<td>2</td>
<td><a href="python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td>3</td>
<td><a href="python3-att-list-extend.html">list.extend(seq)</a>  在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td>4</td>
<td><a href="python3-att-list-index.html">list.index(obj)</a>        从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td>5</td>
<td><a href="python3-att-list-insert.html">list.insert(index, obj)</a>  将对象插入列表</td>
</tr>
<tr>
<td>6</td>
<td><a href="python3-att-list-pop.html">list.pop(obj=list[-1])</a>   移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td>7</td>
<td><a href="python3-att-list-remove.html">list.remove(obj)</a>         移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td>8</td>
<td><a href="python3-att-list-reverse.html">list.reverse()</a>          反向列表中元素</td>
</tr>
<tr>
<td>9</td>
<td><a href="python3-att-list-sort.html">list.sort([func])</a>          对原列表进行排序</td>
</tr>
<tr>
<td>10</td>
<td><a href="python3-att-list-clear.html">list.clear()</a>         清空列表</td>
</tr>
<tr>
<td>11</td>
<td><a href="python3-att-list-copy.html">list.copy()</a>         复制列表</td>
</tr>
</tbody>
</table>
<p><a href="http://www.cnblogs.com/lhj588/archive/2012/01/06/2314181.html" target="_blank" rel="external">http://www.cnblogs.com/lhj588/archive/2012/01/06/2314181.html</a></p>
<hr>
<h2 id="Python3-元组"><a href="#Python3-元组" class="headerlink" title="Python3 元组"></a>Python3 元组</h2><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p>
<p>元组使用小括号，列表使用方括号。</p>
<p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>
<p>如下实例：</p>
<pre><code>tup1 = (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000);
tup2 = (1, 2, 3, 4, 5 );
tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;;
</code></pre><p>创建空元组</p>
<pre><code>tup1 = ();
</code></pre><p>元组中只包含一个元素时，需要在元素后面添加逗号</p>
<pre><code>tup1 = (50,);
</code></pre><p>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p>
<hr>
<p>访问元组</p>
<p>元组可以使用下标索引来访问元组中的值，如下实例:</p>
<pre><code>#!/usr/bin/python3

tup1 = (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000)
tup2 = (1, 2, 3, 4, 5, 6, 7 )

print (&quot;tup1[0]: &quot;, tup1[0])
print (&quot;tup2[1:5]: &quot;, tup2[1:5])
</code></pre><p>以上实例输出结果：</p>
<pre><code>tup1[0]:  Google
tup2[1:5]:  (2, 3, 4, 5)
</code></pre><hr>
<p>修改元组</p>
<p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p>
<pre><code>#!/usr/bin/python3

tup1 = (12, 34.56);
tup2 = (&apos;abc&apos;, &apos;xyz&apos;)

# 以下修改元组元素操作是非法的。
# tup1[0] = 100

# 创建一个新的元组
tup3 = tup1 + tup2;
print (tup3)
</code></pre><p>以上实例输出结果：</p>
<pre><code>(12, 34.56, &apos;abc&apos;, &apos;xyz&apos;)
</code></pre><hr>
<p>删除元组</p>
<p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p>
<pre><code>#!/usr/bin/python3

tup = (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000)

print (tup)
del tup;
print (&quot;删除后的元组 tup : &quot;)
print (tup)
</code></pre><p>以上实例元组被删除后，输出变量会有异常信息，输出如下所示：</p>
<pre><code>删除后的元组 tup :
Traceback (most recent call last):
  File &quot;test.py&quot;, line 8, in &lt;module&gt;
    print (tup)
NameError: name &apos;tup&apos; is not defined
</code></pre><hr>
<p>元组运算符</p>
<p>与字符串一样，元组之间可以使用 + 号和 *<br>号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len((1, 2, 3))</td>
<td>3</td>
<td>计算元素个数</td>
</tr>
<tr>
<td>(1, 2, 3) + (4, 5, 6)</td>
<td>(1, 2, 3, 4, 5, 6)</td>
<td>连接</td>
</tr>
<tr>
<td>(‘Hi!’,) * 4</td>
<td>(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td>
<td>复制</td>
</tr>
<tr>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>元素是否存在</td>
</tr>
<tr>
<td>for x in (1, 2, 3): print x,</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody>
</table>
<hr>
<p>元组索引，截取</p>
<p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：</p>
<p>元组：</p>
<pre><code>L = (&apos;Google&apos;, &apos;Taobao&apos;, &apos;Runoob&apos;)
</code></pre><table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>L[2]</td>
<td>‘Runoob!’</td>
<td>读取第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td>‘Taobao’</td>
<td>反向读取；读取倒数第二个元素</td>
</tr>
<tr>
<td>L[1:]</td>
<td>(‘Taobao’, ‘Runoob!’)</td>
<td>截取元素，从第二个开始后的所有元素。</td>
</tr>
</tbody>
</table>
<p>运行实例如下：</p>
<pre><code>&gt;&gt;&gt; L = (&apos;Google&apos;, &apos;Taobao&apos;, &apos;Runoob&apos;)
&gt;&gt;&gt; L[2]
&apos;Runoob&apos;
&gt;&gt;&gt; L[-2]
&apos;Taobao&apos;
&gt;&gt;&gt; L[1:]
(&apos;Taobao&apos;, &apos;Runoob&apos;)
</code></pre><hr>
<p>元组内置函数</p>
<p>Python元组包含了以下内置函数</p>
<p>序号<br>方法及描述<br>实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line">len(tuple)\</div><div class="line">计算元组元素个数。</div><div class="line">    &gt;&gt;&gt; tuple1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>)</div><div class="line">    &gt;&gt;&gt; len(tuple1)</div><div class="line">    <span class="number">3</span></div><div class="line">    &gt;&gt;&gt;</div><div class="line"></div><div class="line"><span class="number">2</span></div><div class="line">max(tuple)\</div><div class="line">返回元组中元素最大值。</div><div class="line">    &gt;&gt;&gt; tuple2 = (<span class="string">'5'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>)</div><div class="line">    &gt;&gt;&gt; max(tuple2)</div><div class="line">    <span class="string">'8'</span></div><div class="line">    &gt;&gt;&gt;</div><div class="line"></div><div class="line"><span class="number">3</span></div><div class="line">min(tuple)</div><div class="line">返回元组中元素最小值。</div><div class="line"></div><div class="line"></div><div class="line">    &gt;&gt;&gt; tuple2 = (<span class="string">'5'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>)</div><div class="line">    &gt;&gt;&gt; min(tuple2)</div><div class="line">    <span class="string">'4'</span></div><div class="line">    &gt;&gt;&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="number">4</span></div><div class="line">tuple(seq)</div><div class="line">将列表转换为元组。</div><div class="line"></div><div class="line"></div><div class="line">    &gt;&gt;&gt; list1= [<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Baidu'</span>]</div><div class="line">    &gt;&gt;&gt; tuple1=tuple(list1)</div><div class="line">    &gt;&gt;&gt; tuple1</div><div class="line">    (<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Baidu'</span>)</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="Python3-字典"><a href="#Python3-字典" class="headerlink" title="Python3 字典"></a>Python3 字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值(key=&gt;value)对用冒号(<strong>:</strong>)分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号(<strong>{})</strong>中<br>,格式如下所示：</p>
<pre><code>d = {key1 : value1, key2 : value2 }
</code></pre><p>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p>
<p>一个简单的字典实例：</p>
<pre><code>dict = {&apos;Alice&apos;: &apos;2341&apos;, &apos;Beth&apos;: &apos;9102&apos;, &apos;Cecil&apos;: &apos;3258&apos;}
</code></pre><p>也可如此创建字典：</p>
<pre><code>dict1 = { &apos;abc&apos;: 456 };
dict2 = { &apos;abc&apos;: 123, 98.6: 37 };
</code></pre><hr>
<p>访问字典里的值</p>
<p>把相应的键放入熟悉的方括弧，如下实例:</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;}

print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])
print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])
</code></pre><p>以上实例输出结果：</p>
<pre><code>dict[&apos;Name&apos;]:  Runoob
dict[&apos;Age&apos;]:  7
</code></pre><p>如果用字典里没有的键访问数据，会输出错误如下：</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;};

print (&quot;dict[&apos;Alice&apos;]: &quot;, dict[&apos;Alice&apos;])
</code></pre><p>以上实例输出结果：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 5, in &lt;module&gt;
    print (&quot;dict[&apos;Alice&apos;]: &quot;, dict[&apos;Alice&apos;])
KeyError: &apos;Alice&apos;
</code></pre><hr>
<p>修改字典</p>
<p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;}

dict[&apos;Age&apos;] = 8;               # 更新 Age
dict[&apos;School&apos;] = &quot;菜鸟教程&quot;  # 添加信息


print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])
print (&quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;])
</code></pre><p>以上实例输出结果：<br>    dict[‘Age’]:  8<br>    dict[‘School’]:  菜鸟教程</p>
<hr>
<p>删除字典元素</p>
<p>能删单一的元素也能清空字典，清空只需一项操作。</p>
<p>显示删除一个字典用del命令，如下实例：</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;}

del dict[&apos;Name&apos;] # 删除键 &apos;Name&apos;
dict.clear()     # 删除字典
del dict         # 删除字典

print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])
print (&quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;])
</code></pre><p>但这会引发一个异常，因为用执行 del 操作后字典不再存在：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 9, in &lt;module&gt;
    print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])
TypeError: &apos;type&apos; object is not subscriptable
</code></pre><p><strong>注：</strong>del() 方法后面也会讨论。</p>
<hr>
<p>字典键的特性</p>
<p>字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住：</p>
<p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Name&apos;: &apos;小菜鸟&apos;}

print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])
</code></pre><p>以上实例输出结果：</p>
<pre><code>dict[&apos;Name&apos;]:  小菜鸟
</code></pre><p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</p>
<pre><code>#!/usr/bin/python3

dict = {[&apos;Name&apos;]: &apos;Runoob&apos;, &apos;Age&apos;: 7}

print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])
</code></pre><p>以上实例输出结果：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 3, in &lt;module&gt;
    dict = {[&apos;Name&apos;]: &apos;Runoob&apos;, &apos;Age&apos;: 7}
TypeError: unhashable type: &apos;list&apos;
</code></pre><hr>
<p>字典内置函数&amp;方法</p>
<p>Python字典包含了以下内置函数：</p>
<p>+———————–+———————–+———————–+<br>| 序号                  | 函数及描述            | 实例                  |<br>+=======================+=======================+=======================+<br>| 1                     | len(dict)\            |     &gt;&gt;&gt; dict = {‘Name |<br>|                       | 计算字典元素个数，即键的总数。 | ‘: ‘Runoob’, ‘Age’: 7 |<br>|                       |                       | , ‘Class’: ‘First’}   |<br>|                       |                       |     &gt;&gt;&gt; len(dict)     |<br>|                       |                       |     3                 |<br>+———————–+———————–+———————–+<br>| 2                     | str(dict)\            |     &gt;&gt;&gt; dict = {‘Name |<br>|                       | 输出字典，以可打印的字符串表示。 | ‘: ‘Runoob’, ‘Age’: 7 |<br>|                       |                       | , ‘Class’: ‘First’}   |<br>|                       |                       |     &gt;&gt;&gt; str(dict)     |<br>|                       |                       |     “{‘Name’: ‘Runoob |<br>|                       |                       | ‘, ‘Class’: ‘First’,  |<br>|                       |                       | ‘Age’: 7}”            |<br>+———————–+———————–+———————–+<br>| 3                     | type(variable)\       |     &gt;&gt;&gt; dict = {‘Name |<br>|                       | 返回输入的变量类型，如果变量是字典就返回字 | ‘: ‘Runoob’, ‘Age’: 7 |<br>|                       | 典类型。              | , ‘Class’: ‘First’}   |<br>|                       |                       |     &gt;&gt;&gt; type(dict)    |<br>|                       |                       |     <class 'dict'="">    |<br>+———————–+———————–+———————–+</class></p>
<p>Python字典包含了以下内置方法：</p>
<hr>
<p>  序号   函数及描述</p>
<hr>
<p>  1      <a href="python3-att-dictionary-clear.html">radiansdict.clear()</a>\<br>         删除字典内所有元素</p>
<p>  2      <a href="python3-att-dictionary-copy.html">radiansdict.copy()</a>\<br>         返回一个字典的浅复制</p>
<p>  3      <a href="python3-att-dictionary-fromkeys.html">radiansdict.fromkeys()</a>\<br>         创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</p>
<p>  4      <a href="python3-att-dictionary-get.html">radiansdict.get(key, default=None)</a>\<br>         返回指定键的值，如果值不在字典中返回default值</p>
<p>  5      <a href="python3-att-dictionary-in.html">key in dict</a>\<br>         如果键在字典dict里返回true，否则返回false</p>
<p>  6      <a href="python3-att-dictionary-items.html">radiansdict.items()</a>\<br>         以列表返回可遍历的(键, 值) 元组数组</p>
<p>  7      <a href="python3-att-dictionary-keys.html">radiansdict.keys()</a>\<br>         以列表返回一个字典所有的键</p>
<p>  8      <a href="python3-att-dictionary-setdefault.html">radiansdict.setdefault(key, default=None)</a>\<br>         和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</p>
<p>  9      <a href="python3-att-dictionary-update.html">radiansdict.update(dict2)</a>\<br>         把字典dict2的键/值对更新到dict里</p>
<p>  10     <a href="python3-att-dictionary-values.html">radiansdict.values()</a>\</p>
<pre><code>以列表返回字典中的所有值
</code></pre><hr>
<hr>
<h2 id="Python3-Set"><a href="#Python3-Set" class="headerlink" title="Python3 Set"></a>Python3 Set</h2><p><a href="http://www.cnblogs.com/panwenbin-logs/p/5519617.html" target="_blank" rel="external">python中set和frozenset方法和区别</a></p>
<hr>
<h2 id="Python3-编程第一步"><a href="#Python3-编程第一步" class="headerlink" title="Python3 编程第一步"></a>Python3 编程第一步</h2><p>在前面的教程中我们已经学习了一些 Python3<br>的基本语法知识，下面我们尝试来写一个斐波纳契数列。</p>
<p>实例如下：</p>
<pre><code>#!/usr/bin/python3

# Fibonacci series: 斐波纳契数列
# 两个元素的总和确定了下一个数
a, b = 0, 1
while b &lt; 10:
    print(b)
    a, b = b, a+b
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>1
1
2
3
5
8
</code></pre><p>这个例子介绍了几个新特征。</p>
<ul>
<li>第一行包含了一个复合赋值：变量 a 和 b 同时得到新值 0 和<br>1。最后一行再次使用了同样的方法，可以看到，右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。</li>
</ul>
<!-- -->
<pre><code>&gt;&gt;&gt; i = 256*256
&gt;&gt;&gt; print(&apos;i 的值为：&apos;, i)
i 的值为： 65536
</code></pre><hr>
<p>end 关键字</p>
<p>关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：</p>
<pre><code>#!/usr/bin/python3

# Fibonacci series: 斐波纳契数列
# 两个元素的总和确定了下一个数
a, b = 0, 1
while b &lt; 1000:
    print(b, end=&apos;,&apos;)
    a, b = b, a+b
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
</code></pre><hr>
<h2 id="Python3-条件控制"><a href="#Python3-条件控制" class="headerlink" title="Python3 条件控制"></a>Python3 条件控制</h2><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。</p>
<p>可以通过下图来简单了解条件语句的执行过程:</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2013/11/if-condition.jpg" alt=""></p>
<hr>
<p>if 语句</p>
<p>Python中if语句的一般形式如下所示：</p>
<pre><code>if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
</code></pre><ul>
<li>如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句</li>
<li>如果 “condition_1” 为False，将判断 “condition_2”</li>
<li>如果”condition_2” 为 True 将执行 “statement_block_2” 块语句</li>
<li>如果 “condition_2” 为False，将执行”statement_block_3”块语句</li>
</ul>
<p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if –<br>elif – else</strong>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、每个条件后面要使用冒号（:），表示接下来是满足条件后要执行的语句块。</li>
<li>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li>
<li>3、在Python中没有switch – case语句。</li>
</ul>
<hr>
<p>实例</p>
<p>以下是一个简单的 if 实例：</p>
<pre><code>#!/usr/bin/python3

var1 = 100
if var1:
   print (&quot;1 - if 表达式条件为 true&quot;)
   print (var1)

var2 = 0
if var2:
   print (&quot;2 - if 表达式条件为 true&quot;)
   print (var2)
print (&quot;Good bye!&quot;)
</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>1 - if 表达式条件为 true
100
Good bye!
</code></pre><p>从结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行。</p>
<p>以下实例演示了狗的年龄计算判断：</p>
<pre><code>#!/usr/bin/python3

age = int(input(&quot;请输入你家狗狗的年龄: &quot;))
print(&quot;&quot;)
if age &lt; 0:
    print(&quot;你是在逗我吧!&quot;)
elif age == 1:
    print(&quot;相当于 14 岁的人。&quot;)
elif age == 2:
    print(&quot;相当于 22 岁的人。&quot;)
elif age &gt; 2:
    human = 22 + (age -2)*5
    print(&quot;对应人类年龄: &quot;, human)

### 退出提示
input(&quot;点击 enter 键退出&quot;)
</code></pre><p>将以上脚本保存在dog.py文件中，并执行该脚本：</p>
<pre><code>$ python3 dog.py
请输入你家狗狗的年龄: 1

相当于 14 岁的人。
点击 enter 键退出
</code></pre><p>以下为if中常用的操作运算符:</p>
<p>  操作符   描述</p>
<p>  <code>&lt;</code>      小于<br>  <code>&lt;=</code>     小于或等于<br>  <code>&gt;</code>      大于<br>  <code>&gt;=</code>     大于或等于<br>  <code>==</code>     等于，比较对象是否相等<br>  <code>!=</code>     不等于</p>
<hr>
<p>实例</p>
<pre><code>#!/usr/bin/python3

# 程序演示了 == 操作符
# 使用数字
print(5 == 6)
# 使用变量
x = 5
y = 8
print(x == y)
</code></pre><p>以上实例输出结果：</p>
<pre><code>False
False
</code></pre><p>high_low.py文件演示了数字的比较运算：</p>
<pre><code>#!/usr/bin/python3

# 该实例演示了数字猜谜游戏
number = 7
guess = -1
print(&quot;数字猜谜游戏!&quot;)
while guess != number:
    guess = int(input(&quot;请输入你猜的数字：&quot;))

    if guess == number:
        print(&quot;恭喜，你猜对了！&quot;)
    elif guess &lt; number:
        print(&quot;猜的数字小了...&quot;)
    elif guess &gt; number:
        print(&quot;猜的数字大了...&quot;)
</code></pre><p>执行以上脚本，实例输出结果如下：</p>
<pre><code>$ python3 high_low.py
数字猜谜游戏!
请输入你猜的数字：1
猜的数字小了...
请输入你猜的数字：9
猜的数字大了...
请输入你猜的数字：7
恭喜，你猜对了！
</code></pre><hr>
<p>if 嵌套</p>
<p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个<br>if…elif…else 结构中。</p>
<pre><code>if 表达式1:
    语句
    if 表达式2:
        语句
    elif 表达式3:
        语句
    else
        语句
elif 表达式4:
    语句
else:
    语句
</code></pre><hr>
<p>实例</p>
<pre><code># !/usr/bin/python3

num=int(input(&quot;输入一个数字：&quot;))
if num%2==0:
    if num%3==0:
        print (&quot;你输入的数字可以整除 2 和 3&quot;)
    else:
        print (&quot;你输入的数字可以整除 2，但不能整除 3&quot;)
else:
    if num%3==0:
        print (&quot;你输入的数字可以整除 3，但不能整除 2&quot;)
    else:
        print  (&quot;你输入的数字不能整除 2 和 3&quot;)
</code></pre><p>将以上程序保存到 test_if.py 文件中，执行后输出结果为：</p>
<pre><code>$ python3 test.py
输入一个数字：6
你输入的数字可以整除 2 和 3
</code></pre><hr>
<h2 id="Python3-循环语句"><a href="#Python3-循环语句" class="headerlink" title="Python3 循环语句"></a>Python3 循环语句</h2><p>Python3 循环语句</p>
<p>本章节将为大家介绍Python循环语句的使用。</p>
<p>Python中的循环语句有 for 和 while。</p>
<p>Python循环语句的控制结构图如下所示：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/05/while_loop_1.png" alt=""></p>
<hr>
<p>while 循环</p>
<p>Python中while语句的一般形式：</p>
<pre><code>while 判断条件：
    语句
</code></pre><p>同样需要注意冒号和缩进。另外，在Python中没有do..while循环。</p>
<p>以下实例使用了 while 来计算 1 到 100 的总和：</p>
<pre><code>#!/usr/bin/env python3

n = 100

sum = 0
counter = 1
while counter &lt;= n:
    sum = sum + counter
    counter += 1

print(&quot;1 到 %d 之和为: %d&quot; % (n,sum))
</code></pre><p>执行结果如下：</p>
<pre><code>1 到 100 之和为: 5050
</code></pre><hr>
<p>无限循环</p>
<p>我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下：</p>
<pre><code>#!/usr/bin/python3

var = 1
while var == 1 :  # 表达式永远为 true
   num = int(input(&quot;输入一个数字  :&quot;))
   print (&quot;你输入的数字是: &quot;, num)

print (&quot;Good bye!&quot;)
</code></pre><p>执行以上脚本，输出结果如下：</p>
<pre><code>输入一个数字  :5
你输入的数字是:  5
输入一个数字  :
</code></pre><p>你可以使用 <strong>CTRL+C</strong> 来退出当前的无限循环。</p>
<p>无限循环在服务器上客户端的实时请求非常有用。</p>
<hr>
<p>while 循环使用 else 语句</p>
<p>在 while … else 在条件语句为 false 时执行 else 的语句块：</p>
<pre><code>#!/usr/bin/python3

count = 0
while count &lt; 5:
   print (count, &quot; 小于 5&quot;)
   count = count + 1
else:
   print (count, &quot; 大于或等于 5&quot;)
</code></pre><p>执行以上脚本，输出结果如下：</p>
<pre><code>0  小于 5
1  小于 5
2  小于 5
3  小于 5
4  小于 5
5  大于或等于 5
</code></pre><hr>
<p>简单语句组</p>
<p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中，<br>如下所示：</p>
<pre><code>#!/usr/bin/python

flag = 1

while (flag): print (&apos;欢迎访问菜鸟教程!&apos;)

print (&quot;Good bye!&quot;)
</code></pre><p><strong>注意：</strong>以上的无限循环你可以使用 CTRL+C 来中断循环。</p>
<p>执行以上脚本，输出结果如下：</p>
<hr>
<p>for 语句</p>
<p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p>
<p>for循环的一般格式如下：</p>
<pre><code>for &lt;variable&gt; in &lt;sequence&gt;:
    &lt;statements&gt;
else:
    &lt;statements&gt;
</code></pre><p>Python loop循环实例：</p>
<pre><code>&gt;&gt;&gt; languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;]
&gt;&gt;&gt; for x in languages:
...     print (x)
...
C
C++
Perl
Python
&gt;&gt;&gt;
</code></pre><p>以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体：</p>
<pre><code>#!/usr/bin/python3

sites = [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;]
for site in sites:
    if site == &quot;Runoob&quot;:
        print(&quot;菜鸟教程!&quot;)
        break
    print(&quot;循环数据 &quot; + site)
else:
    print(&quot;没有循环数据!&quot;)
print(&quot;完成循环!&quot;)
</code></pre><p>执行脚本后，在循环到 “Runoob”时会跳出循环体：</p>
<pre><code>循环数据 Baidu
循环数据 Google
菜鸟教程!
完成循环!
</code></pre><hr>
<p>range()函数</p>
<p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:</p>
<pre><code>&gt;&gt;&gt; for i in range(5):
...     print(i)
...
0
1
2
3
4
</code></pre><p>你也可以使用range指定区间的值：</p>
<pre><code>&gt;&gt;&gt; for i in range(5,9) :
    print(i)


5
6
7
8
&gt;&gt;&gt;
</code></pre><p>也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’):</p>
<pre><code>&gt;&gt;&gt; for i in range(0, 10, 3) :
    print(i)


0
3
6
9
&gt;&gt;&gt;
</code></pre><p>负数：</p>
<pre><code>&gt;&gt;&gt; for i in range(-10, -100, -30) :
    print(i)


-10
-40
-70
&gt;&gt;&gt;
</code></pre><p>您可以结合range()和len()函数以遍历一个序列的索引,如下所示:</p>
<pre><code>&gt;&gt;&gt; a = [&apos;Google&apos;, &apos;Baidu&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;, &apos;QQ&apos;]
&gt;&gt;&gt; for i in range(len(a)):
...     print(i, a[i])
...
0 Google
1 Baidu
2 Runoob
3 Taobao
4 QQ
&gt;&gt;&gt;
</code></pre><p>还可以使用range()函数来创建一个列表：</p>
<pre><code>&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]
&gt;&gt;&gt;
</code></pre><hr>
<p>break和continue语句及循环中的else子句</p>
<p>break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while<br>循环中终止，任何对应的循环 else 块将不执行。 实例如下：</p>
<pre><code>#!/usr/bin/python3

for letter in &apos;Runoob&apos;:     # 第一个实例
   if letter == &apos;b&apos;:
      break
   print (&apos;当前字母为 :&apos;, letter)

var = 10                    # 第二个实例
while var &gt; 0:              
   print (&apos;当期变量值为 :&apos;, var)
   var = var -1
   if var == 5:
      break

print (&quot;Good bye!&quot;)
</code></pre><p>执行以上脚本输出结果为：</p>
<pre><code>当前字母为 : R
当前字母为 : u
当前字母为 : n
当前字母为 : o
当前字母为 : o
当期变量值为 : 10
当期变量值为 : 9
当期变量值为 : 8
当期变量值为 : 7
当期变量值为 : 6
Good bye!
</code></pre><p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p>
<pre><code>#!/usr/bin/python3

for letter in &apos;Runoob&apos;:     # 第一个实例
   if letter == &apos;o&apos;:        # 字母为 o 时跳过输出
      continue
   print (&apos;当前字母 :&apos;, letter)

var = 10                    # 第二个实例
while var &gt; 0:              
   var = var -1
   if var == 5:             # 变量为 5 时跳过输出
      continue
   print (&apos;当前变量值 :&apos;, var)
print (&quot;Good bye!&quot;)
</code></pre><p>执行以上脚本输出结果为：</p>
<pre><code>当前字母 : R
当前字母 : u
当前字母 : n
当前字母 : b
当前变量值 : 9
当前变量值 : 8
当前变量值 : 7
当前变量值 : 6
当前变量值 : 4
当前变量值 : 3
当前变量值 : 2
当前变量值 : 1
当前变量值 : 0
Good bye!
</code></pre><p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false<br>(以while循环)导致循环终止时被执行,但循环被break终止时不执行。</p>
<p>如下实例用于查询质数的循环例子:</p>
<pre><code>#!/usr/bin/python3

for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, &apos;等于&apos;, x, &apos;*&apos;, n//x)
            break
    else:
        # 循环中没有找到元素
        print(n, &apos; 是质数&apos;)
</code></pre><p>执行以上脚本输出结果为：</p>
<pre><code>2  是质数
3  是质数
4 等于 2 * 2
5  是质数
6 等于 2 * 3
7  是质数
8 等于 2 * 4
9 等于 3 * 3
</code></pre><hr>
<p>pass 语句</p>
<p>Python pass是空语句，是为了保持程序结构的完整性。</p>
<p>pass 不做任何事情，一般用做占位语句，如下实例</p>
<pre><code>&gt;&gt;&gt; while True:
...     pass  # 等待键盘中断 (Ctrl+C)
</code></pre><p>最小的类:</p>
<pre><code>&gt;&gt;&gt; class MyEmptyClass:
...     pass
</code></pre><p>以下实例在字母为 o 时 执行 pass 语句块:</p>
<pre><code>#!/usr/bin/python3

for letter in &apos;Runoob&apos;:
   if letter == &apos;o&apos;:
      pass
      print (&apos;执行 pass 块&apos;)
   print (&apos;当前字母 :&apos;, letter)

print (&quot;Good bye!&quot;)
</code></pre><p>执行以上脚本输出结果为：</p>
<pre><code>当前字母 : R
当前字母 : u
当前字母 : n
执行 pass 块
当前字母 : o
执行 pass 块
当前字母 : o
当前字母 : b
Good bye!
</code></pre><hr>
<h2 id="Python3-迭代器与生成器"><a href="#Python3-迭代器与生成器" class="headerlink" title="Python3 迭代器与生成器"></a>Python3 迭代器与生成器</h2><p>迭代器</p>
<p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<pre><code>&gt;&gt;&gt; list=[1,2,3,4]
&gt;&gt;&gt; it = iter(list)    # 创建迭代器对象
&gt;&gt;&gt; print (next(it))   # 输出迭代器的下一个元素
1
&gt;&gt;&gt; print (next(it))
2
&gt;&gt;&gt;
</code></pre><p>迭代器对象可以使用常规for语句进行遍历：</p>
<pre><code>#!/usr/bin/python3

list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print (x, end=&quot; &quot;)
</code></pre><p>执行以上程序，输出结果如下：</p>
<pre><code>1 2 3 4
</code></pre><p>也可以使用 next() 函数：</p>
<pre><code>#!/usr/bin/python3

import sys         # 引入 sys 模块

list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象

while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
</code></pre><p>执行以上程序，输出结果如下：</p>
<pre><code>1
2
3
4
</code></pre><hr>
<p>生成器</p>
<p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield<br>时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行<br>next()方法时从当前位置继续运行。</p>
<p>以下实例使用 yield 实现斐波那契数列：</p>
<pre><code>#!/usr/bin/python3

import sys

def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter &gt; n):
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成

while True:
    try:
        print (next(f), end=&quot; &quot;)
    except StopIteration:
        sys.exit()
</code></pre><p>执行以上程序，输出结果如下：</p>
<pre><code>0 1 1 2 3 5 8 13 21 34 55
</code></pre><hr>
<h2 id="Python3-函数"><a href="#Python3-函数" class="headerlink" title="Python3 函数"></a>Python3 函数</h2><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p>
<p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<hr>
<p>定义一个函数</p>
<p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 <strong>()</strong>。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li><strong>return [表达式]</strong><br>结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回<br>None。</li>
</ul>
<hr>
<p>语法</p>
<p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<pre><code>def 函数名（参数列表）:
    函数体
</code></pre><p>默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。</p>
<p>实例</p>
<p>让我们使用函数来输出”Hello World！”：</p>
<pre><code>&gt;&gt;&gt; def hello() :
   print(&quot;Hello World!&quot;)


&gt;&gt;&gt; hello()
Hello World!
&gt;&gt;&gt;
</code></pre><p>更复杂点的应用，函数中带上参数变量:</p>
<pre><code>#!/usr/bin/python3

# 计算面积函数
def area(width, height):
    return width * height

def print_welcome(name):
    print(&quot;Welcome&quot;, name)

print_welcome(&quot;Runoob&quot;)
w = 4
h = 5
print(&quot;width =&quot;, w, &quot; height =&quot;, h, &quot; area =&quot;, area(w, h))
</code></pre><p>以上实例输出结果：</p>
<pre><code>Welcome Runoob
width = 4  height = 5  area = 20
</code></pre><hr>
<p>函数调用</p>
<p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p>
<p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python 命令提示符执行。</p>
<p>如下实例调用了 <strong>printme()</strong> 函数：</p>
<pre><code>#!/usr/bin/python3

# 定义函数
def printme( str ):
   &quot;打印任何传入的字符串&quot;
   print (str);
   return;

# 调用函数
printme(&quot;我要调用用户自定义函数!&quot;);
printme(&quot;再次调用同一函数&quot;);
</code></pre><p>以上实例输出结果：</p>
<pre><code>我要调用用户自定义函数!
再次调用同一函数
</code></pre><hr>
<p>按值传递参数和按引用传递参数</p>
<p>在 Python中，所有参数（变量）都是按引用传递。如果你在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p>
<pre><code>#!/usr/bin/python3

# 可写函数说明
def changeme( mylist ):
   &quot;修改传入的列表&quot;
   mylist.append([1,2,3,4]);
   print (&quot;函数内取值: &quot;, mylist)
   return

# 调用changeme函数
mylist = [10,20,30];
changeme( mylist );
print (&quot;函数外取值: &quot;, mylist)
</code></pre><p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p>
<pre><code>函数内取值:  [10, 20, 30, [1, 2, 3, 4]]
函数外取值:  [10, 20, 30, [1, 2, 3, 4]]
</code></pre><hr>
<p>参数</p>
<p>以下是调用函数时可使用的正式参数类型：</p>
<ul>
<li>必需参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<hr>
<p>必需参数</p>
<p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<p>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p>
<pre><code>#!/usr/bin/python3

#可写函数说明
def printme( str ):
   &quot;打印任何传入的字符串&quot;
   print (str);
   return;

#调用printme函数
printme();
</code></pre><p>以上实例输出结果：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 10, in &lt;module&gt;
    printme();
TypeError: printme() missing 1 required positional argument: &apos;str&apos;
</code></pre><hr>
<p>关键字参数</p>
<p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python<br>解释器能够用参数名匹配参数值。</p>
<p>以下实例在函数 printme() 调用时使用参数名：</p>
<pre><code>#!/usr/bin/python3

#可写函数说明
def printme( str ):
   &quot;打印任何传入的字符串&quot;
   print (str);
   return;

#调用printme函数
printme( str = &quot;菜鸟教程&quot;);
</code></pre><p>以上实例输出结果：</p>
<pre><code>菜鸟教程
</code></pre><p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p>
<pre><code>#!/usr/bin/python3

#可写函数说明
def printinfo( name, age ):
   &quot;打印任何传入的字符串&quot;
   print (&quot;名字: &quot;, name);
   print (&quot;年龄: &quot;, age);
   return;

#调用printinfo函数
printinfo( age=50, name=&quot;runoob&quot; );
</code></pre><p>以上实例输出结果：</p>
<pre><code>名字:  runoob
年龄:  50
</code></pre><hr>
<p>默认参数</p>
<p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入<br>age 参数，则使用默认值：</p>
<pre><code>#!/usr/bin/python3

#可写函数说明
def printinfo( name, age = 35 ):
   &quot;打印任何传入的字符串&quot;
   print (&quot;名字: &quot;, name);
   print (&quot;年龄: &quot;, age);
   return;

#调用printinfo函数
printinfo( age=50, name=&quot;runoob&quot; );
print (&quot;------------------------&quot;)
printinfo( name=&quot;runoob&quot; );
</code></pre><p>以上实例输出结果：</p>
<pre><code>名字:  runoob
年龄:  50
------------------------
名字:  runoob
年龄:  35
</code></pre><hr>
<p>不定长参数</p>
<p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p>
<pre><code>def functionname([formal_args,] *var_args_tuple ):
   &quot;函数_文档字符串&quot;
   function_suite
   return [expression]
</code></pre><p>加了星号（*）的变量名会存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p>
<pre><code>#!/usr/bin/python3

# 可写函数说明
def printinfo( arg1, *vartuple ):
   &quot;打印任何传入的参数&quot;
   print (&quot;输出: &quot;)
   print (arg1)
   for var in vartuple:
      print (var)
   return;

# 调用printinfo 函数
printinfo( 10 );
printinfo( 70, 60, 50 );
</code></pre><p>以上实例输出结果：</p>
<pre><code>输出:
10
输出:
70
60
50
</code></pre><hr>
<p>匿名函数</p>
<p>python 使用 lambda 来创建匿名函数。</p>
<p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。</p>
<ul>
<li>lambda 只是一个表达式，函数体比 def 简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda<br>函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li>
<li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<hr>
<p>语法</p>
<p>lambda 函数的语法只包含一个语句，如下：</p>
<pre><code>lambda [arg1 [,arg2,.....argn]]:expression
</code></pre><p>如下实例：</p>
<pre><code>#!/usr/bin/python3

# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2;

# 调用sum函数
print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))
print (&quot;相加后的值为 : &quot;, sum( 20, 20 ))
</code></pre><p>以上实例输出结果：</p>
<pre><code>相加后的值为 :  30
相加后的值为 :  40
</code></pre><hr>
<p>return语句</p>
<p><strong>return [表达式]</strong><br>语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了<br>return 语句的用法：</p>
<pre><code>#!/usr/bin/python3

# 可写函数说明
def sum( arg1, arg2 ):
   # 返回2个参数的和.&quot;
   total = arg1 + arg2
   print (&quot;函数内 : &quot;, total)
   return total;

# 调用sum函数
total = sum( 10, 20 );
print (&quot;函数外 : &quot;, total)
</code></pre><p>以上实例输出结果：</p>
<pre><code>函数内 :  30
函数外 :  30
</code></pre><hr>
<p>变量作用域</p>
<p>Python<br>中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p>
<p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。两种最基本的变量作用域如下：</p>
<ul>
<li>全局变量</li>
<li>局部变量</li>
</ul>
<hr>
<p>全局变量和局部变量</p>
<p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p>
<pre><code>#!/usr/bin/python3

total = 0; # 这是一个全局变量
# 可写函数说明
def sum( arg1, arg2 ):
    #返回2个参数的和.&quot;
    total = arg1 + arg2; # total在这里是局部变量.
    print (&quot;函数内是局部变量 : &quot;, total)
    return total;

#调用sum函数
sum( 10, 20 );
print (&quot;函数外是全局变量 : &quot;, total)
</code></pre><p>以上实例输出结果：</p>
<pre><code>函数内是局部变量 :  30
函数外是全局变量 :  0
</code></pre><hr>
<h2 id="Python3-数据结构"><a href="#Python3-数据结构" class="headerlink" title="Python3 数据结构"></a>Python3 数据结构</h2><p>本章节我们主要结合前面所学的知识点来介绍Python数据结构。</p>
<hr>
<p>列表</p>
<p>Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。</p>
<p>以下是 Python 中列表的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>list.append(x)</td>
<td>把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。</td>
</tr>
<tr>
<td>list.extend(L)</td>
<td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。</td>
</tr>
<tr>
<td>list.insert(i, x)</td>
<td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td>
</tr>
<tr>
<td>list.remove(x)</td>
<td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td>
</tr>
<tr>
<td>list.pop([i])</td>
<td>从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被删除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）</td>
</tr>
<tr>
<td>list.clear()</td>
<td>移除列表中的所有项，等于del a[:]。</td>
</tr>
<tr>
<td>list.index(x)</td>
<td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td>
</tr>
<tr>
<td>list.count(x)</td>
<td>返回 x 在列表中出现的次数。</td>
</tr>
<tr>
<td>list.sort()</td>
<td>对列表中的元素进行排序。</td>
</tr>
<tr>
<td>list.reverse()</td>
<td>倒排列表中的元素。</td>
</tr>
<tr>
<td>list.copy()</td>
<td>返回列表的浅复制，等于a[:]。</td>
</tr>
</tbody>
</table>
<p>下面示例演示了列表的大部分方法：</p>
<pre><code>&gt;&gt;&gt; a = [66.25, 333, 333, 1, 1234.5]
&gt;&gt;&gt; print(a.count(333), a.count(66.25), a.count(&apos;x&apos;))
2 1 0
&gt;&gt;&gt; a.insert(2, -1)
&gt;&gt;&gt; a.append(333)
&gt;&gt;&gt; a
[66.25, 333, -1, 333, 1, 1234.5, 333]
&gt;&gt;&gt; a.index(333)
1
&gt;&gt;&gt; a.remove(333)
&gt;&gt;&gt; a
[66.25, -1, 333, 1, 1234.5, 333]
&gt;&gt;&gt; a.reverse()
&gt;&gt;&gt; a
[333, 1234.5, 1, 333, -1, 66.25]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[-1, 1, 66.25, 333, 333, 1234.5]
</code></pre><p>注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。</p>
<hr>
<p>将列表当做堆栈使用</p>
<p>列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用<br>append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop()<br>方法可以把一个元素从堆栈顶释放出来。例如：</p>
<pre><code>&gt;&gt;&gt; stack = [3, 4, 5]
&gt;&gt;&gt; stack.append(6)
&gt;&gt;&gt; stack.append(7)
&gt;&gt;&gt; stack
[3, 4, 5, 6, 7]
&gt;&gt;&gt; stack.pop()
7
&gt;&gt;&gt; stack
[3, 4, 5, 6]
&gt;&gt;&gt; stack.pop()
6
&gt;&gt;&gt; stack.pop()
5
&gt;&gt;&gt; stack
[3, 4]
</code></pre><hr>
<p>将列表当作队列使用</p>
<p>也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。</p>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; queue = deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])
&gt;&gt;&gt; queue.append(&quot;Terry&quot;)           # Terry arrives
&gt;&gt;&gt; queue.append(&quot;Graham&quot;)          # Graham arrives
&gt;&gt;&gt; queue.popleft()                 # The first to arrive now leaves
&apos;Eric&apos;
&gt;&gt;&gt; queue.popleft()                 # The second to arrive now leaves
&apos;John&apos;
&gt;&gt;&gt; queue                           # Remaining queue in order of arrival
deque([&apos;Michael&apos;, &apos;Terry&apos;, &apos;Graham&apos;])
</code></pre><hr>
<p>列表推导式</p>
<p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p>
<p>每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if<br>子句。返回结果是一个根据表达从其后的 for 和 if<br>上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p>
<p>这里我们将列表中每个数值乘三，获得一个新的列表：</p>
<pre><code>&gt;&gt;&gt; vec = [2, 4, 6]
&gt;&gt;&gt; [3*x for x in vec]
[6, 12, 18]
</code></pre><p>现在我们玩一点小花样：</p>
<pre><code>&gt;&gt;&gt; [[x, x**2] for x in vec]
[[2, 4], [4, 16], [6, 36]]
</code></pre><p>这里我们对序列里每一个元素逐个调用某方法：</p>
<pre><code>&gt;&gt;&gt; freshfruit = [&apos;  banana&apos;, &apos;  loganberry &apos;, &apos;passion fruit  &apos;]
&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]
[&apos;banana&apos;, &apos;loganberry&apos;, &apos;passion fruit&apos;]
</code></pre><p>我们可以用 if 子句作为过滤器：</p>
<pre><code>&gt;&gt;&gt; [3*x for x in vec if x &gt; 3]
[12, 18]
&gt;&gt;&gt; [3*x for x in vec if x &lt; 2]
[]
</code></pre><p>以下是一些关于循环和其它技巧的演示：</p>
<pre><code>&gt;&gt;&gt; vec1 = [2, 4, 6]
&gt;&gt;&gt; vec2 = [4, 3, -9]
&gt;&gt;&gt; [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
&gt;&gt;&gt; [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
&gt;&gt;&gt; [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
</code></pre><p>列表推导式可以使用复杂表达式或嵌套函数：</p>
<pre><code>&gt;&gt;&gt; [str(round(355/113, i)) for i in range(1, 6)]
[&apos;3.1&apos;, &apos;3.14&apos;, &apos;3.142&apos;, &apos;3.1416&apos;, &apos;3.14159&apos;]
</code></pre><hr>
<p>嵌套列表解析</p>
<p>Python的列表还可以嵌套。</p>
<p>以下实例展示了3X4的矩阵列表：</p>
<pre><code>&gt;&gt;&gt; matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
</code></pre><p>以下实例将3X4的矩阵列表转换为4X3列表：</p>
<pre><code>&gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</code></pre><p>以下实例也可以使用以下方法来实现：</p>
<pre><code>&gt;&gt;&gt; transposed = []
&gt;&gt;&gt; for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
&gt;&gt;&gt; transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</code></pre><p>另外一种实现方法：</p>
<pre><code>&gt;&gt;&gt; transposed = []
&gt;&gt;&gt; for i in range(4):
...     # the following 3 lines implement the nested listcomp
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
&gt;&gt;&gt; transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</code></pre><hr>
<p>del 语句</p>
<p>使用 del 语句可以从一个列表中依索引而不是值来删除一个元素。这与使用<br>pop() 返回一个值不同。可以用 del<br>语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：</p>
<pre><code>&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; a
[1, 66.25, 333, 333, 1234.5]
&gt;&gt;&gt; del a[2:4]
&gt;&gt;&gt; a
[1, 66.25, 1234.5]
&gt;&gt;&gt; del a[:]
&gt;&gt;&gt; a
[]
</code></pre><p>也可以用 del 删除实体变量：</p>
<pre><code>&gt;&gt;&gt; del a
</code></pre><hr>
<p>元组和序列</p>
<p>元组由若干逗号分隔的值组成，例如：</p>
<pre><code>&gt;&gt;&gt; t = 12345, 54321, &apos;hello!&apos;
&gt;&gt;&gt; t[0]
12345
&gt;&gt;&gt; t
(12345, 54321, &apos;hello!&apos;)
&gt;&gt;&gt; # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
&gt;&gt;&gt; u
((12345, 54321, &apos;hello!&apos;), (1, 2, 3, 4, 5))
</code></pre><p>如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号，<br>不过括号通常是必须的（如果元组是更大的表达式的一部分）。</p>
<hr>
<p>集合</p>
<p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。</p>
<p>可以用大括号({})创建集合。注意：如果要创建一个空集合，你必须用 set()<br>而不是 {} ；后者创建一个空的字典，下一节我们会介绍这个数据结构。</p>
<p>以下是一个简单的演示：</p>
<pre><code>&gt;&gt;&gt; basket = {&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;}
&gt;&gt;&gt; print(basket)                      # 删除重复的
{&apos;orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;}
&gt;&gt;&gt; &apos;orange&apos; in basket                 # 检测成员
True
&gt;&gt;&gt; &apos;crabgrass&apos; in basket
False

&gt;&gt;&gt; # 以下演示了两个集合的操作
...
&gt;&gt;&gt; a = set(&apos;abracadabra&apos;)
&gt;&gt;&gt; b = set(&apos;alacazam&apos;)
&gt;&gt;&gt; a                                  # a 中唯一的字母
{&apos;a&apos;, &apos;r&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;}
&gt;&gt;&gt; a - b                              # 在 a 中的字母，但不在 b 中
{&apos;r&apos;, &apos;d&apos;, &apos;b&apos;}
&gt;&gt;&gt; a | b                              # 在 a 或 b 中的字母
{&apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;}
&gt;&gt;&gt; a &amp; b                              # 在 a 和 b 中都有的字母
{&apos;a&apos;, &apos;c&apos;}
&gt;&gt;&gt; a ^ b                              # 在 a 或 b 中的字母，但不同时在 a 和 b 中
{&apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;}
</code></pre><p>集合也支持推导式：</p>
<pre><code>&gt;&gt;&gt; a = {x for x in &apos;abracadabra&apos; if x not in &apos;abc&apos;}
&gt;&gt;&gt; a
{&apos;r&apos;, &apos;d&apos;}
</code></pre><hr>
<p>字典</p>
<p>另一个非常有用的 Python 内建数据类型是字典。</p>
<p>序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。</p>
<p>理解字典的最佳方式是把它看做无序的键=&gt;值对集合。在同一个字典之内，关键字必须是互不相同。</p>
<p>一对大括号创建一个空的字典：{}。</p>
<p>这是一个字典运用的简单例子：</p>
<pre><code>&gt;&gt;&gt; tel = {&apos;jack&apos;: 4098, &apos;sape&apos;: 4139}
&gt;&gt;&gt; tel[&apos;guido&apos;] = 4127
&gt;&gt;&gt; tel
{&apos;sape&apos;: 4139, &apos;guido&apos;: 4127, &apos;jack&apos;: 4098}
&gt;&gt;&gt; tel[&apos;jack&apos;]
4098
&gt;&gt;&gt; del tel[&apos;sape&apos;]
&gt;&gt;&gt; tel[&apos;irv&apos;] = 4127
&gt;&gt;&gt; tel
{&apos;guido&apos;: 4127, &apos;irv&apos;: 4127, &apos;jack&apos;: 4098}
&gt;&gt;&gt; list(tel.keys())
[&apos;irv&apos;, &apos;guido&apos;, &apos;jack&apos;]
&gt;&gt;&gt; sorted(tel.keys())
[&apos;guido&apos;, &apos;irv&apos;, &apos;jack&apos;]
&gt;&gt;&gt; &apos;guido&apos; in tel
True
&gt;&gt;&gt; &apos;jack&apos; not in tel
False
</code></pre><p>构造函数 dict()<br>直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：</p>
<pre><code>&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)])
{&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}
</code></pre><p>此外，字典推导可以用来创建任意键和值的表达式词典：</p>
<pre><code>&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
</code></pre><p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：</p>
<pre><code>&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)
{&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}
</code></pre><hr>
<p>遍历技巧</p>
<p>在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：</p>
<pre><code>&gt;&gt;&gt; knights = {&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;}
&gt;&gt;&gt; for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
</code></pre><p>在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：</p>
<pre><code>&gt;&gt;&gt; for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):
...     print(i, v)
...
0 tic
1 tac
2 toe
</code></pre><p>同时遍历两个或更多的序列，可以使用 zip() 组合：</p>
<pre><code>&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]
&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]
&gt;&gt;&gt; for q, a in zip(questions, answers):
...     print(&apos;What is your {0}?  It is {1}.&apos;.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
</code></pre><p>要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：</p>
<pre><code>&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
</code></pre><p>要按顺序遍历一个序列，使用 sorted()<br>函数返回一个已排序的序列，并不修改原值：</p>
<pre><code>&gt;&gt;&gt; basket = [&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;]
&gt;&gt;&gt; for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
</code></pre><hr>
<p>参阅文档</p>
<ul>
<li><a href="/python3/python3-list.html">Python3 列表</a></li>
<li><a href="/python3/python3-tuple.html">Python3 元组</a></li>
<li><a href="/python3/python3-dictionary.html">Python3 字典</a></li>
</ul>
<hr>
<h2 id="Python3-模块"><a href="#Python3-模块" class="headerlink" title="Python3 模块"></a>Python3 模块</h2><p>在前面的几个章节中我们脚本上是用 python 解释器来编程，如果你从 Python解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p>
<p>为此 Python提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p>
<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用<br>python 标准库的方法。</p>
<p>下面是一个使用 python 标准库中模块的例子。</p>
<pre><code>#!/usr/bin/python3
# 文件名: using_sys.py

import sys

print(&apos;命令行参数如下:&apos;)
for i in sys.argv:
   print(i)

print(&apos;\n\nPython 路径为：&apos;, sys.path, &apos;\n&apos;)
</code></pre><p>执行结果如下所示：</p>
<pre><code>$ python using_sys.py 参数1 参数2
命令行参数如下:
using_sys.py
参数1
参数2


Python 路径为： [&apos;/root&apos;, &apos;/usr/lib/python3.4&apos;, &apos;/usr/lib/python3.4/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python3.4/lib-dynload&apos;, &apos;/usr/local/lib/python3.4/dist-packages&apos;, &apos;/usr/lib/python3/dist-packages&apos;]
</code></pre><ul>
<li>1、import sys 引入 python 标准库中的 sys.py<br>模块；这是引入某一模块的方法。</li>
<li>2、sys.argv 是一个包含命令行参数的列表。</li>
<li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li>
</ul>
<hr>
<p>import 语句</p>
<p>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：</p>
<pre><code>import module1[, module2[,... moduleN]
</code></pre><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块<br>support，需要把命令放在脚本的顶端：</p>
<p>support.py 文件代码为：</p>
<pre><code>#!/usr/bin/python3
# Filename: support.py

def print_func( par ):
    print (&quot;Hello : &quot;, par)
    return
</code></pre><p>test.py 引入 support 模块：</p>
<pre><code>#!/usr/bin/python3
# Filename: test.py

# 导入模块
import support

# 现在可以调用模块里包含的函数了
support.print_func(&quot;Runoob&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>$ python3 test.py
Hello :  Runoob
</code></pre><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p>
<p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p>
<p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。</p>
<p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p>
<p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&apos;&apos;, &apos;/usr/lib/python3.4&apos;, &apos;/usr/lib/python3.4/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python3.4/lib-dynload&apos;, &apos;/usr/local/lib/python3.4/dist-packages&apos;, &apos;/usr/lib/python3/dist-packages&apos;]
&gt;&gt;&gt;
</code></pre><p>sys.path<br>输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p>
<p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p>
<p>现在，在解释器的当前目录或者 sys.path<br>中的一个目录里面来创建一个fibo.py的文件，代码如下：</p>
<pre><code># 斐波那契(fibonacci)数列模块

def fib(n):    # 定义到 n 的斐波那契数列
    a, b = 0, 1
    while b &lt; n:
        print(b, end=&apos; &apos;)
        a, b = b, a+b
    print()

def fib2(n): # 返回到 n 的斐波那契数列
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
</code></pre><p>然后进入Python解释器，使用下面的命令导入这个模块：</p>
<pre><code>&gt;&gt;&gt; import fibo
</code></pre><p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p>
<p>可以使用模块名称来访问函数：</p>
<pre><code>&gt;&gt;&gt; fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
&gt;&gt;&gt; fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
&gt;&gt;&gt; fibo.__name__
&apos;fibo&apos;
</code></pre><p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p>
<pre><code>&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><hr>
<p>from…import 语句</p>
<p>Python的from语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<pre><code>from modname import name1[, name2[, ... nameN]]
</code></pre><p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p>
<pre><code>&gt;&gt;&gt; from fibo import fib, fib2
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p>
<p>\</p>
<hr>
<p>From…import* 语句</p>
<p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<pre><code>from modname import *
</code></pre><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<hr>
<p>深入模块</p>
<p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</p>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。</p>
<p>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。</p>
<p>从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname<br>这样的表示法来访问模块内的函数。</p>
<p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用<br>import<br>来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
<p>还有一种导入的方法，可以使用 import<br>直接把模块内（函数，变量的）名称导入到当前操作模块。比如:</p>
<pre><code>&gt;&gt;&gt; from fibo import fib, fib2
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo<br>这个名称是没有定义的）。</p>
<p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p>
<pre><code>&gt;&gt;&gt; from fibo import *
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况，<br>Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p>
<hr>
<p>__name__属性</p>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code>#!/usr/bin/python3
# Filename: using_name.py

if __name__ == &apos;__main__&apos;:
   print(&apos;程序自身在运行&apos;)
else:
   print(&apos;我来自另一模块&apos;)
</code></pre><p>运行输出如下：</p>
<pre><code>$ python using_name.py
</code></pre><p>程序自身在运行</p>
<pre><code>$ python
&gt;&gt;&gt; import using_name
我来自另一模块
&gt;&gt;&gt;
</code></pre><p><strong>说明：</strong><br>每个模块都有一个__name__属性，当其值是’__main__‘时，表明该模块自身在运行，否则是被引入。</p>
<hr>
<p>dir() 函数</p>
<p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fibo)</div><div class="line">[<span class="string">'__name__'</span>, <span class="string">'fib'</span>, <span class="string">'fib2'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sys)  </div><div class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>,</div><div class="line"> <span class="string">'__package__'</span>, <span class="string">'__stderr__'</span>, <span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>,</div><div class="line"> <span class="string">'_clear_type_cache'</span>, <span class="string">'_current_frames'</span>, <span class="string">'_debugmallocstats'</span>, <span class="string">'_getframe'</span>,</div><div class="line"> <span class="string">'_home'</span>, <span class="string">'_mercurial'</span>, <span class="string">'_xoptions'</span>, <span class="string">'abiflags'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>,</div><div class="line"> <span class="string">'base_exec_prefix'</span>, <span class="string">'base_prefix'</span>, <span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>,</div><div class="line"> <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>, <span class="string">'copyright'</span>, <span class="string">'displayhook'</span>,</div><div class="line"> <span class="string">'dont_write_bytecode'</span>, <span class="string">'exc_info'</span>, <span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>,</div><div class="line"> <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'flags'</span>, <span class="string">'float_info'</span>, <span class="string">'float_repr_style'</span>,</div><div class="line"> <span class="string">'getcheckinterval'</span>, <span class="string">'getdefaultencoding'</span>, <span class="string">'getdlopenflags'</span>,</div><div class="line"> <span class="string">'getfilesystemencoding'</span>, <span class="string">'getobjects'</span>, <span class="string">'getprofile'</span>, <span class="string">'getrecursionlimit'</span>,</div><div class="line"> <span class="string">'getrefcount'</span>, <span class="string">'getsizeof'</span>, <span class="string">'getswitchinterval'</span>, <span class="string">'gettotalrefcount'</span>,</div><div class="line"> <span class="string">'gettrace'</span>, <span class="string">'hash_info'</span>, <span class="string">'hexversion'</span>, <span class="string">'implementation'</span>, <span class="string">'int_info'</span>,</div><div class="line"> <span class="string">'intern'</span>, <span class="string">'maxsize'</span>, <span class="string">'maxunicode'</span>, <span class="string">'meta_path'</span>, <span class="string">'modules'</span>, <span class="string">'path'</span>,</div><div class="line"> <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>, <span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>,</div><div class="line"> <span class="string">'setcheckinterval'</span>, <span class="string">'setdlopenflags'</span>, <span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>,</div><div class="line"> <span class="string">'setswitchinterval'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>,</div><div class="line"> <span class="string">'thread_info'</span>, <span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>]</div></pre></td></tr></table></figure>
<p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; import fibo
&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; dir() # 得到一个当前模块中定义的属性列表
[&apos;__builtins__&apos;, &apos;__name__&apos;, &apos;a&apos;, &apos;fib&apos;, &apos;fibo&apos;, &apos;sys&apos;]
&gt;&gt;&gt; a = 5 # 建立一个新的变量 &apos;a&apos;
&gt;&gt;&gt; dir()
[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;a&apos;, &apos;sys&apos;]
&gt;&gt;&gt;
&gt;&gt;&gt; del a # 删除变量名a
&gt;&gt;&gt;
&gt;&gt;&gt; dir()
[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;sys&apos;]
&gt;&gt;&gt;
</code></pre><hr>
<p>标准模块</p>
<p>Python 本身带着一些标准的模块库，在 Python<br>库参考文档中将会介绍到（就是后面的”库参考文档”）。</p>
<p>有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。</p>
<p>这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg<br>这个模块就只会提供给 Windows 系统。</p>
<p>应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量<br>sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
&apos;&gt;&gt;&gt; &apos;
&gt;&gt;&gt; sys.ps2
&apos;... &apos;
&gt;&gt;&gt; sys.ps1 = &apos;C&gt; &apos;
C&gt; print(&apos;Yuck!&apos;)
Yuck!
C&gt;
</code></pre><hr>
<p>包</p>
<p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>
<p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p>
<p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p>
<p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p>
<p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如：<br>.wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p>
<p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所你还需要一组怎么也写不完的模块来处理这些操作。</p>
<p>这里给出了一种可能的包结构（在分层的文件系统中）:</p>
<pre><code>sound/                          顶层包
      __init__.py               初始化 sound 包
      formats/                  文件格式转换子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  声音效果子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  filters 子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</code></pre><p>在导入一个包的时候，Python 会根据 sys.path<br>中的目录来寻找这个包中包含的子目录。</p>
<p>目录只有包含一个叫做 __init__.py的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做string）不小心的影响搜索路径中的有效模块。</p>
<p>最简单的情况，放一个空的:file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的）__all__变量赋值。</p>
<p>用户可以每次只导入一个包里面的特定模块，比如:</p>
<pre><code>import sound.effects.echo
</code></pre><p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p>
<pre><code>sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre><p>还有一种导入子模块的方法是:</p>
<pre><code>from sound.effects import echo
</code></pre><p>这同样会导入子模块:<br>echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p>
<pre><code>echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre><p>还有一种变化就是直接导入一个函数或者变量:</p>
<pre><code>from sound.effects.echo import echofilter
</code></pre><p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter()<br>函数:</p>
<pre><code>echofilter(input, output, delay=0.7, atten=4)
</code></pre><p>注意当使用from package import<br>item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p>
<p>import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError<br>异常被抛出了。</p>
<p>反之，如果使用形如import<br>item.subitem.subsubitem这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p>
<hr>
<p>从一个包中导入*</p>
<p>设想一下，如果我们使用 from sound.effects import *会发生什么？</p>
<p>Python会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。</p>
<p>但是很不幸，这个方法在Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。</p>
<p>在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是Echo 甚至 ECHO。</p>
<p>（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的8+3 命名规则对长模块名称的处理会把问题搞得更纠结。</p>
<p>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。</p>
<p>导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做<br>__all__ 的列表变量，那么在使用 from package import *<br>的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>作为包的作者，可别忘了在更新包之后保证 __all__<br>也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/__init__.py中包含如下代码:</p>
<pre><code>__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre><p>这表示当你使用<code>from sound.effects import *</code>这种用法时，你只会导入包里面这三个子模块。</p>
<p>如果 <strong>__all__</strong> 真的没有定义，那么使用<strong>from sound.effects import<br>*</strong>这种语法的时候，就不会导入包 sound.effects<br>里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。</p>
<p>这会把 __init__.py<br>里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<pre><code>import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code></pre><p>这个例子中，在执行from…import前，包sound.effects中的echo和surround模块都被导入到当前的命名空间中了。（当然如果定义了__all__就更没问题了）</p>
<p>通常我们并不主张使用*这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>记住，使用from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder<br>要使用包sound.effects中的模块echo，你就要写成 from sound.effects import<br>echo。</p>
<pre><code>from . import echo
from .. import formats
from ..filters import equalizer
</code></pre><p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”__main__“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p>
<p>包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>
<p>这个功能并不常用，一般用来扩展包里面的模块。</p>
<hr>
<h2 id="Python3-输入和输出"><a href="#Python3-输入和输出" class="headerlink" title="Python3 输入和输出"></a>Python3 输入和输出</h2><p>在前面几个章节中，我们其实已经接触了 Python<br>的输入输出的功能。本章节我们将具体介绍 Python 的输入输出。</p>
<hr>
<p>输出格式美化</p>
<p>Python两种输出值的方式: 表达式语句和 print() 函数。</p>
<p>第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout引用。</p>
<p>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</p>
<p>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。</p>
<ul>
<li><strong>str()：</strong> 函数返回一个用户易读的表达形式。</li>
<li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li>
</ul>
<p>— 例如</p>
<pre><code>&gt;&gt;&gt; s = &apos;Hello, Runoob&apos;
&gt;&gt;&gt; str(s)
&apos;Hello, Runoob&apos;
&gt;&gt;&gt; repr(s)
&quot;&apos;Hello, Runoob&apos;&quot;
&gt;&gt;&gt; str(1/7)
&apos;0.14285714285714285&apos;
&gt;&gt;&gt; x = 10 * 3.25
&gt;&gt;&gt; y = 200 * 200
&gt;&gt;&gt; s = &apos;x 的值为： &apos; + repr(x) + &apos;,  y 的值为：&apos; + repr(y) + &apos;...&apos;
&gt;&gt;&gt; print(s)
x 的值为： 32.5,  y 的值为：40000...
&gt;&gt;&gt; #  repr() 函数可以转义字符串中的特殊字符
... hello = &apos;hello, runoob\n&apos;
&gt;&gt;&gt; hellos = repr(hello)
&gt;&gt;&gt; print(hellos)
&apos;hello, runoob\n&apos;
&gt;&gt;&gt; # repr() 的参数可以是 Python 的任何对象
... repr((x, y, (&apos;Google&apos;, &apos;Runoob&apos;)))
&quot;(32.5, 40000, (&apos;Google&apos;, &apos;Runoob&apos;))&quot;
</code></pre><p>这里有两种方式输出一个平方与立方的表:</p>
<pre><code>&gt;&gt;&gt; for x in range(1, 11):
...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=&apos; &apos;)
...     # 注意前一行 &apos;end&apos; 的使用
...     print(repr(x*x*x).rjust(4))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000

&gt;&gt;&gt; for x in range(1, 11):
...     print(&apos;{0:2d} {1:3d} {2:4d}&apos;.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
</code></pre><p><strong>注意：</strong>在第一个例子中, 每列间的空格由 print() 添加。</p>
<p>这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右,<br>并在左边填充空格。</p>
<p>还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西,<br>它们仅仅返回新的字符串。</p>
<p>另一个方法 zfill(), 它会在数字的左边填充 0，如下所示：</p>
<pre><code>&gt;&gt;&gt; &apos;12&apos;.zfill(5)
&apos;00012&apos;
&gt;&gt;&gt; &apos;-3.14&apos;.zfill(7)
&apos;-003.14&apos;
&gt;&gt;&gt; &apos;3.14159265359&apos;.zfill(5)
&apos;3.14159265359&apos;
</code></pre><p>str.format() 的基本使用如下:</p>
<pre><code>&gt;&gt;&gt; print(&apos;{}网址： &quot;{}!&quot;&apos;.format(&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;))
菜鸟教程网址： &quot;www.runoob.com!&quot;
</code></pre><p>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。</p>
<p>在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：</p>
<pre><code>&gt;&gt;&gt; print(&apos;{0} 和 {1}&apos;.format(&apos;Google&apos;, &apos;Runoob&apos;))
Google 和 Runoob
&gt;&gt;&gt; print(&apos;{1} 和 {0}&apos;.format(&apos;Google&apos;, &apos;Runoob&apos;))
Runoob 和 Google
</code></pre><p>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p>
<pre><code>&gt;&gt;&gt; print(&apos;{name}网址： {site}&apos;.format(name=&apos;菜鸟教程&apos;, site=&apos;www.runoob.com&apos;))
菜鸟教程网址： www.runoob.com
</code></pre><p>位置及关键字参数可以任意的结合:</p>
<pre><code>&gt;&gt;&gt; print(&apos;站点列表 {0}, {1}, 和 {other}。&apos;.format(&apos;Google&apos;, &apos;Runoob&apos;,
                                                       other=&apos;Taobao&apos;))
站点列表 Google, Runoob, 和 Taobao。
</code></pre><p>‘!a’ (使用 ascii()), ‘!s’ (使用 str()) 和 ‘!r’ (使用 repr())<br>可以用于在格式化某个值之前对其进行转化:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; print(&apos;常量 PI 的值近似为： {}。&apos;.format(math.pi))
常量 PI 的值近似为： 3.141592653589793。
&gt;&gt;&gt; print(&apos;常量 PI 的值近似为： {!r}。&apos;.format(math.pi))
常量 PI 的值近似为： 3.141592653589793。
</code></pre><p>可选项 ‘:’ 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。<br>下面的例子将 Pi 保留到小数点后三位：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; print(&apos;常量 PI 的值近似为 {0:.3f}。&apos;.format(math.pi))
常量 PI 的值近似为 3.142。
</code></pre><p>在 ‘:’ 后传入一个整数, 可以保证该域至少有这么多的宽度。<br>用于美化表格时很有用。</p>
<pre><code>&gt;&gt;&gt; table = {&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3}
&gt;&gt;&gt; for name, number in table.items():
...     print(&apos;{0:10} ==&gt; {1:10d}&apos;.format(name, number))
...
Runoob     ==&gt;          2
Taobao     ==&gt;          3
Google     ==&gt;          1
</code></pre><p>如果你有一个很长的格式化字符串, 而你不想将它们分开,<br>那么在格式化时通过变量名而非位置会是很好的事情。</p>
<p>最简单的就是传入一个字典, 然后使用方括号 ‘[]‘ 来访问键值 :</p>
<pre><code>&gt;&gt;&gt; table = {&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3}
&gt;&gt;&gt; print(&apos;Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; &apos;
          &apos;Taobao: {0[Taobao]:d}&apos;.format(table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre><p>也可以通过在 table 变量前使用 ‘**‘ 来实现相同的功能：</p>
<pre><code>&gt;&gt;&gt; table = {&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3}
&gt;&gt;&gt; print(&apos;Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}&apos;.format(**table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre><hr>
<p>旧式字符串格式化</p>
<p>% 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf()<br>式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; print(&apos;常量 PI 的值近似为：%5.3f。&apos; % math.pi)
常量 PI 的值近似为：3.142。
</code></pre><p>因为 str.format() 比较新的函数， 大多数的 Python 代码仍然使用 %<br>操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().</p>
<hr>
<p>读取键盘输入</p>
<p>Python提供了 input()<br>置函数从标准输入读入一行文本，默认的标准输入是键盘。</p>
<p>input 可以接收一个Python表达式作为输入，并将运算结果返回。</p>
<pre><code>#!/usr/bin/python3

str = input(&quot;请输入：&quot;);
print (&quot;你输入的内容是: &quot;, str)
</code></pre><p>这会产生如下的对应着输入的结果：</p>
<pre><code>请输入：菜鸟教程
你输入的内容是:  菜鸟教程
</code></pre><hr>
<p>读和写文件</p>
<p>open() 将会返回一个 file 对象，基本语法格式如下:</p>
<pre><code>open(filename, mode)
</code></pre><ul>
<li>filename：filename 变量是一个包含了你要访问的文件名称的字符串值。</li>
<li>mode：mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li>
</ul>
<p>不同模式打开文件的完全列表：</p>
<p>  模式   描述</p>
<hr>
<p>  r      以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<br>  rb     以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。<br>  r+     打开一个文件用于读写。文件指针将会放在文件的开头。<br>  rb+    以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。<br>  w      打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>  wb     以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>  w+     打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>  wb+    以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>  a      打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>  ab     以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>  a+     打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br>  ab+    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</p>
<p>以下实例将字符串写入到文件 foo.txt 中：</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)

f.write( &quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot; )

# 关闭打开的文件
f.close()
</code></pre><ul>
<li>第一个参数为要打开的文件名。</li>
<li>第二个参数描述文件如何使用的字符。 mode 可以是 ‘r’ 如果文件只读, ‘w’<br>只用于写 (如果存在同名文件则将被删除), 和 ‘a’ 用于追加文件内容;<br>所写的任何数据都会被自动增加到末尾. ‘r+’ 同时用于读写。 mode<br>参数是可选的; ‘r’ 将是默认值。</li>
</ul>
<p>此时打开文件 foo.txt,显示如下：</p>
<pre><code>$ cat /tmp/foo.txt
Python 是一个非常好的语言。
是的，的确非常好!!
</code></pre><hr>
<p>文件对象的方法</p>
<p>本节中剩下的例子假设已经创建了一个称为 f 的文件对象。</p>
<hr>
<p>f.read()</p>
<p>为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据,<br>然后作为字符串或字节对象返回。</p>
<p>size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负,<br>那么该文件的所有内容都将被读取并且返回。</p>
<p>以下实例假定文件 foo.txt 已存在（上面实例中已创建）：</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)

str = f.read()
print(str)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>Python 是一个非常好的语言。
是的，的确非常好!!
</code></pre><hr>
<p>f.readline()</p>
<p>f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline()<br>如果返回一个空字符串, 说明已经已经读取到最后一行。</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)

str = f.readline()
print(str)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>Python 是一个非常好的语言。
</code></pre><hr>
<p>f.readlines()</p>
<p>f.readlines() 将返回该文件中包含的所有行。</p>
<p>如果设置可选参数 sizehint, 则读取指定长度的字节,<br>并且将这些字节按行分割。</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)

str = f.readlines()
print(str)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>[&apos;Python 是一个非常好的语言。\n&apos;, &apos;是的，的确非常好!!\n&apos;]
</code></pre><p>另一种方式是迭代一个文件对象然后读取每行:</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)

for line in f:
    print(line, end=&apos;&apos;)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>Python 是一个非常好的语言。
是的，的确非常好!!
</code></pre><p>这个方法很简单, 但是并没有提供一个很好的控制。 因为两者的处理机制不同,<br>最好不要混用。</p>
<hr>
<p>f.write()</p>
<p>f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)

num = f.write( &quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot; )
print(num)
# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>29
</code></pre><p>如果要写入一些不是字符串的东西, 那么将需要先进行转换:</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo1.txt&quot;, &quot;w&quot;)

value = (&apos;www.runoob.com&apos;, 14)
s = str(value)
f.write(s)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，打开 foo1.txt 文件：</p>
<pre><code>$ cat /tmp/foo1.txt
(&apos;www.runoob.com&apos;, 14)
</code></pre><hr>
<p>f.tell()</p>
<p>f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。</p>
<hr>
<p>f.seek()</p>
<p>如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。</p>
<p>from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2<br>表示文件的结尾，例如：</p>
<ul>
<li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符</li>
<li>seek(x,1) ： 表示从当前位置往后移动x个字符</li>
<li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li>
</ul>
<p>from_what 值为默认为0，即文件开头。下面给出一个完整的例子：</p>
<pre><code>&gt;&gt;&gt; f = open(&apos;/tmp/foo.txt&apos;, &apos;rb+&apos;)
&gt;&gt;&gt; f.write(b&apos;0123456789abcdef&apos;)
16
&gt;&gt;&gt; f.seek(5)     # 移动到文件的第六个字节
5
&gt;&gt;&gt; f.read(1)
b&apos;5&apos;
&gt;&gt;&gt; f.seek(-3, 2) # 移动到文件的倒数第三字节
13
&gt;&gt;&gt; f.read(1)
b&apos;d&apos;
</code></pre><hr>
<p>f.close()</p>
<p>在文本文件中 (那些打开文件的模式下没有 b 的),<br>只会相对于文件起始位置进行定位。<br>当你处理完一个文件后, 调用 f.close()<br>来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。</p>
<pre><code>&gt;&gt;&gt; f.close()
&gt;&gt;&gt; f.read()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
ValueError: I/O operation on closed file
&lt;pre&gt;
&lt;p&gt;
当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:&lt;/p&gt;
&lt;pre&gt;
&gt;&gt;&gt; with open(&apos;/tmp/foo.txt&apos;, &apos;r&apos;) as f:
...     read_data = f.read()
&gt;&gt;&gt; f.closed
True
</code></pre><p>文件对象还有其他方法, 如 isatty() 和 trucate(), 但这些通常比较少用。</p>
<hr>
<p>pickle 模块</p>
<p>python的pickle模块实现了基本的数据序列和反序列化。</p>
<p>通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</p>
<p>通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p>
<p>基本接口：</p>
<pre><code>pickle.dump(obj, file, [,protocol])
</code></pre><p>有了 pickle 这个对象, 就能对 file 以读取的形式打开:</p>
<pre><code>x = pickle.load(file)
</code></pre><p><strong>注解：</strong>从 file 中读取一个字符串，并将它重构为原来的python对象。</p>
<p><strong>file:</strong> 类文件对象，有read()和readline()接口。</p>
<p>实例1：</p>
<pre><code>#!/usr/bin/python3
import pickle

# 使用pickle模块将数据对象保存到文件
data1 = {&apos;a&apos;: [1, 2.0, 3, 4+6j],
         &apos;b&apos;: (&apos;string&apos;, u&apos;Unicode string&apos;),
         &apos;c&apos;: None}

selfref_list = [1, 2, 3]
selfref_list.append(selfref_list)

output = open(&apos;data.pkl&apos;, &apos;wb&apos;)

# Pickle dictionary using protocol 0.
pickle.dump(data1, output)

# Pickle the list using the highest protocol available.
pickle.dump(selfref_list, output, -1)

output.close()
</code></pre><p>实例2：</p>
<pre><code>#!/usr/bin/python3
import pprint, pickle

#使用pickle模块从文件中重构python对象
pkl_file = open(&apos;data.pkl&apos;, &apos;rb&apos;)

data1 = pickle.load(pkl_file)
pprint.pprint(data1)

data2 = pickle.load(pkl_file)
pprint.pprint(data2)

pkl_file.close()
</code></pre><hr>
<h2 id="Python3-File"><a href="#Python3-File" class="headerlink" title="Python3 File"></a>Python3 File</h2><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p>
<p>+———————————–+———————————–+<br>| 序号                              | 方法及描述                        |<br>+===================================+===================================+<br>| 1                                 | <a href="/python3/python3-f |
|                                   | ile-close.html">file.close()</a>                   |<br>|                                   |                                   |<br>|                                   | 关闭文件。关闭后文件不能再进行读写操作。 |<br>+———————————–+———————————–+<br>| 2                                 | <a href="/python3/python3-f |
|                                   | ile-flush.html">file.flush()</a>                   |<br>|                                   |                                   |<br>|                                   | 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, |<br>|                                   |                                   |<br>|                                   | 而不是被动的等待输出缓冲区写入。  |<br>+———————————–+———————————–+<br>| 3                                 | <a href="/python3/python3- |
|                                   | file-fileno.html">file.fileno()</a>                 |<br>|                                   |                                   |<br>|                                   | 返回一个整型的文件描述符(file     |<br>|                                   | descriptor FD 整型),              |<br>|                                   | 可以用在如os模块的read方法等一些底层操作上。 |<br>+———————————–+———————————–+<br>| 4                                 | <a href="/python3/python3- |
|                                   | file-isatty.html">file.isatty()</a>                 |<br>|                                   |                                   |<br>|                                   | 如果文件连接到一个终端设备返回    |<br>|                                   | True，否则返回 False。            |<br>+———————————–+———————————–+<br>| 5                                 | <a href="/python3/python3-fi |
|                                   | le-next.html">file.next()</a>                     |<br>|                                   |                                   |<br>|                                   | 返回文件下一行。                  |<br>+———————————–+———————————–+<br>| 6                                 | <a href="/python3/py |
|                                   | thon3-file-read.html">file.read([size])</a>             |<br>|                                   |                                   |<br>|                                   | 从文件读取指定的字节数，如果未给定或为负则读取所有。 |<br>+———————————–+———————————–+<br>| 7                                 | <a href="/python |
|                                   | 3/python3-file-readline.html">file.readline([size])</a>     |<br>|                                   |                                   |<br>|                                   | 读取整行，包括 “\n” 字符。       |<br>+———————————–+———————————–+<br>| 8                                 | <a href="/p |
|                                   | ython3/python3-file-readlines.htm |
|                                   | l">file.readlines([sizehint])</a>                                |<br>|                                   |                                   |<br>|                                   | 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约 |<br>|                                   | 为sizeint字节的行,                |<br>|                                   | 实际读取值可能比sizhint较大,      |<br>|                                   | 因为需要填充缓冲区。              |<br>+———————————–+———————————–+<br>| 9                                 | <a href="/python3/python3-file- |
|                                   | seek.html">file.seek(offset[,              |<br>|                                   | whence])</a>                        |<br>|                                   |                                   |<br>|                                   | 设置文件当前位置                  |<br>+———————————–+———————————–+<br>| 10                                | <a href="/python3/python3-fi |
|                                   | le-tell.html">file.tell()</a>                     |<br>|                                   |                                   |<br>|                                   | 返回文件当前位置。                |<br>+———————————–+———————————–+<br>| 11                                | <a href="/python |
|                                   | 3/python3-file-truncate.html">file.truncate([size])</a>     |<br>|                                   |                                   |<br>|                                   | 截取文件，截取的字节通过size指定，默认为当前文件位置。 |<br>+———————————–+———————————–+<br>| 12                                | <a href="/python3/python |
|                                   | 3-file-write.html">file.write(str)</a>                |<br>|                                   |                                   |<br>|                                   | 将字符串写入文件，没有返回值。    |<br>+———————————–+———————————–+<br>| 13                                | <a href="/pyth |
|                                   | on3/python3-file-writelines.html">file.writelines(sequence)</a> |<br>|                                   |                                   |<br>|                                   | 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符 |<br>|                                   | 。                                |<br>+———————————–+———————————–+</p>
<hr>
<h2 id="Python3-OS"><a href="#Python3-OS" class="headerlink" title="Python3 OS"></a>Python3 OS</h2><p>os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>os.access(path, mode)</td>
<td>检验权限模式</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>os.chdir(path)</td>
<td>改变当前工作目录</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>os.chflags(path, flags)</td>
<td>设置路径的标记为数字标记。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>os.chmod(path, mode)</td>
<td>更改权限</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>os.chown(path, uid, gid)</td>
<td>更改文件所有者</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td>os.chroot(path)</td>
<td>改变当前进程的根目录</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td>os.close(fd)</td>
<td>关闭文件描述符 fd</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td>os.closerange(fd_low, fd_high)</td>
<td>关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td>os.dup(fd)</td>
<td>复制文件描述符 fd</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td>os.dup2(fd, fd2)</td>
<td>将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td>os.fchdir(fd)</td>
<td>通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td>os.fchmod(fd, mode)</td>
<td>改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td>os.fchown(fd, uid, gid)</td>
<td>修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td>os.fdatasync(fd)</td>
<td>强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td>os.fdopen(fd[, mode[, bufsize]])</td>
<td>通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td>os.fpathconf(fd, name)</td>
<td>返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td>os.fstat(fd)</td>
<td>返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td>os.fstatvfs(fd)</td>
<td>返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td>os.fsync(fd)</td>
<td>强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td>os.ftruncate(fd, length)</td>
<td>裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td>os.getcwd()</td>
<td>返回当前工作目录</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td>os.getcwdu()</td>
<td>返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td>os.isatty(fd)</td>
<td>如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td>os.lchflags(path, flags)</td>
<td>设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td>os.lchmod(path, mode)</td>
<td>修改连接文件权限</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td>os.lchown(path, uid, gid)</td>
<td>更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td>os.link(src, dst)</td>
<td>创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td>os.listdir(path)</td>
<td>返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td>os.lseek(fd, pos, how)</td>
<td>设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td>os.lstat(path)</td>
<td>像stat(),但是没有软链接</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td>os.major(device)</td>
<td>从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td>os.makedev(major, minor)</td>
<td>以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td>os.makedirs(path[, mode])</td>
<td>递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td>os.minor(device)</td>
<td>从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td style="text-align:center">35</td>
<td>os.mkdir(path[, mode])</td>
<td>以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td style="text-align:center">36</td>
<td>os.mkfifo(path[, mode])</td>
<td>创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td>os.mknod(filename[, mode=0600, device])</td>
<td>创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td style="text-align:center">38</td>
<td>os.open(file, flags[, mode])</td>
<td>打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td style="text-align:center">39</td>
<td>os.openpty()</td>
<td>打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td>os.pathconf(path, name)</td>
<td>返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td style="text-align:center">41</td>
<td>os.pipe()</td>
<td>创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr>
<td style="text-align:center">42</td>
<td>os.popen(command[, mode[, bufsize]])</td>
<td>从一个 command 打开一个管道</td>
</tr>
<tr>
<td style="text-align:center">43</td>
<td>os.read(fd, n)</td>
<td>从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td style="text-align:center">44</td>
<td>os.readlink(path)</td>
<td>返回软链接所指向的文件</td>
</tr>
<tr>
<td style="text-align:center">45</td>
<td>os.remove(path)</td>
<td>删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td style="text-align:center">46</td>
<td>os.removedirs(path)</td>
<td>递归删除目录。</td>
</tr>
<tr>
<td style="text-align:center">47</td>
<td>os.rename(src, dst)</td>
<td>重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td>os.renames(old, new)</td>
<td>递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td style="text-align:center">49</td>
<td>os.rmdir(path)</td>
<td>删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
</tbody>
</table>
<p>50<br>os.stat(path)</p>
<p>获取path指定的路径的信息，功能等同于C API中的stat()系统调用。<br>51<br>os.stat_float_times([newvalue])<br>决定stat_result是否以float对象显示时间戳<br>52<br>os.statvfs(path)</p>
<p>获取指定路径的文件系统统计信息<br>53<br>os.symlink(src, dst)</p>
<p>创建一个软链接<br>54<br>os.tcgetpgrp(fd)</p>
<p>返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组<br>55<br>os.tcsetpgrp(fd, pg)</p>
<p>设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。<br>56<br>os.tempnam([dir[, prefix]])</p>
<p>返回唯一的路径名用于创建临时文件。<br>57<br>os.tmpfile()</p>
<p>返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。<br>58<br>os.tmpnam()</p>
<p>为创建一个临时文件返回一个唯一的路径<br>59<br>os.ttyname(fd)</p>
<p>返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。<br>60<br>os.unlink(path)</p>
<p>删除文件路径<br>61<br>os.utime(path, times)</p>
<p>返回指定的path文件的访问和修改的时间。<br>62<br>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</p>
<p>输出在文件夹中的文件名通过在树中游走，向上或者向下。<br>63<br>os.write(fd, str)</p>
<p>写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</p>
<hr>
<h2 id="Python3-错误和异常"><a href="#Python3-错误和异常" class="headerlink" title="Python3 错误和异常"></a>Python3 错误和异常</h2><p>作为Python初学者，在刚学习Python编程时，经常会看到一些报错信息，在前面我们没有提及，这章节我们会专门介绍。</p>
<p>Python有两种错误很容易辨认：语法错误和异常。</p>
<hr>
<p>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例</p>
<pre><code>&gt;&gt;&gt; while True print(&apos;Hello world&apos;)
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
    while True print(&apos;Hello world&apos;)
                   ^
SyntaxError: invalid syntax
</code></pre><p>这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号（:）。</p>
<p>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。</p>
<hr>
<p>异常</p>
<p>即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。</p>
<p>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:</p>
<pre><code>&gt;&gt;&gt; 10 * (1/0)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
ZeroDivisionError: division by zero
&gt;&gt;&gt; 4 + spam*3
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: name &apos;spam&apos; is not defined
&gt;&gt;&gt; &apos;2&apos; + 2
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly
</code></pre><p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有<br>ZeroDivisionError，NameError 和 TypeError。</p>
<p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p>
<hr>
<p>异常处理</p>
<p>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用<br>Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个<br>KeyboardInterrupt 异常。</p>
<pre><code>&gt;&gt;&gt; while True:
        try:
            x = int(input(&quot;Please enter a number: &quot;))
            break
        except ValueError:
            print(&quot;Oops!  That was no valid number.  Try again   &quot;)
</code></pre><p>try语句按照如下方式工作；</p>
<ul>
<li>首先，执行try子句（在关键字try和关键字except之间的语句）</li>
<li>如果没有异常发生，忽略except子句，try子句执行后结束。</li>
<li>如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和    except 之后的名称相符，那么对应的except子句将被执行。最后执行 try    语句之后的代码。</li>
<li>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。</li>
</ul>
<p>一个 try语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p>
<p>处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try<br>的处理程序中的异常。</p>
<p>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p>
<pre><code>except (RuntimeError, TypeError, NameError):
    pass
</code></pre><p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p>
<pre><code>import sys

try:
    f = open(&apos;myfile.txt&apos;)
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print(&quot;OS error: {0}&quot;.format(err))
except ValueError:
    print(&quot;Could not convert data to an integer.&quot;)
except:
    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])
    raise
</code></pre><p>try except<br>语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。例如:</p>
<pre><code>for arg in sys.argv[1:]:
    try:
        f = open(arg, &apos;r&apos;)
    except IOError:
        print(&apos;cannot open&apos;, arg)
    else:
        print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;)
        f.close()
</code></pre><p>使用 else 子句比把所有的语句都放在 try<br>子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。</p>
<p>异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p>
<pre><code>&gt;&gt;&gt; def this_fails():
        x = 1/0

&gt;&gt;&gt; try:
        this_fails()
    except ZeroDivisionError as err:
        print(&apos;Handling run-time error:&apos;, err)

Handling run-time error: int division or modulo by zero
</code></pre><hr>
<p>抛出异常</p>
<p>Python 使用 raise 语句抛出一个指定的异常。例如:</p>
<pre><code>&gt;&gt;&gt; raise NameError(&apos;HiThere&apos;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: HiThere
</code></pre><p>raise<br>唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是<br>Exception 的子类）。</p>
<p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise<br>语句就可以再次把它抛出。</p>
<pre><code>&gt;&gt;&gt; try:
        raise NameError(&apos;HiThere&apos;)
    except NameError:
        print(&apos;An exception flew by!&apos;)
        raise

An exception flew by!
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in ?
NameError: HiThere
</code></pre><hr>
<p>用户自定义异常</p>
<p>你可以通过创建一个新的exception类来拥有自己的异常。异常应该继承自<br>Exception 类，或者直接继承，或者间接继承，例如:</p>
<pre><code>&gt;&gt;&gt; class MyError(Exception):
        def __init__(self, value):
            self.value = value
        def __str__(self):
            return repr(self.value)

&gt;&gt;&gt; try:
        raise MyError(2*2)
    except MyError as e:
        print(&apos;My exception occurred, value:&apos;, e.value)

My exception occurred, value: 4
&gt;&gt;&gt; raise MyError(&apos;oops!&apos;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
__main__.MyError: &apos;oops!&apos;
</code></pre><p>在这个例子中，类 Exception 默认的 __init__() 被覆盖。</p>
<p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p>
<pre><code>class Error(Exception):
    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;
    pass

class InputError(Error):
    &quot;&quot;&quot;Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    &quot;&quot;&quot;

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not
    allowed.

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    &quot;&quot;&quot;

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message
</code></pre><p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p>
<hr>
<p>定义清理行为</p>
<p>try<br>语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。<br>例如:</p>
<pre><code>&gt;&gt;&gt; try:
        raise KeyboardInterrupt
    finally:
        print(&apos;Goodbye, world!&apos;)

Goodbye, world!
KeyboardInterrupt
</code></pre><p>以上例子不管try子句里面有没有发生异常，finally子句都会执行。</p>
<p>如果一个异常在 try 子句里（或者在 except 和 else子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。</p>
<p>下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally<br>子句）:</p>
<pre><code>&gt;&gt;&gt; def divide(x, y):
        try:
            result = x / y
        except ZeroDivisionError:
            print(&quot;division by zero!&quot;)
        else:
            print(&quot;result is&quot;, result)
        finally:
            print(&quot;executing finally clause&quot;)

&gt;&gt;&gt; divide(2, 1)
result is 2.0
executing finally clause
&gt;&gt;&gt; divide(2, 0)
division by zero!
executing finally clause
&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)
executing finally clause
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;&lt;stdin&gt;&quot;, line 3, in divide
TypeError: unsupported operand type(s) for /: &apos;str&apos; and &apos;str&apos;
</code></pre><hr>
<p>预定义的清理行为</p>
<p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。</p>
<p>这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p>
<pre><code>for line in open(&quot;myfile.txt&quot;):
    print(line, end=&quot;&quot;)
</code></pre><p>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。</p>
<p>关键词 with<br>语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p>
<pre><code>with open(&quot;myfile.txt&quot;) as f:
    for line in f:
        print(line, end=&quot;&quot;)
</code></pre><p>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。</p>
<hr>
<h2 id="Python3-面向对象"><a href="#Python3-面向对象" class="headerlink" title="Python3 面向对象"></a>Python3 面向对象</h2><p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。</p>
<p>如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。</p>
<p>接下来我们先来简单的了解下面向对象的一些基本特征。</p>
<hr>
<p>面向对象技术简介</p>
<ul>
<li><strong>类(Class):</strong><br>用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>
<li><strong>实例变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li>
<li><strong>继承：</strong>即一个派生类（derived class）继承基类（base<br>class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li>
<li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li>
<li><strong>方法：</strong>类中定义的函数。</li>
<li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ul>
<p>和其它编程语言相比，Python在尽可能不增加新的语法和语义的情况下加入了类机制。</p>
<p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p>
<p>对象可以包含任意数量和类型的数据。</p>
<hr>
<p>类定义</p>
<p>语法格式如下：</p>
<pre><code>class ClassName:
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p>
<hr>
<p>类对象</p>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p>
<p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p>
<pre><code>#!/usr/bin/python3

class MyClass:
    &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;
    i = 12345
    def f(self):
        return &apos;hello world&apos;

# 实例化类
x = MyClass()

# 访问类的属性和方法
print(&quot;MyClass 类的属性 i 为：&quot;, x.i)
print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())
</code></pre><p>实例化类：</p>
<pre><code># 实例化类
x = MyClass()
# 访问类的属性和方法
</code></pre><p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p>
<p>执行以上程序输出结果为：</p>
<pre><code>MyClass 类的属性 i 为： 12345
MyClass 类的方法 f 输出为： hello world
</code></pre><hr>
<p>很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为<br>__init__() 的特殊方法（构造方法），像下面这样：</p>
<pre><code>def __init__(self):
    self.data = []
</code></pre><p>类定义了 __init__() 方法的话，类的实例化操作会自动调用<br>__init__() 方法。所以在下例中，可以这样创建一个新的实例:</p>
<pre><code>x = MyClass()
</code></pre><p>当然， __init__() 方法可以有参数，参数通过 __init__()<br>传递到类的实例化操作上。例如:</p>
<pre><code>&gt;&gt;&gt; class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
...
&gt;&gt;&gt; x = Complex(3.0, -4.5)
&gt;&gt;&gt; x.r, x.i
(3.0, -4.5)
</code></pre><hr>
<p>self代表类的实例，而非类</p>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>,<br>按照惯例它的名称是 self。</p>
<pre><code>class Test:
    def prt(self):
        print(self)
        print(self.__class__)

t = Test()
t.prt()
</code></pre><p>以上实例执行结果为：</p>
<pre><code>&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
</code></pre><p>从执行结果可以很明显的看出，self<br>代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。</p>
<p>self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</p>
<pre><code>class Test:
    def prt(runoob):
        print(runoob)
        print(runoob.__class__)

t = Test()
t.prt()
</code></pre><p>以上实例执行结果为：</p>
<pre><code>&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
</code></pre><hr>
<p>类的方法</p>
<p>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数:</p>
<pre><code>#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &apos;&apos;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

# 实例化类
p = people(&apos;runoob&apos;,10,30)
p.speak()
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>runoob 说: 我 10 岁。
</code></pre><hr>
<p>继承</p>
<p>Python<br>同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p>
<pre><code>class DerivedClassName(BaseClassName1):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索即方法在子类中未找到时，从左到右查找基类中是否包含方法。</p>
<p>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<pre><code>class DerivedClassName(modname.BaseClassName):
</code></pre><hr>
<p>实例</p>
<pre><code>#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &apos;&apos;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

#单继承示例
class student(people):
    grade = &apos;&apos;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))



s = student(&apos;ken&apos;,10,60,3)
s.speak()
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>ken 说: 我 10 岁了，我在读 3 年级
</code></pre><hr>
<p>多继承</p>
<p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<pre><code>class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索<br>即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<pre><code>#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &apos;&apos;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

#单继承示例
class student(people):
    grade = &apos;&apos;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))

#另一个类，多重继承之前的准备
class speaker():
    topic = &apos;&apos;
    name = &apos;&apos;
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))

#多重继承
class sample(speaker,student):
    a =&apos;&apos;
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)

test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre><hr>
<p>方法重写</p>
<p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<pre><code>#!/usr/bin/python3

class Parent:        # 定义父类
   def myMethod(self):
      print (&apos;调用父类方法&apos;)

class Child(Parent): # 定义子类
   def myMethod(self):
      print (&apos;调用子类方法&apos;)

c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>调用子类方法
</code></pre><hr>
<p>类属性与方法</p>
<p>— 类的私有属性</p>
<p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时<br><strong>self.__private_attrs</strong>。</p>
<p>— 类的方法</p>
<p>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数</p>
<p>— 类的私有方法</p>
<p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用<br><strong>self.__private_methods</strong>。</p>
<p>— 实例</p>
<p>类的私有属性实例如下：</p>
<pre><code>#!/usr/bin/python3

class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量

    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print (self.__secretCount)

counter = JustCounter()
counter.count()
counter.count()
print (counter.publicCount)
print (counter.__secretCount)  # 报错，实例不能访问私有变量
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 16, in &lt;module&gt;
    print (counter.__secretCount)  # 报错，实例不能访问私有变量
AttributeError: &apos;JustCounter&apos; object has no attribute &apos;__secretCount&apos;
</code></pre><p>类的私有方法实例如下：</p>
<pre><code>#!/usr/bin/python3

class Site:
    def __init__(self, name, url):
        self.name = name       # public
        self.__url = url   # private

    def who(self):
        print(&apos;name  : &apos;, self.name)
        print(&apos;url : &apos;, self.__url)

    def __foo(self):          # 私有方法
        print(&apos;这是私有方法&apos;)

    def foo(self):            # 公共方法
        print(&apos;这是公共方法&apos;)
        self.__foo()

x = Site(&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;)
x.who()        # 正常输出
x.foo()        # 正常输出
x.__foo()      # 报错
</code></pre><p>以上实例执行结果：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/05/F5C2A308-3A88-42B4-B575-C719EB8F1CC4.jpg" alt="">{width=”70%”}</p>
<p>— 类的专有方法：</p>
<ul>
<li><strong>__init__ :</strong> 构造函数，在生成对象时调用</li>
<li><strong>__del__ :</strong> 析构函数，释放对象时使用</li>
<li><strong>__repr__ :</strong> 打印，转换</li>
<li><strong>__setitem__ :</strong> 按照索引赋值</li>
<li><strong>__getitem__:</strong> 按照索引获取值</li>
<li><strong>__len__:</strong> 获得长度</li>
<li><strong>__cmp__:</strong> 比较运算</li>
<li><strong>__call__:</strong> 函数调用</li>
<li><strong>__add__:</strong> 加运算</li>
<li><strong>__sub__:</strong> 减运算</li>
<li><strong>__mul__:</strong> 乘运算</li>
<li><strong>__div__:</strong> 除运算</li>
<li><strong>__mod__:</strong> 求余运算</li>
<li><strong>__pow__:</strong> 称方</li>
</ul>
<p>— 运算符重载</p>
<p>Python同样支持运算符重载，我么可以对类的专有方法进行重载，实例如下：</p>
<pre><code>#!/usr/bin/python3

class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b

   def __str__(self):
      return &apos;Vector (%d, %d)&apos; % (self.a, self.b)

   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)
</code></pre><p>以上代码执行结果如下所示:</p>
<pre><code>Vector(7,8)
</code></pre><hr>
<h2 id="Python3-标准库概览"><a href="#Python3-标准库概览" class="headerlink" title="Python3 标准库概览"></a>Python3 标准库概览</h2><p>到python官网下载http: // pypi.python.org / pypi / xlrd模块安装，前提是已经安装了python<br>环境。</p>
<p>二、使用介绍</p>
<p>1、导入模块</p>
<p>import xlrd</p>
<p>2、打开Excel文件读取数据</p>
<p>data = xlrd.open_workbook(‘excelFile.xls’)</p>
<p>3、使用技巧</p>
<p>获取一个工作表</p>
<p>table = data.sheets()[0]  # 通过索引顺序获取</p>
<p>table = data.sheet_by_index(0)  # 通过索引顺序获取</p>
<p>table = data.sheet_by_name(u’Sheet1’)  # 通过名称获取</p>
<p>获取整行和整列的值（数组）<br>　　<br>table.row_values(i)</p>
<p>table.col_values(i)</p>
<p>获取行数和列数<br>　　<br>nrows = table.nrows</p>
<p>ncols = table.ncols</p>
<p>循环行列表数据<br>for i in range(nrows):<br>    print<br>table.row_values(i)</p>
<p>单元格<br>cell_A1 = table.cell(0, 0).value</p>
<p>cell_C4 = table.cell(2, 3).value</p>
<p>使用行列索引<br>cell_A1 = table.row(0)[0].value</p>
<p>cell_A2 = table.col(1)[0].value</p>
<p>简单的写入</p>
<pre><code>row = 0

col = 0

# 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error
</code></pre><p>ctype = 1<br>value = ‘单元格的值’</p>
<p>xf = 0  # 扩展的格式化</p>
<p>table.put_cell(row, col, ctype, value, xf)</p>
<p>table.cell(0, 0)  # 单元格的值’</p>
<p>table.cell(0, 0).value  # 单元格的值’</p>
<pre><code># -*- coding: utf-8 -*-
</code></pre><p>import  xdrlib ,sys<br>import xlrd<br>def open_excel(file= ‘file.xls’):<br>    try:<br>        data = xlrd.open_workbook(file)<br>        return data<br>    except Exception,e:<br>        print str(e)</p>
<pre><code>#根据索引获取Excel表格中的数据   参数:file：Excel文件路径     colnameindex：表头列名所在行的所以  ，by_index：表的索引
</code></pre><p>def excel_table_byindex(file= ‘file.xls’,colnameindex=0,by_index=0):<br>    data = open_excel(file)<br>    table = data.sheets()[by_index]<br>    nrows = table.nrows #行数<br>    ncols = table.ncols #列数<br>    colnames =  table.row_values(colnameindex) #某一行数据<br>    list =[]<br>    for rownum in range(1,nrows):</p>
<pre><code>     row = table.row_values(rownum)
     if row:
         app = {}
         for i in range(len(colnames)):
            app[colnames[i]] = row[i]
         list.append(app)
return list

#根据名称获取Excel表格中的数据   参数:file：Excel文件路径     colnameindex：表头列名所在行的所以  ，by_name：Sheet1名称
</code></pre><p>def excel_table_byname(file= ‘file.xls’,colnameindex=0,by_name=u’Sheet1’):<br>    data = open_excel(file)<br>    table = data.sheet_by_name(by_name)<br>    nrows = table.nrows #行数<br>    colnames =  table.row_values(colnameindex) #某一行数据<br>    list =[]<br>    for rownum in range(1,nrows):<br>         row = table.row_values(rownum)<br>         if row:<br>             app = {}<br>             for i in range(len(colnames)):<br>                app[colnames[i]] = row[i]<br>             list.append(app)<br>    return list</p>
<p>def main():<br>   tables = excel_table_byindex()<br>   for row in tables:<br>       print row</p>
<p>   tables = excel_table_byname()<br>   for row in tables:<br>       print row</p>
<p>if <strong>name</strong>==”<strong>main</strong>“:<br>    main()</p>
<hr>
<h2 id="Python3-扩展包"><a href="#Python3-扩展包" class="headerlink" title="Python3 扩展包"></a>Python3 扩展包</h2><hr>
<p>thread 多线程(MT)</p>
<pre><code>&gt;&gt; import thread
</code></pre><p>Python 的 threading 模块</p>
<p>Python 供了几个用于多线程编程的模块，包括 thread, threading 和 Queue 等。thread 和 threading 模块允许程序员创建和管理线程。thread 模块 供了基本的线程和锁的支持，而 threading 供了更高级别，功能更强的线程管理的功能。Queue 模块允许用户创建一个可以用于多个线程之间 共享数据的队列数据结构。</p>
<p>出于以下几点考虑，我们不建议您使用 thread 模块。</p>
<ul>
<li><p>更高级别的 threading 模块更为先 进，对线程的支持更为完善，而且使用 thread 模块里的属性有可能会与 threading 出现冲突。其次， 低级别的 thread 模块的同步原语很少(实际上只有一个)，而 threading 模块则有很多。</p>
</li>
<li><p>对于你的进程什么时候应该结束完全没有控制，当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作。至少 threading 模块能确保重要的子线程退出后进程才退出。</p>
</li>
</ul>
<hr>
<p>thread 模块</p>
<p>除了产生线程外，thread 模块也提供了基本的同步数 据结构锁对象(lock object，也叫原语锁，简单锁，互斥锁，互斥量，二值信号量)。</p>
<p>thread 模块函数</p>
<pre><code>start_new_thread(function, args, kwargs=None)：产生一个新的线程，在新线程中用指定的参数和可选的 kwargs 来调用这个函数。

allocate_lock()：分配一个 LockType 类型的锁对象

exit()：让线程退出

acquire(wait=None)：尝试获取锁对象

locked()：如果获取了锁对象返回 True，否则返回 False

release()：释放锁
</code></pre><p>下面是一个使用 thread 的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> thread</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, nsec, lock)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'start loop %s at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    sleep(nsec)</div><div class="line"></div><div class="line">    print(<span class="string">'loop %s done at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    <span class="comment"># 每个线程都会被分配一个事先已经获得的锁，在 sleep()的时间到了之后就释放 相应的锁以通知主线程，这个线程已经结束了。</span></div><div class="line"></div><div class="line">    lock.release()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'starting at:'</span>, time())</div><div class="line"></div><div class="line">    locks = []</div><div class="line"></div><div class="line">    nloops = range(len(loops))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># 调用 thread.allocate_lock()函数创建一个锁的列表</span></div><div class="line"></div><div class="line">        lock = thread.allocate_lock()</div><div class="line"></div><div class="line">        <span class="comment"># 分别调用各个锁的 acquire()函数获得, 获得锁表示“把锁锁上”</span></div><div class="line"></div><div class="line">        lock.acquire()</div><div class="line"></div><div class="line">        locks.append(lock)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># 创建线程，每个线程都用各自的循环号，睡眠时间和锁为参数去调用 loop()函数</span></div><div class="line"></div><div class="line">        thread.start_new_thread(loop, (, iloops[], ilocks[i]))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># 在线程结束的时候，线程要自己去做解锁操作</span></div><div class="line"></div><div class="line">        <span class="comment"># 当前循环只是坐在那一直等(达到暂停主 线程的目的)，直到两个锁都被解锁为止才继续运行。</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> locks[].ilocked(): <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    print(<span class="string">'all DONE at:'</span>, time())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>start_new_thread()要求一定要有前两个参数。所以，就算我们想要运行的函数不要参数，也要传一个空的元组。</p>
<p>为什么要加上sleep(6)这一句呢? 因为，如果我们没有让主线程停下来，那主线程就会运行下一条语句，显示 “all done”，然后就关闭运行着 loop()和 loop1()的两个线程，退出了。</p>
<p>我们有没有更好的办法替换使用sleep() 这种不靠谱的同步方式呢？答案是使用锁，使用了锁，我们就可以在两个线程都退出之后马上退出。</p>
<p>为什么我们不在创建锁的循环里创建线程呢?有以下几个原因:</p>
<ul>
<li><p>我们想到实现线程的同步，所以要让“所有的马同时冲出栅栏”。</p>
</li>
<li><p>获取锁要花一些时间，如果你的 线程退出得“太快”，可能会导致还没有获得锁，线程就已经结束了的情况。</p>
</li>
</ul>
<hr>
<p>threading 模块</p>
<p>threading 模块不仅提供了 Thread 类，还 供了各 种非常好用的同步机制。</p>
<p>下面是threading 模块里所有的对象：</p>
<ul>
<li><p>Thread： 表示一个线程的执行的对象</p>
</li>
<li><p>Lock： 锁原语对象(跟 thread 模块里的锁对象相同)</p>
</li>
<li><p>RLock： 可重入锁对象。使单线程可以再次获得已经获得了的锁(递归锁定)。</p>
</li>
<li><p>Condition： 条件变量对象能让一个线程停下来，等待其它线程满足了某个“条件”。如，状态的改变或值的改变。</p>
</li>
<li><p>Event： 通用的条件变量。多个线程可以等待某个事件的发生，在事件发生后， 所有的线程都会被激活。</p>
</li>
<li><p>Semaphore： 为等待锁的线程 供一个类似“等候室”的结构</p>
</li>
<li><p>BoundedSemaphore： 与 Semaphore 类似，只是它不允许超过初始值</p>
</li>
<li><p>Timer： 与 Thread 相似，只是，它要等待一段时间后才开始运行。</p>
</li>
</ul>
<p>守护线程</p>
<p>另一个避免使用 thread 模块的原因是，它不支持守护线程。当主线程退出时，所有的子线程不 论它们是否还在工作，都会被强行退出。有时，我们并不期望这种行为，这时，就引入了守护线程 的概念</p>
<p>threading 模块支持守护线程，它们是这样工作的:守护线程一般是一个等待客户请求的服务器， 如果没有客户 出请求，它就在那等着。如果你设定一个线程为守护线程，就表示你在说这个线程 是不重要的，在进程退出的时候，不用等待这个线程退出。</p>
<p>如果你的主线程要退出的时候，不用等待那些子线程完成，那就设定这些线程的 daemon 属性。 即，在线程开始(调用 thread.start())之前，调用setDaemon()函数设定线程的 daemon 标志 (thread.setDaemon(True))就表示这个线程“不重要”</p>
<p>如果你想要等待子线程完成再退出，那就什么都不用做，或者显式地调用 thread.setDaemon(False)以保证其 daemon 标志为 False。你可以调用thread.isDaemon()函数来判 断其 daemon 标志的值。新的子线程会继承其父线程的 daemon 标志。整个 Python 会在所有的非守护 线程退出后才会结束,即进程中没有非守护线程存在的时候才结束。</p>
<hr>
<p>Thread 类</p>
<p>Thread类提供了以下方法:</p>
<ul>
<li><p>run(): 用以表示线程活动的方法。</p>
</li>
<li><p>start():启动线程活动。</p>
</li>
<li><p>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</p>
</li>
<li><p>is_alive(): 返回线程是否活动的。</p>
</li>
<li><p>name(): 设置/返回线程名。</p>
</li>
<li><p>daemon(): 返回/设置线程的 daemon 标志，一定要在调用 start()函数前设置</p>
</li>
</ul>
<p>用 Thread 类，你可以用多种方法来创建线程。我们在这里介绍三种比较相像的方法。</p>
<ul>
<li><p>创建一个Thread的实例，传给它一个函数</p>
</li>
<li><p>创建一个Thread的实例，传给它一个可调用的类对象</p>
</li>
<li><p>从Thread派生出一个子类，创建一个这个子类的实例</p>
</li>
</ul>
<p>下边是三种不同方式的创建线程的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, nsec, lock)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'start loop %s at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    sleep(nsec)</div><div class="line"></div><div class="line">    print(<span class="string">'loop %s done at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    <span class="comment"># 每个线程都会被分配一个事先已经获得的锁，在 sleep()的时间到了之后就释放 相应的锁以通知主线程，这个线程已经结束了。</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'starting at:'</span>, time())</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line">    nloops = range(len(loops))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">         = tthreading.Thread(target=loop, args=(, iloops[i]))</div><div class="line"></div><div class="line">        threads.append()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    tfor  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># start threads</span></div><div class="line"></div><div class="line">        threads[].istart()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># wait for all</span></div><div class="line"></div><div class="line">        <span class="comment"># join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。</span></div><div class="line"></div><div class="line">        <span class="comment"># 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为"spinlock")</span></div><div class="line"></div><div class="line">        threads[].ijoin()  <span class="comment"># threads to finish</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    print(<span class="string">'all DONE at:'</span>, time())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>与传一个函数很相似的另一个方法是在创建线程的时候，传一个可调用的类的实例供线程启动 的时候执行——这是多线程编程的一个更为面向对象的方法。相对于一个或几个函数来说，由于类 对象里可以使用类的强大的功能，可以保存更多的信息，这种方法更为灵活</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadFunc</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">""</span>)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">        self.args = args</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。</span></div><div class="line"></div><div class="line">        self.func(*self.args)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, nsec)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'start loop %s at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    sleep(nsec)</div><div class="line"></div><div class="line">    print(<span class="string">'loop %s done at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'starting at:'</span>, time())</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line">    nloops = range(len(loops))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        t = Thread(target=ThreadFunc(loop, (, iloops[i]), loop.__name__))</div><div class="line"></div><div class="line">        threads.append()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    tfor  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># start threads</span></div><div class="line"></div><div class="line">        threads[].istart()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># wait for all</span></div><div class="line"></div><div class="line">        <span class="comment"># join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。</span></div><div class="line"></div><div class="line">        <span class="comment"># 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为"spinlock")</span></div><div class="line"></div><div class="line">        threads[].ijoin()  <span class="comment"># threads to finish</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    print(<span class="string">'all DONE at:'</span>, time())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>最后一个例子介绍如何子类化 Thread 类，这与上一个例子中的创建一个可调用的类非常像。使 用子类化创建线程(第 29-30 行)使代码看上去更清晰明了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">""</span>)</span>:</span></div><div class="line"></div><div class="line">        super(MyThread, self).__init__()</div><div class="line"></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">        self.args = args</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getResult</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。</span></div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">'starting'</span>, self.name, <span class="string">'at:'</span>, time()</div><div class="line"></div><div class="line">        self.res = self.func(*self.args)</div><div class="line"></div><div class="line">        <span class="keyword">print</span> self.name, <span class="string">'finished at:'</span>, time()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, nsec)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'start loop %s at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    sleep(nsec)</div><div class="line"></div><div class="line">    print(<span class="string">'loop %s done at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'starting at:'</span>, time())</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line">    nloops = range(len(loops))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        t = MyThread(loop, (, iloops[i]), loop.__name__)</div><div class="line"></div><div class="line">        threads.append()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    tfor  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># start threads</span></div><div class="line"></div><div class="line">        threads[].istart()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># wait for all</span></div><div class="line"></div><div class="line">        <span class="comment"># join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。</span></div><div class="line"></div><div class="line">        <span class="comment"># 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为"spinlock")</span></div><div class="line"></div><div class="line">        threads[].ijoin()  <span class="comment"># threads to finish</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    print(<span class="string">'all DONE at:'</span>, time())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>除了各种同步对象和线程对象外，threading 模块还 供了一些函数。</p>
<ul>
<li><p>active_count(): 当前活动的线程对象的数量</p>
</li>
<li><p>current_thread(): 返回当前线程对象</p>
</li>
<li><p>enumerate(): 返回当前活动线程的列表</p>
</li>
<li><p>settrace(func): 为所有线程设置一个跟踪函数</p>
</li>
<li><p>setprofile(func): 为所有线程设置一个 profile 函数</p>
</li>
</ul>
<hr>
<p>Lock &amp; RLock</p>
<p>原语锁定是一个同步原语，状态是锁定或未锁定。两个方法acquire()和release() 用于加锁和释放锁。</p>
<p>RLock 可重入锁是一个类似于Lock对象的同步原语，但同一个线程可以多次调用。</p>
<p>Lock 不支持递归加锁，也就是说即便在同 线程中，也必须等待锁释放。通常建议改 RLock， 它会处理 “owning thread” 和 “recursion level” 状态，对于同 线程的多次请求锁 为，只累加计数器。每次调 release() 将递减该计数器，直到 0 时释放锁，因此 acquire() 和 release() 必须 要成对出现。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqOVvR9rGR63zFhl4GsziamgiaK57Bz5e5DQwnkcJFESr6INibDrNtZYh3Gbibh6ibzTE2P57aVmspLO2w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<hr>
<p>Event</p>
<p>事件用于在线程间通信。一个线程发出一个信号，其他一个或多个线程等待。</p>
<p>Event 通过通过 个内部标记来协调多线程运 。 法 wait() 阻塞线程执 ，直到标记为 True。 set() 将标记设为 True，clear() 更改标记为 False。isSet() 用于判断标记状态。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqOVvR9rGR63zFhl4GsziamgzmVv3krdzPmiaEghdLfxx8ic37iaBMnPianJYiby96KbGiaMUJjxYVHmPFcw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<hr>
<p>Condition</p>
<p>条件变量和 Lock 参数一样，也是一个，也是一个同步原语，当需要线程关注特定的状态变化或事件的发生时使用这个锁定。</p>
<p>可以认为，除了Lock带有的锁定池外，Condition还包含一个等待池，池中的线程处于状态图中的等待阻塞状态，直到另一个线程调用notify()/notifyAll()通知；得到通知后线程进入锁定池等待锁定。</p>
<p>构造方法：</p>
<p>Condition([lock/rlock])</p>
<p>Condition 有以下这些方法：</p>
<ul>
<li><p>acquire([timeout])/release(): 调用关联的锁的相应方法。</p>
</li>
<li><p>wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。</p>
</li>
<li><p>notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。</p>
</li>
<li><p>notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。</p>
</li>
</ul>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqOVvR9rGR63zFhl4GsziamgOKibrfhsMI7icHyVNVH54HcIoia5gmuwfIT9ibEbCEmA0zAMt3GycO5Ltg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>只有获取锁的线程才能调用 wait() 和 notify()，因此必须在锁释放前调用。</p>
<p>当 wait() 释放锁后，其他线程也可进入 wait 状态。notifyAll() 激活所有等待线程，让它们去抢锁然后完成后续执行。</p>
<p>生产者-消费者问题和 Queue 模块</p>
<p>现在我们用一个经典的(生产者消费者)例子来介绍一下 Queue模块。</p>
<p>生产者消费者的场景是： 生产者生产货物，然后把货物放到一个队列之类的数据结构中，生产货物所要花费的时间无法预先确定。消费者消耗生产者生产的货物的时间也是不确定的。</p>
<p>常用的 Queue 模块的属性:</p>
<ul>
<li><p>queue(size): 创建一个大小为size的Queue对象。</p>
</li>
<li><p>qsize(): 返回队列的大小(由于在返回的时候，队列可能会被其它线程修改，所以这个值是近似值)</p>
</li>
<li><p>empty(): 如果队列为空返回 True，否则返回 False</p>
</li>
<li><p>full(): 如果队列已满返回 True，否则返回 False</p>
</li>
<li><p>put(item,block=0): 把item放到队列中，如果给了block(不为0)，函数会一直阻塞到队列中有空间为止</p>
</li>
<li><p>get(block=0): 从队列中取一个对象，如果给了 block(不为 0)，函数会一直阻塞到队列中有对象为止</p>
</li>
</ul>
<p>Queue 模块可以用来进行线程间通讯，让各个线程之间共享数据。</p>
<p>现在，我们创建一个队列，让 生产者(线程)把新生产的货物放进去供消费者(线程)使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">""</span>)</span>:</span></div><div class="line"></div><div class="line">        super(MyThread, self).__init__()</div><div class="line"></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">        self.args = args</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getResult</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。</span></div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">'starting'</span>, self.name, <span class="string">'at:'</span>, time()</div><div class="line"></div><div class="line">        self.res = self.func(*self.args)</div><div class="line"></div><div class="line">        <span class="keyword">print</span> self.name, <span class="string">'finished at:'</span>, time()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># writeQ()和 readQ()函数分别用来把对象放入队列和消耗队列中的一个对象。在这里我们使用 字符串'xxx'来表示队列中的对象。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeQ</span><span class="params">(queue)</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">'producing object for Q...'</span></div><div class="line"></div><div class="line">    queue.put(<span class="string">'xxx'</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">"size now"</span>, queue.qsize()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readQ</span><span class="params">(queue)</span>:</span></div><div class="line"></div><div class="line">    queue.get(<span class="number">1</span>)</div><div class="line"></div><div class="line">    print(<span class="string">"consumed object from Q... size now"</span>, queue.qsize())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(queue, loops)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># writer()函数只做一件事，就是一次往队列中放入一个对象，等待一会，然后再做同样的事</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> irange(loops):</div><div class="line"></div><div class="line">        writeQ(queue)</div><div class="line"></div><div class="line">        sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(queue, loops)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># reader()函数只做一件事，就是一次从队列中取出一个对象，等待一会，然后再做同样的事</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> irange(loops):</div><div class="line"></div><div class="line">        readQ(queue)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 设置有多少个线程要被运行</span></div><div class="line"></div><div class="line">funcs = [writer, reader]</div><div class="line"></div><div class="line">nfuncs = range(len(funcs))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    nloops = randint(<span class="number">10</span>, <span class="number">20</span>)</div><div class="line"></div><div class="line">    q = Queue(<span class="number">32</span>)</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> infuncs:</div><div class="line"></div><div class="line">        t = MyThread(funcs[], (, qinloops), funcs[i].__name__)</div><div class="line"></div><div class="line">        threads.append()</div><div class="line"></div><div class="line"></div><div class="line">    tfor  <span class="keyword">in</span> infuncs:</div><div class="line"></div><div class="line">        threads[].istart()</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> infuncs:</div><div class="line"></div><div class="line">        threads[].ijoin()</div><div class="line"></div><div class="line">        <span class="keyword">print</span> threads[].igetResult()</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">'all DONE'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<hr>
<p>FAQ</p>
<p>进程与线程。线程与进程的区别是什么?</p>
<p>进程(有时被称为重量级进程)是程序的一次 执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。</p>
<p>线程(有时被称为轻量级进程)跟进程有些相似，不同的是，所有的线程运行在同一个进程中， 共享相同的运行环境。它们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。</p>
<p>这篇文章很好的解释了 线程和进程的区别，推荐阅读: <a href="http://www.ruanyifeng.com/blo…" target="_blank" rel="external">http://www.ruanyifeng.com/blo…</a></p>
<p>Python 的线程。在 Python 中，哪一种多线程的程序表现得更好，I/O 密集型的还是计算 密集型的?</p>
<p>由于GIL的缘故，对所有面向 I/O 的(会调用内建的操作系统 C 代码的)程序来说，GIL 会在这个 I/O 调用之 前被释放，以允许其它的线程在这个线程等待 I/O 的时候运行。如果某线程并未使用很多 I/O 操作， 它会在自己的时间片内一直占用处理器(和 GIL)。也就是说，I/O 密集型的 Python 程序比计算密集 型的程序更能充分利用多线程环境的好处。</p>
<p>线程。你认为，多 CPU 的系统与一般的系统有什么大的不同?多线程的程序在这种系统上的表现会怎么样?</p>
<p>Python的线程就是C语言的一个pthread，并通过操作系统调度算法进行调度（例如linux是CFS）。为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度（当然是否真正进行上下文切换由操作系统自主决定）。</p>
<hr>
<p>伪代码</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqOVvR9rGR63zFhl4GsziamgmicjiaRklkib0EjLq9mFbcicbbOhNtTH6oxlAbYtSJDA1jdgibiaNElk3D6A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>这种模式在只有一个CPU核心的情况下毫无问题。任何一个线程被唤起时都能成功获得到GIL（因为只有释放了GIL才会引发线程调度）。</p>
<p>但当CPU有多个核心的时候，问题就来了。从伪代码可以看到，从release GIL到acquire GIL之间几乎是没有间隙的。所以当其他在其他核心上的线程被唤醒时，大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤醒执行的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。然后达到切换时间后进入待调度状态，再被唤醒，再等待，以此往复恶性循环。</p>
<p>简单的总结下就是：Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。</p>
<p>线程池。修改 生成者消费者 的代码，不再是一个生产者和一个消费者，而是可以有任意个 消费者线程(一个线程池)，每个线程可以在任意时刻处理或消耗任意多个产品。</p>
<hr>
<h2 id="Python3-实例"><a href="#Python3-实例" class="headerlink" title="Python3 实例"></a>Python3 实例</h2><hr>
<h2 id="Python3-正则表达式"><a href="#Python3-正则表达式" class="headerlink" title="Python3 正则表达式"></a>Python3 正则表达式</h2><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p>
<p>Python 自1.5版本起增加了<code>re</code>模块，它提供 Perl 风格的正则表达式模式。</p>
<p>re 模块使 Python 语言拥有全部的正则表达式功能。</p>
<p>compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。</p>
<p>re模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</p>
<p>本章节主要介绍Python中常用的正则表达式处理函数。</p>
<hr>
<p>re.match函数</p>
<p>re.match尝试从字符串的<strong>起始位置</strong>匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>
<p><strong>函数语法</strong>：</p>
<pre><code>re.match(pattern, string, flags=0)
</code></pre><p>函数参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>匹配的正则表达式</td>
</tr>
<tr>
<td>string</td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td>flags</td>
<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>
</tr>
</tbody>
</table>
<p>匹配成功re.match方法返回一个匹配的对象，否则返回None。</p>
<p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">匹配对象方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">group(num=0)</td>
<td style="text-align:left">匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>
</tr>
<tr>
<td style="text-align:left">groups()</td>
<td style="text-align:left">返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>
</tr>
</tbody>
</table>
<p>实例 1：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-

import re
print(re.match(&apos;www&apos;, &apos;www.runoob.com&apos;).span())  # 在起始位置匹配
print(re.match(&apos;com&apos;, &apos;www.runoob.com&apos;))         # 不在起始位置匹配
</code></pre><p>以上实例运行输出结果为：</p>
<pre><code>(0, 3)
None
</code></pre><p>实例 2：</p>
<pre><code>#!/usr/bin/python3
import re

line = &quot;Cats are smarter than dogs&quot;

matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)

if matchObj:
   print (&quot;matchObj.group() : &quot;, matchObj.group())
   print (&quot;matchObj.group(1) : &quot;, matchObj.group(1))
   print (&quot;matchObj.group(2) : &quot;, matchObj.group(2))
else:
   print (&quot;No match!!&quot;)
</code></pre><p>以上实例执行结果如下：</p>
<pre><code>matchObj.group() :  Cats are smarter than dogs
matchObj.group(1) :  Cats
matchObj.group(2) :  smarter
</code></pre><hr>
<p>re.search方法</p>
<p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<p>函数语法：</p>
<pre><code>re.search(pattern, string, flags=0)
</code></pre><p>函数参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>匹配的正则表达式</td>
</tr>
<tr>
<td>string</td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td>flags</td>
<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>
</tr>
</tbody>
</table>
<p>匹配成功re.search方法返回一个匹配的对象，否则返回None。</p>
<p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<table>
<thead>
<tr>
<th>匹配对象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(num=0)</td>
<td>匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>
</tr>
<tr>
<td>groups()</td>
<td>返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>
</tr>
</tbody>
</table>
<p>实例 1：</p>
<pre><code>#!/usr/bin/python3

import re

print(re.search(&apos;www&apos;, &apos;www.runoob.com&apos;).span())  # 在起始位置匹配
print(re.search(&apos;com&apos;, &apos;www.runoob.com&apos;).span())         # 不在起始位置匹配
</code></pre><p>以上实例运行输出结果为：</p>
<pre><code>(0, 3)
(11, 14)
</code></pre><p>实例 2：</p>
<pre><code>#!/usr/bin/python3

import re

line = &quot;Cats are smarter than dogs&quot;;

searchObj = re.search( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)

if searchObj:
   print (&quot;searchObj.group() : &quot;, searchObj.group())
   print (&quot;searchObj.group(1) : &quot;, searchObj.group(1))
   print (&quot;searchObj.group(2) : &quot;, searchObj.group(2))
else:
   print (&quot;Nothing found!!&quot;)
</code></pre><p>以上实例执行结果如下：</p>
<pre><code>searchObj.group() :  Cats are smarter than dogs
searchObj.group(1) :  Cats
searchObj.group(2) :  smarter
</code></pre><hr>
<p>re.match与re.search的区别</p>
<p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>
<p>实例：</p>
<pre><code>#!/usr/bin/python3

import re

line = &quot;Cats are smarter than dogs&quot;;

matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I)
if matchObj:
   print (&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())
else:
   print (&quot;No match!!&quot;)

matchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I)
if matchObj:
   print (&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())
else:
   print (&quot;No match!!&quot;)
</code></pre><p>以上实例运行结果如下：</p>
<pre><code>No match!!
search --&gt; matchObj.group() :  dogs
</code></pre><hr>
<p>检索和替换</p>
<p>Python 的re模块提供了re.sub用于替换字符串中的匹配项。</p>
<p>语法：</p>
<pre><code>re.sub(pattern, repl, string, count=0)
</code></pre><p>参数：</p>
<ul>
<li>pattern : 正则中的模式字符串。</li>
<li>repl : 替换的字符串，也可为一个函数。</li>
<li>string : 要被查找替换的原始字符串。</li>
<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>
</ul>
<p>实例：</p>
<pre><code>#!/usr/bin/python3
import re

phone = &quot;2004-959-559 # 这是一个电话号码&quot;

# 删除注释
num = re.sub(r&apos;#.*$&apos;, &quot;&quot;, phone)
print (&quot;电话号码 : &quot;, num)

# 移除非数字的内容
num = re.sub(r&apos;\D&apos;, &quot;&quot;, phone)
print (&quot;电话号码 : &quot;, num)
</code></pre><p>以上实例执行结果如下：</p>
<pre><code>电话号码 :  2004-959-559
电话号码 :  2004959559
</code></pre><hr>
<p>repl 参数是一个函数</p>
<p>以下实例中将字符串中的匹配的数字乘于 2：</p>
<pre><code>#!/usr/bin/python

import re

# 将匹配的数字乘于 2
def double(matched):
    value = int(matched.group(&apos;value&apos;))
    return str(value * 2)

s = &apos;A23G4HFD567&apos;
print(re.sub(&apos;(?P&lt;value&gt;\d+)&apos;, double, s))
</code></pre><p>执行输出结果为：</p>
<pre><code>A46G8HFD1134
</code></pre><hr>
<p>正则表达式修饰符 - 可选标志</p>
<p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.I</td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td>re.L</td>
<td>做本地化识别（local-aware）匹配</td>
</tr>
<tr>
<td>re.M</td>
<td>多行匹配，影响 ^ 和 \$</td>
</tr>
<tr>
<td>re.S</td>
<td>使 . 匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td>re.U</td>
<td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td>
</tr>
<tr>
<td>re.X</td>
<td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td>
</tr>
</tbody>
</table>
<hr>
<p>正则表达式模式</p>
<p>模式字符串使用特殊的语法来表示一个正则表达式：</p>
<ul>
<li><p>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。</p>
</li>
<li><p>多数字母和数字前加一个反斜杠时会拥有不同的含义。</p>
</li>
<li><p>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。</p>
</li>
<li><p>反斜杠本身需要使用反斜杠转义。</p>
</li>
<li><p>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如<br>r’/t’，等价于’//t’)匹配相应的特殊字符。</p>
</li>
</ul>
<p>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td>\$</td>
<td>匹配字符串的末尾。</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td>[…]</td>
<td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td>
</tr>
<tr>
<td>[^…]</td>
<td>不在[]中的字符：[\^abc] 匹配除了a,b,c之外的字符。</td>
</tr>
<tr>
<td>re*</td>
<td>匹配0个或多个的表达式。</td>
</tr>
<tr>
<td>re+</td>
<td>匹配1个或多个的表达式。</td>
</tr>
<tr>
<td>re?</td>
<td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td>re{ n}</td>
</tr>
<tr>
<td>re{ n,}</td>
<td>精确匹配n个前面表达式。</td>
</tr>
<tr>
<td>re{ n, m}</td>
<td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td>a\</td>
<td>b</td>
<td>匹配a或b</td>
</tr>
<tr>
<td>(re)</td>
<td>G匹配括号内的表达式，也表示一个组</td>
</tr>
<tr>
<td>(?imx)</td>
<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>
</tr>
<tr>
<td>(?-imx)</td>
<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>
</tr>
<tr>
<td>(?: re)</td>
<td>类似 (…), 但是不表示一个组</td>
</tr>
<tr>
<td>(?imx: re)</td>
<td>在括号中使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>(?-imx: re)</td>
<td>在括号中不使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>(?#…)</td>
<td>注释.</td>
</tr>
<tr>
<td>(?= re)</td>
<td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td>(?! re)</td>
<td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>
</tr>
<tr>
<td>(?&gt; re)</td>
<td>匹配的独立模式，省去回溯。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母数字</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意空白字符，等价于 [\t\n\r\f].</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意非空字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任意数字，等价于 [0-9].</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字</td>
</tr>
<tr>
<td>\A</td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td>\Z</td>
<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c</td>
</tr>
<tr>
<td>\z</td>
<td>匹配字符串结束</td>
</tr>
<tr>
<td>\G</td>
<td>匹配最后匹配完成的位置。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td>\n, \t, etc.</td>
<td>匹配一个换行符。匹配一个制表符。等</td>
</tr>
<tr>
<td>\1…\9</td>
<td>匹配第n个分组的子表达式。</td>
</tr>
<tr>
<td>\10</td>
<td>匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。</td>
</tr>
</tbody>
</table>
<hr>
<p>正则表达式实例</p>
<hr>
<p>字符匹配</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>python</td>
<td>匹配 “python”.</td>
</tr>
</tbody>
</table>
<hr>
<p>字符类</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Pp]ython</td>
<td>匹配 “Python” 或 “python”</td>
</tr>
<tr>
<td>rub[ye]</td>
<td>匹配 “ruby” 或 “rube”</td>
</tr>
<tr>
<td>[aeiou]</td>
<td>匹配中括号内的任意一个字母</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配任何数字。类似于 [0123456789]</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配任何小写字母</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>匹配任何大写字母</td>
</tr>
<tr>
<td>[a-zA-Z0-9]</td>
<td>匹配任何字母及数字</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>除了aeiou字母以外的所有字符</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>匹配除了数字外的字符</td>
</tr>
</tbody>
</table>
<hr>
<p>特殊字符类</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]‘ 的模式。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 [\^0-9]。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]‘。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。等价于 ‘[\^A-Za-z0-9_]‘。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Python3-CGI编程"><a href="#Python3-CGI编程" class="headerlink" title="Python3 CGI编程"></a>Python3 CGI编程</h2><hr>
<h2 id="Python3-MySQL"><a href="#Python3-MySQL" class="headerlink" title="Python3 MySQL"></a>Python3 MySQL</h2><hr>
<h2 id="Python3-网络编程"><a href="#Python3-网络编程" class="headerlink" title="Python3 网络编程"></a>Python3 网络编程</h2><hr>
<h2 id="Python3-SMTP发送邮件"><a href="#Python3-SMTP发送邮件" class="headerlink" title="Python3 SMTP发送邮件"></a>Python3 SMTP发送邮件</h2><p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。</p>
<p>python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。</p>
<p>Python创建 SMTP 对象语法如下：</p>
<pre><code>import smtplib

smtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )
</code></pre><p>参数说明：</p>
<ul>
<li>host: SMTP 服务器主机。<br>你可以指定主机的ip地址或者域名如:w3cschool.cc，这个是可选参数。</li>
<li>port: 如果你提供了 host 参数, 你需要指定 SMTP服务使用的端口号，一般情况下SMTP端口号为25。</li>
<li>local_hostname: 如果SMTP在你的本机上，你只需要指定服务器地址为localhost 即可。</li>
</ul>
<p>Python SMTP对象使用sendmail方法发送邮件，语法如下：</p>
<pre><code>SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options]
</code></pre><p>参数说明：</p>
<ul>
<li>from_addr: 邮件发送者地址。</li>
<li>to_addrs: 字符串列表，邮件发送地址。</li>
<li>msg: 发送消息</li>
</ul>
<p>这里要注意一下第三个参数，msg是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意msg的格式。这个格式就是smtp协议中定义的格式。</p>
<p>实例</p>
<p>以下是一个使用Python发送邮件简单的实例：</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.text import MIMEText
from email.header import Header

sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

# 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码
message = MIMEText(&apos;Python 邮件发送测试...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)
message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)

subject = &apos;Python SMTP 邮件测试&apos;
message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)


try:
    smtpObj = smtplib.SMTP(&apos;localhost&apos;)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)
</code></pre><p>我们使用三个引号来设置邮件信息，标准邮件需要三个头部信息： <strong>From</strong>,<br><strong>To</strong>, 和 <strong>Subject</strong> ，每个信息直接使用空行分割。</p>
<p>我们通过实例化 smtplib 模块的 SMTP 对象 <em>smtpObj</em> 来连接到 SMTP<br>访问，并使用 <em>sendmail</em> 方法来发送信息。</p>
<p>执行以上程序，如果你本机安装sendmail，就会输出：</p>
<pre><code>$ python3 test.py
邮件发送成功
</code></pre><p>查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2016/04/smtp1.jpg" alt=""></p>
<p>如果我们本机没有 sendmail 访问，也可以使用其他服务商的 SMTP访问（QQ、网易、Google等）。</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.text import MIMEText
from email.header import Header

# 第三方 SMTP 服务
mail_host=&quot;smtp.XXX.com&quot;  #设置服务器
mail_user=&quot;XXXX&quot;    #用户名
mail_pass=&quot;XXXXXX&quot;   #口令


sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

message = MIMEText(&apos;Python 邮件发送测试...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)
message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)

subject = &apos;Python SMTP 邮件测试&apos;
message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)


try:
    smtpObj = smtplib.SMTP()
    smtpObj.connect(mail_host, 25)    # 25 为 SMTP 端口号
    smtpObj.login(mail_user,mail_pass)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)
</code></pre><hr>
<p>发送HTML格式的邮件</p>
<p>Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中_subtype设置为html。具体代码如下：</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.text import MIMEText
from email.header import Header

sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

mail_msg = &quot;&quot;&quot;
&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;
&quot;&quot;&quot;
message = MIMEText(mail_msg, &apos;html&apos;, &apos;utf-8&apos;)
message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)

subject = &apos;Python SMTP 邮件测试&apos;
message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)


try:
    smtpObj = smtplib.SMTP(&apos;localhost&apos;)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)
</code></pre><p>执行以上程序，如果你本机安装sendmail，就会输出：</p>
<pre><code>$ python3 test.py
邮件发送成功
</code></pre><p>查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2016/04/smtp2.jpg" alt=""></p>
<hr>
<p>发送带附件的邮件</p>
<p>发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header

sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

#创建一个带附件的实例
message = MIMEMultipart()
message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)
subject = &apos;Python SMTP 邮件测试&apos;
message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)

#邮件正文内容
message.attach(MIMEText(&apos;这是菜鸟教程Python 邮件发送测试……&apos;, &apos;plain&apos;, &apos;utf-8&apos;))

# 构造附件1，传送当前目录下的 test.txt 文件
att1 = MIMEText(open(&apos;test.txt&apos;, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;)
att1[&quot;Content-Type&quot;] = &apos;application/octet-stream&apos;
# 这里的filename可以任意写，写什么名字，邮件中显示什么名字
att1[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;test.txt&quot;&apos;
message.attach(att1)

# 构造附件2，传送当前目录下的 runoob.txt 文件
att2 = MIMEText(open(&apos;runoob.txt&apos;, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;)
att2[&quot;Content-Type&quot;] = &apos;application/octet-stream&apos;
att2[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;runoob.txt&quot;&apos;
message.attach(att2)

try:
    smtpObj = smtplib.SMTP(&apos;localhost&apos;)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)

$ python3 test.py
邮件发送成功
</code></pre><p>查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2013/11/smtp3.jpg" alt=""></p>
<hr>
<p>HTML 文本中添加图片</p>
<p>邮件的 HTML<br>文本中一般邮件服务商添加外链是无效的，正确添加突破的实例如下所示：</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.header import Header

sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

msgRoot = MIMEMultipart(&apos;related&apos;)
msgRoot[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
msgRoot[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)
subject = &apos;Python SMTP 邮件测试&apos;
msgRoot[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)

msgAlternative = MIMEMultipart(&apos;alternative&apos;)
msgRoot.attach(msgAlternative)


mail_msg = &quot;&quot;&quot;
&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot;&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图片演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;cid:image1&quot;&gt;&lt;/p&gt;
&quot;&quot;&quot;
msgAlternative.attach(MIMEText(mail_msg, &apos;html&apos;, &apos;utf-8&apos;))

# 指定图片为当前目录
fp = open(&apos;test.png&apos;, &apos;rb&apos;)
msgImage = MIMEImage(fp.read())
fp.close()

# 定义图片 ID，在 HTML 文本中引用
msgImage.add_header(&apos;Content-ID&apos;, &apos;&lt;image1&gt;&apos;)
msgRoot.attach(msgImage)

try:
    smtpObj = smtplib.SMTP(&apos;localhost&apos;)
    smtpObj.sendmail(sender, receivers, msgRoot.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)

$ python3 test.py
邮件发送成功
</code></pre><p>查看我们的收件箱(如果在垃圾箱可能需要移动到收件箱才可正常显示)，就可以查看到邮件信息：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2016/04/smtp4.jpg" alt=""></p>
<p>更多内容请参阅：<a href="https://docs.python.org/3/library/email-examples.html" target="_blank" rel="external">https://docs.python.org/3/library/email-examples.html</a>。</p>
<hr>
<h2 id="Python3-多线程"><a href="#Python3-多线程" class="headerlink" title="Python3 多线程"></a>Python3 多线程</h2><hr>
<h2 id="Python3-XML解析"><a href="#Python3-XML解析" class="headerlink" title="Python3 XML解析"></a>Python3 XML解析</h2><hr>
<h2 id="Python3-JSON"><a href="#Python3-JSON" class="headerlink" title="Python3 JSON"></a>Python3 JSON</h2><hr>
<h2 id="Python3-日期和时间"><a href="#Python3-日期和时间" class="headerlink" title="Python3 日期和时间"></a>Python3 日期和时间</h2><hr>
<h2 id="Python-输出指定范围内的素数"><a href="#Python-输出指定范围内的素数" class="headerlink" title="Python 输出指定范围内的素数"></a>Python 输出指定范围内的素数</h2><hr>
<h2 id="Python-装饰器"><a href="#Python-装饰器" class="headerlink" title="Python 装饰器"></a>Python 装饰器</h2><p>我们知道，在 Python 中，我们可以像使用变量一样使用函数：</p>
<ul>
<li>函数可以被赋值给其他变量</li>
<li>函数可以被删除</li>
<li>可以在函数里面再定义函数</li>
<li>函数可以作为参数传递给另外一个函数</li>
<li>函数可以作为另一个函数的返回</li>
</ul>
<p>简而言之，函数就是一个对象。</p>
<hr>
<p>对一个简单的函数进行装饰</p>
<p>为了更好地理解装饰器，我们先从一个简单的例子开始，假设有下面的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<p>在上面，我们将 hello 函数传给 makeitalic，再将返回赋给 hello，此时调用 hello() 就得到了我们想要的结果。</p>
<p>不过要注意的是，由于我们将 makeitalic 的返回赋给了 hello，此时 hello() 函数仍然存在，但是它的函数名不再是 hello 了，而是 wrapped，正是 makeitalic 返回函数的名称，可以验证一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello.__name__</div><div class="line"><span class="string">'wrapped'</span></div></pre></td></tr></table></figure></p>
<p>对于这个小瑕疵，后文将会给出解决方法。</p>
<p>现在，我们梳理一下上面的例子，为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，完整的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div><div class="line"></div><div class="line">hello = makeitalic(hello)</div></pre></td></tr></table></figure></p>
<p>事实上，makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello，并返回一个函数，将其赋给 hello。</p>
<p>一般情况下，我们使用装饰器提供的 @ 语法糖（Syntactic Sugar），来简化上面的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<p>像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello）为参数，并返回一个包装后的函数（比如上面的 wrapped）给被装饰函数（hello）。</p>
<hr>
<p>装饰器的使用形式</p>
<p>装饰器的一般使用形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>等价于下面的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line">func = decorator(func)</div></pre></td></tr></table></figure>
<p>装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator_one</span></div><div class="line"><span class="meta">@decorator_two</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">func = decorator_one(decorator_two(func))</div></pre></td></tr></table></figure>
<p>装饰器还可以带参数，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator(arg1, arg2)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">等价于：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">func = decorator(arg1, arg2)(func)</div></pre></td></tr></table></figure>
<p>下面我们再看一些具体的例子，以加深对它的理解。</p>
<p>对带参数的函数进行装饰</p>
<p>前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        ret = func(*args, **kwargs)</div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;i&gt;'</span> + ret + <span class="string">'&lt;/i&gt;'</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">(name1, name2)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s, %s'</span> % (name1, name2)</div></pre></td></tr></table></figure>
<p>由于函数 hello 带参数，因此内嵌包装函数 wrapped 也做了一点改变：</p>
<p>内嵌包装函数的参数传给了 func，即被装饰函数，也就是说内嵌包装函数的参数跟被装饰函数的参数对应，这里使用了 (<em>args, *</em>kwargs)，是为了适应可变参数。</p>
<p>看看使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello(<span class="string">'python'</span>)</div><div class="line"><span class="string">'&lt;i&gt;hello python&lt;/i&gt;'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello2(<span class="string">'python'</span>, <span class="string">'java'</span>)</div><div class="line"><span class="string">'&lt;i&gt;hello python, java&lt;/i&gt;'</span></div></pre></td></tr></table></figure>
<hr>
<p>带参数的装饰器</p>
<p>上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <code>&lt;i&gt;…&lt;/i&gt;</code>，现在，我们想改用标签 <code>&lt;b&gt;…&lt;/b&gt;</code> 或 <code>&lt;p&gt;…&lt;/p&gt;</code>。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrap_in_tag</span><span class="params">(tag)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            ret = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> <span class="string">'&lt;'</span> + tag + <span class="string">'&gt;'</span> + ret + <span class="string">'&lt;/'</span> + tag + <span class="string">'&gt;'</span></div><div class="line">        <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>现在，我们可以根据需要生成想要的装饰器了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">makebold = wrap_in_tag(<span class="string">'b'</span>)  <span class="comment"># 根据 'b' 返回 makebold 生成器</span></div><div class="line"></div><div class="line"><span class="meta">@makebold</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello(<span class="string">'world'</span>)</div><div class="line"><span class="string">'&lt;b&gt;hello world&lt;/b&gt;'</span></div></pre></td></tr></table></figure>
<p>上面的形式也可以写得更加简洁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@wrap_in_tag('b')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div></pre></td></tr></table></figure>
<p>这就是带参数的装饰器，其实就是在装饰器外面多了一层包装，根据不同的参数返回不同的装饰器。</p>
<hr>
<p>多个装饰器</p>
<p>现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makebold</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;b&gt;'</span> + func() + <span class="string">'&lt;/b&gt;'</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;i&gt;'</span> + func() + <span class="string">'&lt;/i&gt;'</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makebold</span></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<p>上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div><div class="line"></div><div class="line">hello = makebold(makeitalic(hello))</div></pre></td></tr></table></figure>
<p>调用函数 hello：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello()</div><div class="line"><span class="string">'&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;'</span></div></pre></td></tr></table></figure>
<p>基于类的装饰器</p>
<p>前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bold</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;b&gt;'</span> + self.func(*args, **kwargs) + <span class="string">'&lt;/b&gt;'</span></div><div class="line"></div><div class="line"><span class="meta">@Bold</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello(<span class="string">'world'</span>)</div><div class="line"><span class="string">'&lt;b&gt;hello world&lt;/b&gt;'</span></div></pre></td></tr></table></figure>
<p>可以看到，类 Bold 有两个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__init__()：它接收一个函数作为参数，也就是被装饰的函数</div><div class="line">__call__()：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用</div></pre></td></tr></table></figure>
<p>还可以让类装饰器带参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tag)</span>:</span></div><div class="line">        self.tag = tag</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"&lt;&#123;tag&#125;&gt;&#123;res&#125;&lt;/&#123;tag&#125;&gt;"</span>.format(</div><div class="line">                res=func(*args, **kwargs), tag=self.tag</div><div class="line">            )</div><div class="line">        <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@Tag('b')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div></pre></td></tr></table></figure>
<p>需要注意的是，如果类装饰器有参数，则 <code>__init__</code> 接收参数，而 <code>__call__</code> 接收 func。</p>
<hr>
<p>装饰器的副作用</p>
<p>前面提到，使用装饰器有一个瑕疵，就是被装饰的函数，它的函数名称已经不是原来的名称了，回到最开始的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<p>函数 hello 被 makeitalic 装饰后，它的函数名称已经改变了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello.__name__</div><div class="line"><span class="string">'wrapped'</span></div></pre></td></tr></table></figure>
<p>为了消除这样的副作用，Python 中的 functool 包提供了一个 wraps 的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">    @wraps(func)       # 加上 wraps 装饰器</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello.__name__</div><div class="line"><span class="string">'hello'</span></div></pre></td></tr></table></figure>
<p>小结</p>
<ul>
<li>本质上，装饰器就是一个返回函数的高阶函数。</li>
<li>装饰器可以动态地修改一个类或函数的功能，通过在原有的类或者函数上包裹一层修饰类或修饰函数实现。</li>
<li>事实上，装饰器就是闭包的一种应用，但它比较特别，接收被装饰函数为参数，并返回一个函数，赋给被装饰函数，闭包则没这种限制。</li>
</ul>
<hr>
</div></article><div class="pagination"><span class="pagination-prev">PREV</span><a href="/2017/09/29/DBMSSAS-Assignment3/" class="pagination-next">NEXT</a></div><div class="comments"></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blog/">Blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COLLECTION/">COLLECTION</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Notes/">Notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TA/">TA</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/07/Python-3-Basic/">Python 3 Basic</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/29/DBMSSAS-Assignment3/">DBMSSAS Assignment3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/28/Python-资源包大全/">Python 资源包大全</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/DBMSSAS-Assignment2/">DBMSSAS Assignment2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/DBMSSAS-Assignment1/">DBMSSAS Assignment1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/数据库基础及SAS应用/">数据库基础及SAS应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/15/python相关技巧/">python相关技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/Pandas-Cheat-List/">Pandas Cheat List</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2017 <a href="/">Mingo Tang</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>