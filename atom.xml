<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mingo的博客</title>
  <subtitle>My Personal Blog</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://mingotang.github.io/"/>
  <updated>2017-10-07T03:23:23.000Z</updated>
  <id>http://mingotang.github.io/</id>
  
  <author>
    <name>Mingo Tang</name>
    <email>mtang024@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 3 Basic</title>
    <link href="http://mingotang.github.io/2017/10/07/Python-3-Basic/"/>
    <id>http://mingotang.github.io/2017/10/07/Python-3-Basic/</id>
    <published>2017-10-07T03:11:19.000Z</published>
    <updated>2017-10-07T03:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<blockquote>
<p><a href="https://docs.python.org/3.5/index.html" target="_blank" rel="external">Python 3.5.3 documentation</a></p>
</blockquote>
<h2 id="Python-3-教程"><a href="#Python-3-教程" class="headerlink" title="Python 3 教程"></a><a href="http://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="external">Python 3 教程</a></h2><p><img src="http://www.runoob.com/wp-content/uploads/2014/05/python3.png" alt="python3"></p>
<p>Python的3.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。为了不带入过多的累赘，Python<br>3.0在设计的时候没有考虑向下兼容。</p>
<p>Python 介绍及安装教程我们在<a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="external">Python2.X版本的教程</a>中已有介绍，这里就不再赘述。</p>
<p>你也可以点击<a href="http://www.runoob.com/python-2x-3x.html" target="_blank" rel="external">Python2.x与3.x版本区别</a>来查看两者的不同。</p>
<p>本教程主要针对Python 3.x版本的学习，如果你使用的是Python<br>2.x版本请移步至<a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="external">Python2.X版本的教程</a>。</p>
<hr>
<p>查看python版本</p>
<p>我们可以使用以下命令来查看我们使用的Python版本：</p>
<pre><code>python -V
</code></pre><p>以上命令执行结果如下：</p>
<pre><code>Python 3.3.2
</code></pre><p>你也可以进入Python的交互式编程模式，查看版本：</p>
<pre><code>Python 3.3.2 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)] on win32
Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license()&quot; for more information.
&gt;&gt;&gt;
</code></pre><hr>
<p>第一个Python3.x程序</p>
<p>对于大多数程序语言，第一个入门编程代码便是”Hello<br>World！”，以下代码为使用Python输出”Hello World！”：</p>
<pre><code>#!/usr/bin/python3
print(&quot;Hello, World!&quot;)
</code></pre><p>你可以将以上代码保存在hello.py文件中并使用python命令执行该脚本文件。</p>
<pre><code>$ python3 hello.py
</code></pre><p>以上命令输出结果为：</p>
<pre><code>Hello, World!
</code></pre><hr>
<h2 id="Python3-基础语法"><a href="#Python3-基础语法" class="headerlink" title="Python3 基础语法"></a>Python3 基础语法</h2><p>编码</p>
<p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode<br>字符串。 当然你也可以为源码文件指定不同的编码：</p>
<pre><code># -*- coding: cp-1252 -*-
</code></pre><hr>
<p>标识符</p>
<ul>
<li>第一个字符必须是字母表中字母或下划线’_‘。</li>
<li>标识符的其他的部分有字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>在Python 3中，非-ASCII 标识符也是允许的了。</p>
<hr>
<p>python保留字</p>
<p>保留字即关键字，我们不能把它们用作任何标识符名称。Python的标准库提供了一个keyword module，可以输出当前版本的所有关键字：</p>
<pre><code>&gt;&gt;&gt; import keyword
&gt;&gt;&gt; keyword.kwlist
[&apos;False&apos;, &apos;None&apos;, &apos;True&apos;, &apos;and&apos;, &apos;as&apos;, &apos;assert&apos;, &apos;break&apos;, &apos;class&apos;, &apos;continue&apos;, &apos;def&apos;, &apos;del&apos;, &apos;elif&apos;, &apos;else&apos;, &apos;except&apos;, &apos;finally&apos;, &apos;for&apos;, &apos;from&apos;, &apos;global&apos;, &apos;if&apos;, &apos;import&apos;, &apos;in&apos;, &apos;is&apos;, &apos;lambda&apos;, &apos;nonlocal&apos;, &apos;not&apos;, &apos;or&apos;, &apos;pass&apos;, &apos;raise&apos;, &apos;return&apos;, &apos;try&apos;, &apos;while&apos;, &apos;with&apos;, &apos;yield&apos;]
</code></pre><hr>
<p>注释</p>
<p>Python中单行注释以 <strong>#</strong> 开头，实例如下：</p>
<pre><code>#!/usr/bin/python3

# 第一个注释
print (&quot;Hello, Python!&quot;) # 第二个注释
</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>Hello, Python!
</code></pre><p>多行注释可以用多个 # 号：</p>
<pre><code>#!/usr/bin/python3

# 第一个注释
# 第二个注释

print (&quot;Hello, Python!&quot;)
</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>Hello, Python!
</code></pre><hr>
<p>行与缩进</p>
<p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号({})。</p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：</p>
<pre><code>if True:
    print (&quot;True&quot;)
else:
    print (&quot;False&quot;)
</code></pre><p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p>
<pre><code>if True:
    print (&quot;Answer&quot;)
    print (&quot;True&quot;)
else:
    print (&quot;Answer&quot;)
  print (&quot;False&quot;)    # 缩进不一致，会导致运行错误
</code></pre><p>以上程序由于缩进不一致，执行后会出现类似以下错误：</p>
<pre><code> File &quot;test.py&quot;, line 6
    print (&quot;False&quot;)    # 缩进不一致，会导致运行错误
                                      ^
IndentationError: unindent does not match any outer indentation level
</code></pre><hr>
<p>多行语句</p>
<p>Python通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠(\)来实现多行语句，例如：</p>
<pre><code>total = item_one + \
        item_two + \
        item_three
</code></pre><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠(\)，例如：</p>
<pre><code>total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;,
        &apos;item_four&apos;, &apos;item_five&apos;]
</code></pre><hr>
<p>数据类型</p>
<p>python中数有四种类型：整数、长整数、浮点数和复数。</p>
<ul>
<li>整数， 如 1</li>
<li>长整数 是比较大的整数</li>
<li>浮点数 如 1.23、3E-2</li>
<li>复数 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<hr>
<p>字符串</p>
<ul>
<li>python中单引号和双引号使用完全相同。</li>
<li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li>
<li>转义符 ‘\‘</li>
<li>自然字符串， 通过在字符串前加r或R。 如 r”this is a line with \n”<br>则\n会显示，并不是换行。</li>
<li>python允许处理unicode字符串，加前缀u或U， 如 u”this is an unicode string”。</li>
<li>字符串是不可变的。</li>
<li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li>
</ul>
<!-- -->
<pre><code>word = &apos;字符串&apos;
sentence = &quot;这是一个句子。&quot;
paragraph = &quot;&quot;&quot;这是一个段落，
可以由多行组成&quot;&quot;&quot;
</code></pre><hr>
<p>空行</p>
<p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p><strong>记住：</strong>空行也是程序代码的一部分。</p>
<hr>
<p>等待用户输入</p>
<p>执行下面的程序在按回车键后就会等待用户输入：</p>
<pre><code>#!/usr/bin/python3

input(&quot;\n\n按下 enter 键后退出。&quot;)
</code></pre><p>以上代码中<br>，”\n\n”在结果输出前会输出两个新的空行。一旦用户按下键时，程序将退出。</p>
<hr>
<p>同一行显示多条语句</p>
<p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：</p>
<pre><code>#!/usr/bin/python3

import sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\n&apos;)
</code></pre><p>执行以上代码，输入结果为：</p>
<pre><code>$ python3 test.py
runoob
</code></pre><hr>
<p>多个语句构成代码组</p>
<p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( :<br>)结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<p>如下实例：</p>
<pre><code>if expression :
   suite
elif expression :
   suite
else :
   suite
</code></pre><hr>
<p>命令行参数</p>
<p>很多程序可以执行一些操作来查看一些基本信，Python可以使用-h参数查看各参数帮助信息：</p>
<pre><code>$ python -h
usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...
Options and arguments (and corresponding environment variables):
-c cmd : program passed in as string (terminates option list)
-d     : debug output from parser (also PYTHONDEBUG=x)
-E     : ignore environment variables (such as PYTHONPATH)
-h     : print this help message and exit

[ etc. ]
</code></pre><p>我们在使用脚本形式执行 Python<br>时，可以接收命令行输入的参数，具体使用可以参照 <a href="http://www.runoob.com/python3/python3-command-line-arguments.html" target="_blank" rel="external">Python 3<br>命令行参数</a>。</p>
<hr>
<h2 id="Python3-基本数据类型"><a href="#Python3-基本数据类型" class="headerlink" title="Python3 基本数据类型"></a>Python3 基本数据类型</h2><p>Python中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p>
<p>等号（=）用来给变量赋值。</p>
<p>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：</p>
<pre><code>#!/usr/bin/python3

counter = 100          # 整型变量
miles   = 1000.0       # 浮点型变量
name    = &quot;runoob&quot;     # 字符串

print (counter)
print (miles)
print (name)
</code></pre><p>执行以上程序会输出如下结果：</p>
<pre><code>100
1000.0
runoob
</code></pre><hr>
<p>多个变量赋值</p>
<p>Python允许你同时为多个变量赋值。例如：</p>
<pre><code>a = b = c = 1
</code></pre><p>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</p>
<p>您也可以为多个对象指定多个变量。例如：</p>
<pre><code>a, b, c = 1, 2, &quot;runoob&quot;
</code></pre><p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “runoob”<br>分配给变量 c。</p>
<hr>
<p>标准数据类型</p>
<p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Sets（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<hr>
<p>Number（数字）</p>
<p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的<br>Long。</p>
<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>
<p>内置的type()函数可以用来查询变量所指的对象类型。</p>
<pre><code>&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j
&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))
&lt;class &apos;int&apos;&gt; &lt;class &apos;float&apos;&gt; &lt;class &apos;bool&apos;&gt; &lt;class &apos;complex&apos;&gt;
</code></pre><blockquote>
<p><strong>注意：</strong>在Python2中是没有布尔型的，它用数字0表示False，用1表示True。到Python3中，把True和False定义成关键字了，但它们的值还是1和0，它们可以和数字相加。</p>
</blockquote>
<p>当你指定一个值时，Number 对象就会被创建：</p>
<pre><code>var1 = 1
var2 = 10
</code></pre><p>您也可以使用del语句删除一些对象引用。</p>
<p>del语句的语法是：</p>
<pre><code>del var1[,var2[,var3[....,varN]]]]
</code></pre><p>您可以通过使用del语句删除单个或多个对象。例如：</p>
<pre><code>del var
del var_a, var_b
</code></pre><hr>
<p>数值运算</p>
<pre><code>&gt;&gt;&gt; 5 + 4  # 加法
9
&gt;&gt;&gt; 4.3 - 2 # 减法
2.3
&gt;&gt;&gt; 3 * 7  # 乘法
21
&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数
0.5
&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数
0
&gt;&gt;&gt; 17 % 3 # 取余
2
&gt;&gt;&gt; 2 ** 5 # 乘方
32
</code></pre><p><strong>注意：</strong></p>
<ul>
<li>1、Python可以同时为多个变量赋值，如a, b = 1, 2。</li>
<li>2、一个变量可以通过赋值指向不同类型的对象。</li>
<li>3、数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。</li>
<li>4、在混合计算时，Python会把整型转换成为浮点数。</li>
</ul>
<hr>
<p>数值类型实例</p>
<table>
<thead>
<tr>
<th>int</th>
<th>float</th>
<th>complex</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>0.0</td>
<td>3.14j</td>
</tr>
<tr>
<td>100</td>
<td>15.20</td>
<td>45.j</td>
</tr>
<tr>
<td>-786</td>
<td>-21.9</td>
<td>9.322e-36j</td>
</tr>
<tr>
<td>080</td>
<td>32.3+e18</td>
<td>.876j</td>
</tr>
<tr>
<td>-0490</td>
<td>-90.</td>
<td>-.6545+0J</td>
</tr>
<tr>
<td>-0x260</td>
<td>-32.54e100</td>
<td>3e+26J</td>
</tr>
<tr>
<td>0x69</td>
<td>70.2-E12</td>
<td>4.53e-7j</td>
</tr>
</tbody>
</table>
<p>Python还支持复数，复数由实数部分和虚数部分构成，可以用a +<br>bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p>
<hr>
<p>String（字符串）</p>
<p>Python中的字符串用单引号(‘)或双引号(“)括起来，同时使用反斜杠(\)转义特殊字符。</p>
<p>字符串的截取的语法格式如下：</p>
<pre><code>变量[头下标:尾下标]
</code></pre><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p>加号 (+) 是字符串的连接符， 星号 (*)表示复制当前字符串，紧跟的数字为复制的次数。实例如下：</p>
<pre><code>#!/usr/bin/python3

str = &apos;Runoob&apos;

print (str)          # 输出字符串
print (str[0:-1])    # 输出第一个个到倒数第二个的所有字符
print (str[0])       # 输出字符串第一个字符
print (str[2:5])     # 输出从第三个开始到第五个的字符
print (str[2:])      # 输出从第三个开始的后的所有字符
print (str * 2)      # 输出字符串两次
print (str + &quot;TEST&quot;) # 连接字符串
</code></pre><p>执行以上程序会输出如下结果：</p>
<pre><code>Runoob
Runoo
R
noo
noob
RunoobRunoob
RunoobTEST
</code></pre><p>Python使用反斜杠(\)转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串：</p>
<pre><code>&gt;&gt;&gt; print(&apos;Ru\noob&apos;)
Ru
oob
&gt;&gt;&gt; print(r&apos;Ru\noob&apos;)
Ru\noob
&gt;&gt;&gt;
</code></pre><p>另外，反斜杠(\)可以作为续行符，表示下一行是上一行的延续。也可以使用<br><strong>“””…”””</strong> 或者 <strong>‘’’…’’’</strong> 跨越多行。</p>
<p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p>
<pre><code>&gt;&gt;&gt; word = &apos;Python&apos;
&gt;&gt;&gt; print(word[0], word[5])
P n
&gt;&gt;&gt; print(word[-1], word[-6])
n P
</code></pre><p>与 C 字符串不同的是，Python字符串不能被改变。向一个索引位置赋值，比如word[0] = ‘m’会导致错误。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li>
<li>2、字符串可以用+运算符连接在一起，用*运算符重复。</li>
<li>3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li>
<li>4、Python中的字符串不能改变。</li>
</ul>
<hr>
<p>List（列表）</p>
<p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在方括号([])之间、用逗号分隔开的元素列表。</p>
<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>列表截取的语法格式如下：</p>
<pre><code>变量[头下标:尾下标]
</code></pre><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p>加号（+）是列表连接运算符，星号（*）是重复操作。如下实例：</p>
<pre><code>#!/usr/bin/python3

list = [ &apos;abcd&apos;, 786 , 2.23, &apos;runoob&apos;, 70.2 ]
tinylist = [123, &apos;runoob&apos;]

print (list)            # 输出完整列表
print (list[0])         # 输出列表第一个元素
print (list[1:3])       # 从第二个开始输出到第三个元素
print (list[2:])        # 输出从第三个元素开始的所有元素
print (tinylist * 2)    # 输出两次列表
print (list + tinylist) # 连接列表
</code></pre><p>以上实例输出结果：</p>
<pre><code>[&apos;abcd&apos;, 786, 2.23, &apos;runoob&apos;, 70.2]
abcd
[786, 2.23]
[2.23, &apos;runoob&apos;, 70.2]
[123, &apos;runoob&apos;, 123, &apos;runoob&apos;]
[&apos;abcd&apos;, 786, 2.23, &apos;runoob&apos;, 70.2, 123, &apos;runoob&apos;]
</code></pre><p>与Python字符串不一样的是，列表中的元素是可以改变的：</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]
&gt;&gt;&gt; a[0] = 9
&gt;&gt;&gt; a[2:5] = [13, 14, 15]
&gt;&gt;&gt; a
[9, 2, 13, 14, 15, 6]
&gt;&gt;&gt; a[2:5] = []   # 删除
&gt;&gt;&gt; a
[9, 2, 6]
</code></pre><p>List内置了有很多方法，例如append()、pop()等等，这在后面会讲到。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、List写在方括号之间，元素用逗号隔开。</li>
<li>2、和字符串一样，list可以被索引和切片。</li>
<li>3、List可以使用+操作符进行拼接。</li>
<li>4、List中的元素是可以改变的。</li>
</ul>
<hr>
<p>Tuple（元组）</p>
<p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号(<strong>()</strong>)里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<pre><code>#!/usr/bin/python3

tuple = ( &apos;abcd&apos;, 786 , 2.23, &apos;runoob&apos;, 70.2  )
tinytuple = (123, &apos;runoob&apos;)

print (tuple)             # 输出完整元组
print (tuple[0])          # 输出元组的第一个元素
print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
print (tuple[2:])         # 输出从第三个元素开始的所有元素
print (tinytuple * 2)     # 输出两次元组
print (tuple + tinytuple) # 连接元组
</code></pre><p>以上实例输出结果：</p>
<pre><code>(&apos;abcd&apos;, 786, 2.23, &apos;runoob&apos;, 70.2)
abcd
(786, 2.23)
(2.23, &apos;runoob&apos;, 70.2)
(123, &apos;runoob&apos;, 123, &apos;runoob&apos;)
(&apos;abcd&apos;, 786, 2.23, &apos;runoob&apos;, 70.2, 123, &apos;runoob&apos;)
</code></pre><p>元组与字符串类似，可以被索引且下标索引从0开始，-1为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p>
<p>其实，可以把字符串看作一种特殊的元组。</p>
<pre><code>&gt;&gt;&gt; tup = (1, 2, 3, 4, 5, 6)
&gt;&gt;&gt; print(tup[0])
1
&gt;&gt;&gt; print(tup[1:5])
(2, 3, 4, 5)
&gt;&gt;&gt; tup[0] = 11  # 修改元组元素的操作是非法的
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &apos;tuple&apos; object does not support item assignment
&gt;&gt;&gt;
</code></pre><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<pre><code>tup1 = ()    # 空元组
tup2 = (20,) # 一个元素，需要在元素后添加逗号
</code></pre><p>string、list和tuple都属于sequence（序列）。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、与字符串一样，元组的元素不能修改。</li>
<li>2、元组也可以被索引和切片，方法一样。</li>
<li>3、注意构造包含0或1个元素的元组的特殊语法规则。</li>
<li>4、元组也可以使用+操作符进行拼接。</li>
</ul>
<hr>
<p>Set（集合）</p>
<p>集合（set）是一个无序不重复元素的序列。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号({})或者 set()函数创建集合，注意：创建一个空集合必须用<br>set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<pre><code>#!/usr/bin/python3

student = ({&apos;Tom&apos;, &apos;Jim&apos;, &apos;Mary&apos;, &apos;Tom&apos;, &apos;Jack&apos;, &apos;Rose&apos;})

print(student)   # 输出集合，重复的元素被自动去掉

# 成员测试
if(&apos;Rose&apos; in student) :
    print(&apos;Rose 在集合中&apos;)
else :
    print(&apos;Rose 不在集合中&apos;)


# set可以进行集合运算
a = set(&apos;abracadabra&apos;)
b = set(&apos;alacazam&apos;)

print(a)

print(a - b)     # a和b的差集

print(a | b)     # a和b的并集

print(a &amp; b)     # a和b的交集

print(a ^ b)     # a和b中不同时存在的元素
</code></pre><p>以上实例输出结果：</p>
<pre><code>{&apos;Mary&apos;, &apos;Jim&apos;, &apos;Rose&apos;, &apos;Jack&apos;, &apos;Tom&apos;}
Rose 在集合中
{&apos;b&apos;, &apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;}
{&apos;b&apos;, &apos;d&apos;, &apos;r&apos;}
{&apos;l&apos;, &apos;r&apos;, &apos;a&apos;, &apos;c&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;}
{&apos;a&apos;, &apos;c&apos;}
{&apos;l&apos;, &apos;r&apos;, &apos;z&apos;, &apos;m&apos;, &apos;b&apos;, &apos;d&apos;}
</code></pre><hr>
<p>Dictionary（字典）</p>
<p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用”{ }”标识，它是一个无序的<strong>键(key) :<br>值(value)</strong>对集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<pre><code>#!/usr/bin/python3

dict = {}
dict[&apos;one&apos;] = &quot;1 - 菜鸟教程&quot;
dict[2]     = &quot;2 - 菜鸟工具&quot;

tinydict = {&apos;name&apos;: &apos;runoob&apos;,&apos;code&apos;:1, &apos;site&apos;: &apos;www.runoob.com&apos;}


print (dict[&apos;one&apos;])       # 输出键为 &apos;one&apos; 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - 菜鸟教程
2 - 菜鸟工具
{&apos;name&apos;: &apos;runoob&apos;, &apos;site&apos;: &apos;www.runoob.com&apos;, &apos;code&apos;: 1}
dict_keys([&apos;name&apos;, &apos;site&apos;, &apos;code&apos;])
dict_values([&apos;runoob&apos;, &apos;www.runoob.com&apos;, 1])
</code></pre><p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p>
<pre><code>&gt;&gt;&gt; dict([(&apos;Runoob&apos;, 1), (&apos;Google&apos;, 2), (&apos;Taobao&apos;, 3)])
{&apos;Taobao&apos;: 3, &apos;Runoob&apos;: 1, &apos;Google&apos;: 2}

&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}

&gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3)
{&apos;Taobao&apos;: 3, &apos;Runoob&apos;: 1, &apos;Google&apos;: 2}
</code></pre><p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、字典是一种映射类型，它的元素是键值对。</li>
<li>2、字典的关键字必须为不可变类型，且不能重复。</li>
<li>3、创建空字典使用 <strong>{ }</strong>。</li>
</ul>
<hr>
<p>数据类型转换</p>
<p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int(x [,base])</td>
<td style="text-align:left">将x转换为一个整数</td>
</tr>
<tr>
<td style="text-align:left">float(x)</td>
<td style="text-align:left">将x转换到一个浮点数</td>
</tr>
<tr>
<td style="text-align:left">complex(real [,imag])</td>
<td style="text-align:left">创建一个复数</td>
</tr>
<tr>
<td style="text-align:left">str(x)</td>
<td style="text-align:left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td style="text-align:left">repr(x)</td>
<td style="text-align:left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td style="text-align:left">eval(str)</td>
<td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td style="text-align:left">tuple(s)</td>
<td style="text-align:left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td style="text-align:left">list(s)</td>
<td style="text-align:left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td style="text-align:left">set(s)</td>
<td style="text-align:left">转换为可变集合</td>
</tr>
<tr>
<td style="text-align:left">dict(d)</td>
<td style="text-align:left">创建一个字典。d 必须是一个序列   (key,value)元组。</td>
</tr>
<tr>
<td style="text-align:left">frozenset(s)</td>
<td style="text-align:left">转换为不可变集合</td>
</tr>
<tr>
<td style="text-align:left">chr(x)</td>
<td style="text-align:left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td style="text-align:left">unichr(x)</td>
<td style="text-align:left">将一个整数转换为Unicode字符</td>
</tr>
<tr>
<td style="text-align:left">ord(x)</td>
<td style="text-align:left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td style="text-align:left">hex(x)</td>
<td style="text-align:left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td style="text-align:left">oct(x)</td>
<td style="text-align:left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Python3-解释器"><a href="#Python3-解释器" class="headerlink" title="Python3 解释器"></a>Python3 解释器</h2><p>Linux/Unix的系统上，一般默认的 python 版本为 2.x，我们可以将 python3.x<br>安装在 <strong>/usr/local/python3</strong> 目录中。</p>
<p>安装完成后，我们可以将路径 <strong>/usr/local/python3/bin</strong> 添加到您的<br>Linux/Unix 操作系统的环境变量中，这样您就可以通过 shell<br>终端输入下面的命令来启动 Python3 。</p>
<pre><code>$ PATH=$PATH:/usr/local/python3/bin/python3    # 设置环境变量
$ python3 --version
Python 3.4.0
</code></pre><p>在Window系统下你可以通过以下命令来设置Python的环境变量，假设你的Python安装在<br>C:\Python34 下:</p>
<pre><code>set path=%path%;C:\python34
</code></pre><hr>
<p>交互式编程</p>
<p>我们可以在命令提示符中输入”Python”命令来启动Python解释器：</p>
<pre><code>$ python3
</code></pre><p>执行以上命令后，出现如下窗口信息：</p>
<pre><code>$ python3
Python 3.4.0 (default, Apr 11 2014, 13:05:11)
[GCC 4.8.2] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre><p>在 python 提示符中输入以下语句，然后按回车键查看运行效果：</p>
<pre><code>print (&quot;Hello, Python!&quot;);
</code></pre><p>以上命令执行结果如下：</p>
<pre><code>Hello, Python!
</code></pre><p>当键入一个多行结构时，续行是必须的。我们可以看下如下 if 语句：</p>
<pre><code>&gt;&gt;&gt; flag = True
&gt;&gt;&gt; if flag :
...     print(&quot;flag 条件为 True!&quot;)
...
flag 条件为 True!
</code></pre><hr>
<p>脚本式编程</p>
<p>将如下代码拷贝至 <strong>hello.py</strong>文件中：</p>
<pre><code>print (&quot;Hello, Python!&quot;);
</code></pre><p>通过以下命令执行该脚本：</p>
<pre><code>python3 hello.py
</code></pre><p>输出结果为：</p>
<pre><code>Hello, Python!
</code></pre><p>在Linux/Unix系统中，你可以在脚本顶部添加以下命令让Python脚本可以像SHELL脚本一样可直接执行：</p>
<pre><code>#! /usr/bin/env python3
</code></pre><p>然后修改脚本权限，使其有执行权限，命令如下：</p>
<pre><code>$ chmod +x hello.py
</code></pre><p>执行以下命令：</p>
<pre><code>./hello.py
</code></pre><p>输出结果为：</p>
<pre><code>Hello, Python!
</code></pre><hr>
<h2 id="Python3-注释"><a href="#Python3-注释" class="headerlink" title="Python3 注释"></a>Python3 注释</h2><p>确保对模块, 函数, 方法和行内注释使用正确的风格</p>
<p>Python中的注释有单行注释和多行注释：</p>
<p>Python中单行注释以#开头，例如：：</p>
<pre><code># 这是一个注释
print(&quot;Hello, World!&quot;)
</code></pre><p>多行注释用三个单引号（’’’）或者三个双引号（”””）将注释括起来，例如:</p>
<p>1、单引号（’’’）</p>
<pre><code>#!/usr/bin/python3
&apos;&apos;&apos;
这是多行注释，用三个单引号
这是多行注释，用三个单引号
这是多行注释，用三个单引号
&apos;&apos;&apos;
print(&quot;Hello, World!&quot;)
</code></pre><p>2、双引号（’’’）</p>
<pre><code>#!/usr/bin/python3
&quot;&quot;&quot;
这是多行注释，用三个单引号
这是多行注释，用三个单引号
这是多行注释，用三个单引号
&quot;&quot;&quot;
print(&quot;Hello, World!&quot;)
</code></pre><hr>
<h2 id="Python3-运算符"><a href="#Python3-运算符" class="headerlink" title="Python3 运算符"></a>Python3 运算符</h2><p>什么是运算符？</p>
<p>本章节主要说明Python的运算符。举个简单的例子 <strong>4 +5 = 9</strong> 。<br>例子中，<strong>4</strong> 和 <strong>5</strong> 被称为<strong>操作数</strong>，”<strong>+</strong>“ 称为运算符。</p>
<p>Python语言支持以下类型的运算符:</p>
<ul>
<li><a href="#ysf1">算术运算符</a></li>
<li><a href="#ysf2">比较（关系）运算符</a></li>
<li><a href="#ysf3">赋值运算符</a></li>
<li><a href="#ysf4">逻辑运算符</a></li>
<li><a href="#ysf5">位运算符</a></li>
<li><a href="#ysf6">成员运算符</a></li>
<li><a href="#ysf7">身份运算符</a></li>
<li><a href="#ysf8">运算符优先级</a></li>
</ul>
<p>接下来让我们一个个来学习Python的运算符。</p>
<hr>
<p>算术运算符</p>
<p>以下假设变量a为10，变量b为21：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td style="text-align:left">加 - 两个对象相加</td>
<td style="text-align:left">a + b 输出结果 31</td>
</tr>
<tr>
<td>-</td>
<td style="text-align:left">减 - 得到负数或是一个数减去另一个数</td>
<td style="text-align:left">a - b 输出结果 -11</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td style="text-align:left">a * b 输出结果 210</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:left">除 - x 除以 y</td>
<td style="text-align:left">b / a 输出结果 2.1</td>
</tr>
<tr>
<td>%</td>
<td style="text-align:left">取模 - 返回除法的余数</td>
<td style="text-align:left">b % a 输出结果 1</td>
</tr>
<tr>
<td>**</td>
<td style="text-align:left">幂 - 返回x的y次幂</td>
<td style="text-align:left">a**b 为10的21次方</td>
</tr>
<tr>
<td>//</td>
<td style="text-align:left">取整除 - 返回商的整数部分</td>
<td style="text-align:left">9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有算术运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 21
b = 10
c = 0

c = a + b
print (&quot;1 - c 的值为：&quot;, c)

c = a - b
print (&quot;2 - c 的值为：&quot;, c)

c = a * b
print (&quot;3 - c 的值为：&quot;, c)

c = a / b
print (&quot;4 - c 的值为：&quot;, c)

c = a % b
print (&quot;5 - c 的值为：&quot;, c)

# 修改变量 a 、b 、c
a = 2
b = 3
c = a**b
print (&quot;6 - c 的值为：&quot;, c)

a = 10
b = 5
c = a//b
print (&quot;7 - c 的值为：&quot;, c)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - c 的值为： 31
2 - c 的值为： 11
3 - c 的值为： 210
4 - c 的值为： 2.1
5 - c 的值为： 1
6 - c 的值为： 8
7 - c 的值为： 2
</code></pre><hr>
<p>比较运算符</p>
<p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">等于 - 比较对象是否相等</td>
<td style="text-align:left">(a == b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不等于 - 比较两个对象是否不相等</td>
<td style="text-align:left">(a != b) 返回 true.</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于 - 返回x是否大于y</td>
<td style="text-align:left">(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td>
<td style="text-align:left">(a &lt; b) 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于 - 返回x是否大于等于y。</td>
<td style="text-align:left">(a &gt;= b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于 - 返回x是否小于等于y。</td>
<td style="text-align:left">(a &lt;= b) 返回 true。</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有比较运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 21
b = 10
c = 0

if ( a == b ):
   print (&quot;1 - a 等于 b&quot;)
else:
   print (&quot;1 - a 不等于 b&quot;)

if ( a != b ):
   print (&quot;2 - a 不等于 b&quot;)
else:
   print (&quot;2 - a 等于 b&quot;)

if ( a &lt; b ):
   print (&quot;3 - a 小于 b&quot;)
else:
   print (&quot;3 - a 大于等于 b&quot;)

if ( a &gt; b ):
   print (&quot;4 - a 大于 b&quot;)
else:
   print (&quot;4 - a 小于等于 b&quot;)

# 修改变量 a 和 b 的值
a = 5;
b = 20;
if ( a &lt;= b ):
   print (&quot;5 - a 小于等于 b&quot;)
else:
   print (&quot;5 - a 大于  b&quot;)

if ( b &gt;= a ):
   print (&quot;6 - b 大于等于 a&quot;)
else:
   print (&quot;6 - b 小于 a&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - a 不等于 b
2 - a 不等于 b
3 - a 大于等于 b
4 - a 大于 b
5 - a 小于等于 b
6 - b 大于等于 a
</code></pre><hr>
<p>赋值运算符</p>
<p>以下假设变量a为10，变量b为20：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">简单的赋值运算符</td>
<td style="text-align:left">c = a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
</tbody>
</table>
<p>  +=       加法赋值运算符     c += a 等效于 c = c + a<br>  -=       减法赋值运算符     c -= a 等效于 c = c - a<br>  *=      乘法赋值运算符     c *= a 等效于 c = c * a<br>  /=       除法赋值运算符     c /= a 等效于 c = c / a<br>  %=       取模赋值运算符     c %= a 等效于 c = c % a<br>  **=    幂赋值运算符       c **= a 等效于 c = c ** a<br>  //=      取整除赋值运算符   c //= a 等效于 c = c // a</p>
<p>以下实例演示了Python所有赋值运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 21
b = 10
c = 0

c = a + b
print (&quot;1 - c 的值为：&quot;, c)

c += a
print (&quot;2 - c 的值为：&quot;, c)

c *= a
print (&quot;3 - c 的值为：&quot;, c)

c /= a
print (&quot;4 - c 的值为：&quot;, c)

c = 2
c %= a
print (&quot;5 - c 的值为：&quot;, c)

c **= a
print (&quot;6 - c 的值为：&quot;, c)

c //= a
print (&quot;7 - c 的值为：&quot;, c)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - c 的值为： 31
2 - c 的值为： 52
3 - c 的值为： 1092
4 - c 的值为： 52.0
5 - c 的值为： 2
6 - c 的值为： 2097152
7 - c 的值为： 99864
</code></pre><hr>
<p>位运算符</p>
<p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p>
<p>下表中变量 a 为 60，b 为 13二进制格式如下：</p>
<pre><code>a = 0011 1100

b = 0000 1101

-----------------

a&amp;b = 0000 1100

a|b = 0011 1101

a^b = 0011 0001

~a  = 1100 0011
</code></pre><table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
<td style="text-align:left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td>(a \</td>
<td>b) 输出结果 61 ，二进制解释： 0011 1101</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">按位异或运算符：当两对应的二进位相异时，结果为1</td>
<td style="text-align:left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1</td>
<td style="text-align:left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">左移动运算符：运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td style="text-align:left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td>
<td style="text-align:left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有位运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 60            # 60 = 0011 1100
b = 13            # 13 = 0000 1101
c = 0

c = a &amp; b;        # 12 = 0000 1100
print (&quot;1 - c 的值为：&quot;, c)

c = a | b;        # 61 = 0011 1101
print (&quot;2 - c 的值为：&quot;, c)

c = a ^ b;        # 49 = 0011 0001
print (&quot;3 - c 的值为：&quot;, c)

c = ~a;           # -61 = 1100 0011
print (&quot;4 - c 的值为：&quot;, c)

c = a &lt;&lt; 2;       # 240 = 1111 0000
print (&quot;5 - c 的值为：&quot;, c)

c = a &gt;&gt; 2;       # 15 = 0000 1111
print (&quot;6 - c 的值为：&quot;, c)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - c 的值为： 12
2 - c 的值为： 61
3 - c 的值为： 49
4 - c 的值为： -61
5 - c 的值为： 240
6 - c 的值为： 15
</code></pre><hr>
<p>逻辑运算符</p>
<p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">逻辑表达式</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">and</td>
<td style="text-align:left">x and y</td>
<td style="text-align:left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td>
<td style="text-align:left">(a and b) 返回 20。</td>
</tr>
<tr>
<td style="text-align:left">or</td>
<td style="text-align:left">x or y</td>
<td style="text-align:left">布尔”或” - 如果 x 是 True，它返回 True，否则它返回 y 的计算值。</td>
<td style="text-align:left">(a or b) 返回 10。</td>
</tr>
<tr>
<td style="text-align:left">not</td>
<td style="text-align:left">not x</td>
<td style="text-align:left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td style="text-align:left">not(a and b) 返回 False</td>
</tr>
</tbody>
</table>
<p>以上实例输出结果：</p>
<pre><code>#!/usr/bin/python3

a = 10
b = 20

if ( a and b ):
   print (&quot;1 - 变量 a 和 b 都为 true&quot;)
else:
   print (&quot;1 - 变量 a 和 b 有一个不为 true&quot;)

if ( a or b ):
   print (&quot;2 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)
else:
   print (&quot;2 - 变量 a 和 b 都不为 true&quot;)

# 修改变量 a 的值
a = 0
if ( a and b ):
   print (&quot;3 - 变量 a 和 b 都为 true&quot;)
else:
   print (&quot;3 - 变量 a 和 b 有一个不为 true&quot;)

if ( a or b ):
   print (&quot;4 - 变量 a 和 b 都为 true，或其中一个变量为 true&quot;)
else:
   print (&quot;4 - 变量 a 和 b 都不为 true&quot;)

if not( a and b ):
   print (&quot;5 - 变量 a 和 b 都为 false，或其中一个变量为 false&quot;)
else:
   print (&quot;5 - 变量 a 和 b 都为 true&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - 变量 a 和 b 都为 true
2 - 变量 a 和 b 都为 true，或其中一个变量为 true
3 - 变量 a 和 b 有一个不为 true
4 - 变量 a 和 b 都为 true，或其中一个变量为 true
5 - 变量 a 和 b 都为 false，或其中一个变量为 false
</code></pre><hr>
<p>成员运算符</p>
<p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">in</td>
<td style="text-align:left">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td style="text-align:left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td style="text-align:left">not in</td>
<td style="text-align:left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td style="text-align:left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有成员运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 10
b = 20
list = [1, 2, 3, 4, 5 ];

if ( a in list ):
   print (&quot;1 - 变量 a 在给定的列表中 list 中&quot;)
else:
   print (&quot;1 - 变量 a 不在给定的列表中 list 中&quot;)

if ( b not in list ):
   print (&quot;2 - 变量 b 不在给定的列表中 list 中&quot;)
else:
   print (&quot;2 - 变量 b 在给定的列表中 list 中&quot;)

# 修改变量 a 的值
a = 2
if ( a in list ):
   print (&quot;3 - 变量 a 在给定的列表中 list 中&quot;)
else:
   print (&quot;3 - 变量 a 不在给定的列表中 list 中&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - 变量 a 不在给定的列表中 list 中
2 - 变量 b 不在给定的列表中 list 中
3 - 变量 a 在给定的列表中 list 中
</code></pre><hr>
<p>身份运算符</p>
<p>身份运算符用于比较两个对象的存储单元</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">is</td>
<td style="text-align:left">is是判断两个标识符是不是引用自一个对象</td>
<td style="text-align:left">x is y, 如果 id(x) 等于 id(y) , <strong>is</strong> 返回结果 1</td>
</tr>
<tr>
<td style="text-align:left">is not</td>
<td style="text-align:left">is not是判断两个标识符是不是引用自不同对象</td>
<td style="text-align:left">x is not y, 如果 id(x) 不等于 id(y). <strong>is not</strong> 返回结果 1</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有身份运算符的操作：</p>
<pre><code>#!/usr/bin/python3

a = 20
b = 20

if ( a is b ):
   print (&quot;1 - a 和 b 有相同的标识&quot;)
else:
   print (&quot;1 - a 和 b 没有相同的标识&quot;)

if ( id(a) == id(b) ):
   print (&quot;2 - a 和 b 有相同的标识&quot;)
else:
   print (&quot;2 - a 和 b 没有相同的标识&quot;)

# 修改变量 b 的值
b = 30
if ( a is b ):
   print (&quot;3 - a 和 b 有相同的标识&quot;)
else:
   print (&quot;3 - a 和 b 没有相同的标识&quot;)

if ( a is not b ):
   print (&quot;4 - a 和 b 没有相同的标识&quot;)
else:
   print (&quot;4 - a 和 b 有相同的标识&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>1 - a 和 b 有相同的标识
2 - a 和 b 有相同的标识
3 - a 和 b 没有相同的标识
4 - a 和 b 没有相同的标识
</code></pre><hr>
<p>运算符优先级</p>
<p>以下表格列出了从最高到最低优先级的所有运算符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">**</td>
<td style="text-align:center">指数 (最高优先级)</td>
</tr>
<tr>
<td style="text-align:center">~ + -</td>
<td style="text-align:center">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td style="text-align:center">* / % //</td>
<td style="text-align:center">乘，除，取模和取整除</td>
</tr>
<tr>
<td style="text-align:center">+ -</td>
<td style="text-align:center">加法减法</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt; &lt;&lt;</td>
<td style="text-align:center">右移，左移运算符</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">位 ‘AND’</td>
</tr>
<tr>
<td style="text-align:center">^ \</td>
<td style="text-align:center"></td>
<td>位运算符</td>
</tr>
<tr>
<td style="text-align:center">&lt;= &lt; &gt; &gt;=</td>
<td style="text-align:center">比较运算符</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt; == !=</td>
<td style="text-align:center">等于运算符</td>
</tr>
<tr>
<td style="text-align:center">= %= /= //= -= += *= **=</td>
<td style="text-align:center">赋值运算符</td>
</tr>
<tr>
<td style="text-align:center">is is not</td>
<td style="text-align:center">身份运算符</td>
</tr>
<tr>
<td style="text-align:center">in not in</td>
<td style="text-align:center">成员运算符</td>
</tr>
<tr>
<td style="text-align:center">not or and</td>
<td style="text-align:center">逻辑运算符</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有运算符优先级的操作：</p>
<pre><code>#!/usr/bin/python3

a = 20
b = 10
c = 15
d = 5
e = 0

e = (a + b) * c / d       #( 30 * 15 ) / 5
print (&quot;(a + b) * c / d 运算结果为：&quot;,  e)

e = ((a + b) * c) / d     # (30 * 15 ) / 5
print (&quot;((a + b) * c) / d 运算结果为：&quot;,  e)

e = (a + b) * (c / d);    # (30) * (15/5)
print (&quot;(a + b) * (c / d) 运算结果为：&quot;,  e)

e = a + (b * c) / d;      #  20 + (150/5)
print (&quot;a + (b * c) / d 运算结果为：&quot;,  e)
</code></pre><p>以上实例输出结果：</p>
<pre><code>(a + b) * c / d 运算结果为： 90.0
((a + b) * c) / d 运算结果为： 90.0
(a + b) * (c / d) 运算结果为： 90.0
a + (b * c) / d 运算结果为： 50.0
</code></pre><hr>
<h2 id="Python3-数字-Number"><a href="#Python3-数字-Number" class="headerlink" title="Python3 数字(Number)"></a>Python3 数字(Number)</h2><p>Python 数字数据类型用于存储数值。</p>
<p>数据类型是不允许改变的, 这就意味着如果改变数字数据类型得值，将重新分配内存空间。</p>
<p>以下实例在变量赋值时 Number 对象将被创建：</p>
<pre><code>var1 = 1
var2 = 10
</code></pre><p>您也可以使用del语句删除一些数字对象的引用。</p>
<p>del语句的语法是：</p>
<pre><code>del var1[,var2[,var3[....,varN]]]]
</code></pre><p>您可以通过使用del语句删除单个或多个对象的引用，例如：</p>
<pre><code>del var
del var_a, var_b
</code></pre><p>Python 支持三种不同的数值类型：</p>
<ul>
<li><strong>整型(Int)</strong> -<br>通常被称为是整型或整数，是正或负整数，不带小数点。Python3<br>整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有<br>Python2 的 Long 类型。</li>
<li><strong>浮点型(float)</strong> -<br>浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2<br>= 2.5 x 10^2^ = 250）</li>
<li><strong>复数( (complex))</strong> - 复数由实数部分和虚数部分构成，可以用a +<br>bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<p>我们可以使用十六进制和八进制来代表整数：</p>
<pre><code>&gt;&gt;&gt; number = 0xA0F # 十六进制
&gt;&gt;&gt; number
2575

&gt;&gt;&gt; number=0o37 # 八进制
&gt;&gt;&gt; number
31
</code></pre><table>
<thead>
<tr>
<th>int</th>
<th style="text-align:center">float</th>
<th style="text-align:center">complex</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">3.14j</td>
</tr>
<tr>
<td>100</td>
<td style="text-align:center">15.20</td>
<td style="text-align:center">45.j</td>
</tr>
<tr>
<td>-786</td>
<td style="text-align:center">-21.9</td>
<td style="text-align:center">9.322e-36j</td>
</tr>
<tr>
<td>080</td>
<td style="text-align:center">32.3+e18</td>
<td style="text-align:center">.876j</td>
</tr>
<tr>
<td>-0490</td>
<td style="text-align:center">-90.</td>
<td style="text-align:center">-.6545+0J</td>
</tr>
<tr>
<td>-0x260</td>
<td style="text-align:center">-32.54e100</td>
<td style="text-align:center">3e+26J</td>
</tr>
<tr>
<td>0x69</td>
<td style="text-align:center">70.2-E12</td>
<td style="text-align:center">4.53e-7j</td>
</tr>
</tbody>
</table>
<ul>
<li>Python支持复数，复数由实数部分和虚数部分构成，可以用a +<br>bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<hr>
<p>Python 数字类型转换</p>
<p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<ul>
<li><p><strong>int(x)</strong> 将x转换为一个整数。</p>
</li>
<li><p><strong>float(x)</strong> 将x转换到一个浮点数。</p>
</li>
<li><p><strong>complex(x)</strong> 将x转换到一个复数，实数部分为 x，虚数部分为 0。</p>
</li>
<li><p><strong>complex(x, y)</strong> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为<br>y。x 和 y 是数字表达式。</p>
</li>
</ul>
<p>以下实例将浮点数变量 a 转换为整数：</p>
<pre><code>&gt;&gt;&gt; a = 1.0
&gt;&gt;&gt; int(a)
1
</code></pre><hr>
<p>Python 数字运算</p>
<p>Python<br>解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。</p>
<p>表达式的语法很直白： +, -, * 和 /<br>和其它语言（如Pascal或C）里一样。例如：</p>
<pre><code>&gt;&gt;&gt; 2 + 2
4
&gt;&gt;&gt; 50 - 5*6
20
&gt;&gt;&gt; (50 - 5*6) / 4
5.0
&gt;&gt;&gt; 8 / 5  # 总是返回一个浮点数
1.6
</code></pre><p><strong>注意：</strong>在不同的机器上浮点运算的结果可能会不一样。</p>
<p>在整数除法中，除法（/）总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符<strong>//</strong> ：</p>
<pre><code>&gt;&gt;&gt; 17 / 3  # 整数除法返回浮点型
5.666666666666667
&gt;&gt;&gt;
&gt;&gt;&gt; 17 // 3  # 整数除法返回向下取整后的结果
5
&gt;&gt;&gt; 17 % 3  # ％操作符返回除法的余数
2
&gt;&gt;&gt; 5 * 3 + 2
17
</code></pre><p>等号（=）用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。</p>
<pre><code>&gt;&gt;&gt; width = 20
&gt;&gt;&gt; height = 5*9
&gt;&gt;&gt; width * height
900
</code></pre><p>Python 可以使用 <strong>**</strong> 操作来进行幂运算：</p>
<pre><code>&gt;&gt;&gt; 5 ** 2  # 5 的平方
25
&gt;&gt;&gt; 2 ** 7  # 2的7次方
128
</code></pre><p>变量在使用前必须先”定义”（即赋予变量一个值），否则会出现错误：</p>
<pre><code>&gt;&gt;&gt; n   # 尝试访问一个未定义的变量
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &apos;n&apos; is not defined
</code></pre><p>不同类型的数混合运算时会将整数转换为浮点数：</p>
<pre><code>&gt;&gt;&gt; 3 * 3.75 / 1.5
7.5
&gt;&gt;&gt; 7.0 / 2
3.5
</code></pre><p>在交互模式中，最后被输出的表达式结果被赋值给变量 <strong>_</strong> 。例如：</p>
<pre><code>&gt;&gt;&gt; tax = 12.5 / 100
&gt;&gt;&gt; price = 100.50
&gt;&gt;&gt; price * tax
12.5625
&gt;&gt;&gt; price + _
113.0625
&gt;&gt;&gt; round(_, 2)
113.06
</code></pre><p>此处， <strong>_</strong> 变量应被用户视为只读变量。</p>
<hr>
<p>数学函数</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">abs(x)</td>
<td style="text-align:left">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td style="text-align:left">ceil(x)</td>
<td style="text-align:left">返回数字的上入整数，如math.ceil(4.1)返回 5</td>
</tr>
<tr>
<td style="text-align:left">cmp(x, y)</td>
<td style="text-align:left">如果 x &lt; y 返回 -1, 如果 x ==y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃</strong> 。使用 <strong>使用(x&gt;y)-(x&lt;y)</strong> 替换。</td>
</tr>
<tr>
<td style="text-align:left">exp(x)</td>
<td style="text-align:left">返回e的x次幂(e^x^),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td style="text-align:left">fabs(x)</td>
<td style="text-align:left">返回数字的绝对值，如math.fabs(-10)  返回10.0</td>
</tr>
<tr>
<td style="text-align:left">floor(x)</td>
<td style="text-align:left">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td style="text-align:left">log(x)</td>
<td style="text-align:left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td style="text-align:left">log10(x)</td>
<td style="text-align:left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
</tbody>
</table>
<p>+———————————–+———————————–+<br>| <a href="/python3/python3-func-nu |                                   |
| mber-max.html">max(x1,                          | 返回给定参数的最大值，参数可以为序列。 |<br>| x2,…)</a>                    |                                   |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-nu |                                   |
| mber-min.html">min(x1,                          | 返回给定参数的最小值，参数可以为序列。 |<br>| x2,…)</a>                    |                                   |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-n | 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮 |
| umber-modf.html">modf(x)</a>                  | 点型表示。                        |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-number- |                                   |
| pow.html">pow(x,                           | x**y 运算后的值。               |<br>| y)</a>                         |                                   |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-nu |                                   |
| mber-round.html">round(x                          | 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 |<br>| [,n])</a>                  |                                   |<br>+———————————–+———————————–+<br>| <a href="/python3/python3-func-n | 返回数字x的平方根，数字可以为负数，返回类型为实数，如math.s |
| umber-sqrt.html">sqrt(x)</a>                  | qrt(4)返回                        |<br>|                                   | 2+0j                              |<br>+———————————–+———————————–+</p>
<hr>
<p>随机数函数</p>
<p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p>
<p>Python包含以下常用随机数函数：<br>| 函数     |        描述|<br>|:—|:—|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-choice.html" target="_blank" rel="external">choice(seq)</a>                                |从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-randrange.html" target="_blank" rel="external">randrange ([start,] stop [,step])</a>  | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-random.html" target="_blank" rel="external">random()</a>                            |       随机生成下一个实数，它在[0,1)范围内。|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-seed.html" target="_blank" rel="external">seed([x])</a>    |                              改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。|<br>|  <a href="http://www.runoob.com/python3/python3-func-number-shuffle.html" target="_blank" rel="external">shuffle(lst)</a>        |                      将序列的所有元素随机排序|<br> | <a href="http://www.runoob.com/python3/python3-func-number-uniform.html" target="_blank" rel="external">uniform(x, y)</a>                        |     随机生成下一个实数，它在[x,y]范围内。|</p>
<hr>
<p>三角函数</p>
<p>Python包括以下三角函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-acos.html" target="_blank" rel="external">acos(x)</a></td>
<td style="text-align:left">返回x的反余弦弧度值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-asin.html" target="_blank" rel="external">asin(x)</a></td>
<td style="text-align:left">返回x的反正弦弧度值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-atan.html" target="_blank" rel="external">atan(x)</a></td>
<td style="text-align:left">返回x的反正切弧度值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-atan2.html" target="_blank" rel="external">atan2(y, x)</a></td>
<td style="text-align:left">返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-cos.html" target="_blank" rel="external">cos(x)</a></td>
<td style="text-align:left">返回x的弧度的余弦值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-hypot.html" target="_blank" rel="external">hypot(x, y)</a></td>
<td style="text-align:left">返回欧几里德范数 sqrt(x*x + y*y)。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-sin.html" target="_blank" rel="external">sin(x)</a></td>
<td style="text-align:left">返回的x弧度的正弦值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-tan.html" target="_blank" rel="external">tan(x)</a></td>
<td style="text-align:left">返回x弧度的正切值。</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-degrees.html" target="_blank" rel="external">degrees(x)</a></td>
<td style="text-align:left">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.runoob.com/python3/python3-func-number-radians.html" target="_blank" rel="external">radians(x)</a></td>
<td style="text-align:left">将角度转换为弧度</td>
</tr>
</tbody>
</table>
<hr>
<p>数学常量</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pi</td>
<td>数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td>e</td>
<td>数学常量 e，e即自然常数（自然常数）。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Python3-字符串"><a href="#Python3-字符串" class="headerlink" title="Python3 字符串"></a>Python3 字符串</h2><p>字符串是 Python 中最常用的数据类型。我们可以使用引号(‘或”)来创建字符串。</p>
<p>创建字符串很简单，只要为变量分配一个值即可。例如：</p>
<pre><code>var1 = &apos;Hello World!&apos;
var2 = &quot;Runoob&quot;
</code></pre><hr>
<p>访问字符串中的值</p>
<p>Python 不支持单字符类型，单字符也在Python也是作为一个字符串使用。</p>
<p>Python 访问子字符串，可以使用方括号来截取字符串，如下实例：</p>
<pre><code>#!/usr/bin/python3

var1 = &apos;Hello World!&apos;
var2 = &quot;Runoob&quot;

print (&quot;var1[0]: &quot;, var1[0])
print (&quot;var2[1:5]: &quot;, var2[1:5])
</code></pre><p>以上实例执行结果：</p>
<pre><code>var1[0]:  H
var2[1:5]:  unoo
</code></pre><hr>
<p>字符串更新</p>
<p>你可以对已存在的字符串进行修改，并赋值给另一个变量，如下实例：</p>
<pre><code>#!/usr/bin/python3

var1 = &apos;Hello World!&apos;

print (&quot;已更新字符串 : &quot;, var1[:6] + &apos;Runoob!&apos;)
</code></pre><p>以上实例执行结果</p>
<pre><code>已更新字符串 :  Hello Runoob!
</code></pre><hr>
<p>转义字符</p>
<p>在需要在字符中使用特殊字符时，python用反斜杠(\)转义字符。如下表：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\(在行尾时)</td>
<td>续行符</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠符号</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\a</td>
<td>响铃</td>
</tr>
<tr>
<td>\b</td>
<td>退格(Backspace)</td>
</tr>
<tr>
<td>\e</td>
<td>转义</td>
</tr>
<tr>
<td>\000</td>
<td>空</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表符</td>
</tr>
<tr>
<td>\t</td>
<td>横向制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\oyy</td>
<td>八进制数，yy代表的字符，例如：\o12代表换行</td>
</tr>
<tr>
<td>\xyy</td>
<td>十六进制数，yy代表的字符，例如：\x0a代表换行</td>
</tr>
<tr>
<td>\other</td>
<td>其它的字符以普通格式输出</td>
</tr>
</tbody>
</table>
<hr>
<p>字符串运算符</p>
<p>下表实例变量a值为字符串 “Hello”，b变量值为 “Python”：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">字符串连接</td>
<td style="text-align:left">a + b 输出结果： HelloPython</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">重复输出字符串</td>
<td style="text-align:left">a*2 输出结果：HelloHello</td>
</tr>
<tr>
<td style="text-align:center">[]</td>
<td style="text-align:left">通过索引获取字符串中字符</td>
<td style="text-align:left">a[1] 输出结果 <strong>e</strong></td>
</tr>
<tr>
<td style="text-align:center">[ : ]</td>
<td style="text-align:left">截取字符串中的一部分</td>
<td style="text-align:left">a[1:4] 输出结果 <strong>ell</strong></td>
</tr>
<tr>
<td style="text-align:center">in</td>
<td style="text-align:left">成员运算符 - 如果字符串中包含给定的字符返回 True</td>
<td style="text-align:left"><strong>H in a</strong> 输出结果 1</td>
</tr>
<tr>
<td style="text-align:center">not in</td>
<td style="text-align:left">成员运算符 - 如果字符串中不包含给定的字符返回 True</td>
<td style="text-align:left"><strong>M not in a</strong> 输出结果 1</td>
</tr>
<tr>
<td style="text-align:center">r/R</td>
<td style="text-align:left">原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td>
<td style="text-align:left"><strong>print r’\n’</strong> prints \n 和 <strong>print R’\n’</strong> prints \n</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">格式字符串</td>
<td style="text-align:left">请看下一节内容。</td>
</tr>
</tbody>
</table>
<p>实例</p>
<pre><code>#!/usr/bin/python3

a = &quot;Hello&quot;
b = &quot;Python&quot;

print(&quot;a + b 输出结果：&quot;, a + b)
print(&quot;a * 2 输出结果：&quot;, a * 2)
print(&quot;a[1] 输出结果：&quot;, a[1])
print(&quot;a[1:4] 输出结果：&quot;, a[1:4])

if( &quot;H&quot; in a) :
    print(&quot;H 在变量 a 中&quot;)
else :
    print(&quot;H 不在变量 a 中&quot;)

if( &quot;M&quot; not in a) :
    print(&quot;M 不在变量 a 中&quot;)
else :
    print(&quot;M 在变量 a 中&quot;)

print (r&apos;\n&apos;)
print (R&apos;\n&apos;)
</code></pre><p>以上实例输出结果为：</p>
<pre><code>a + b 输出结果： HelloPython
a * 2 输出结果： HelloHello
a[1] 输出结果： e
a[1:4] 输出结果： ell
H 在变量 a 中
M 不在变量 a 中
\n
\n
</code></pre><hr>
<p>字符串格式化</p>
<p>Python 支持格式化字符串的输出。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符<br>%s 的字符串中。</p>
<p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p>
<p>如下实例：</p>
<pre><code>#!/usr/bin/python3

print (&quot;我叫 %s 今年 %d 岁!&quot; % (&apos;小明&apos;, 10))
</code></pre><p>以上实例输出结果：</p>
<pre><code>我叫 小明 今年 10 岁!
</code></pre><p>python字符串格式化符号:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:center">格式化字符及其ASCII码</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">格式化字符串</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">格式化整数</td>
</tr>
<tr>
<td style="text-align:center">%u</td>
<td style="text-align:center">格式化无符号整型</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:center">格式化无符号八进制数</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:center">格式化无符号十六进制数</td>
</tr>
<tr>
<td style="text-align:center">%X</td>
<td style="text-align:center">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td style="text-align:center">%e</td>
<td style="text-align:center">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:center">%E</td>
<td style="text-align:center">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:center">%g</td>
<td style="text-align:center">%f和%e的简写</td>
</tr>
<tr>
<td style="text-align:center">%G</td>
<td style="text-align:center">%f 和 %E 的简写</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">用十六进制数格式化变量的地址</td>
</tr>
</tbody>
</table>
<p>格式化操作符辅助指令:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:left">用做左对齐</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td style="text-align:center">&lt;sp&gt;</td>
<td style="text-align:left">在正数前面显示空格</td>
</tr>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或</td>
<td>者’0X’(取决于用的是’x’还是’X’)</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">显示的数字前面填充’0’而不是默认的空格</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:left">‘%%’输出一个单一的’%’</td>
</tr>
<tr>
<td style="text-align:center">(var)</td>
<td style="text-align:left">映射变量(字典参数)</td>
</tr>
<tr>
<td style="text-align:center">m.n.</td>
<td style="text-align:left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody>
</table>
<hr>
<p>三引号</p>
<p>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"></div><div class="line">para_str = <span class="string">"""这是一个多行字符串的实例</span></div><div class="line"><span class="string">多行字符串可以使用制表符</span></div><div class="line"><span class="string">TAB ( \t )。</span></div><div class="line"><span class="string">也可以使用换行符 [ \n ]。</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">print</span> (para_str)</div></pre></td></tr></table></figure></p>
<p>以上实例执行结果为：</p>
<pre><code>这是一个多行字符串的实例
多行字符串可以使用制表符
TAB (    )。
也可以使用换行符 [
 ]。
</code></pre><p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。</p>
<p>一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">errHTML = <span class="string">'''</span></div><div class="line"><span class="string">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span></div><div class="line"><span class="string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span></div><div class="line"><span class="string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span></div><div class="line"><span class="string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span></div><div class="line"><span class="string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span></div><div class="line"><span class="string">ONCLICK="window.history.back()"&gt;&lt;/FORM&gt;</span></div><div class="line"><span class="string">&lt;/BODY&gt;&lt;/HTML&gt;</span></div><div class="line"><span class="string">'''</span></div><div class="line">cursor.execute(<span class="string">'''</span></div><div class="line"><span class="string">CREATE TABLE users (  </span></div><div class="line"><span class="string">login VARCHAR(8),</span></div><div class="line"><span class="string">uid INTEGER,</span></div><div class="line"><span class="string">prid INTEGER)</span></div><div class="line"><span class="string">'''</span>)</div></pre></td></tr></table></figure>
<hr>
<p>Unicode 字符串</p>
<p>在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀<strong>u</strong>。</p>
<p>在Python3中，所有的字符串都是Unicode字符串。</p>
<hr>
<p>Python 的字符串内建函数</p>
<p>Python 的字符串常用内建函数如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="http://www.runoob.com/python3/python3-string-capitalize.html" target="_blank" rel="external">capitalize()</a> 将字符串的第一个字符转换为大写</td>
</tr>
<tr>
<td>2</td>
<td><a href="http://www.runoob.com/python3/python3-string-center.html" target="_blank" rel="external">center(width,fillchar)</a> 返回一个指定的宽度 width居中的字符串，fillchar为填充的字符，默认为空格。</td>
</tr>
<tr>
<td>3</td>
<td><a href="http://www.runoob.com/python3/python3-string-count.html" target="_blank" rel="external">count(str, beg=0,end=len(string))</a> 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str出现的次数</td>
</tr>
<tr>
<td>4</td>
<td><a href="http://www.runoob.com/python3/python3-string-decode.html" target="_blank" rel="external">bytes.decode(encoding=”utf-8”, errors=”strict”)</a> Python3 中没有 decode 方法，但我们可以使用 bytes 对象的decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由str.encode() 来编码返回。</td>
</tr>
<tr>
<td>5</td>
<td><a href="http://www.runoob.com/python3/python3-string-encode.html" target="_blank" rel="external">encode(encoding=’UTF-8’,errors=’strict’)</a> 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError的异常，除非 errors 指定的是’ignore’或者’replace’</td>
</tr>
<tr>
<td>6</td>
<td>[endswith(suffix, beg=0,</td>
</tr>
<tr>
<td></td>
<td>end=len(string))](<a href="http://www.runoob.com/python3/python" target="_blank" rel="external">http://www.runoob.com/python3/python</a></td>
</tr>
<tr>
<td></td>
<td>3-string-endswith.html)\</td>
</tr>
<tr>
<td></td>
<td>检查字符串是否以 obj</td>
</tr>
<tr>
<td></td>
<td>结束，如果beg 或者 end</td>
</tr>
<tr>
<td></td>
<td>指定则检查指定的范围内是否以 obj</td>
</tr>
<tr>
<td></td>
<td>结束，如果是，返回 True,否则返回</td>
</tr>
<tr>
<td></td>
<td>False.</td>
</tr>
<tr>
<td>7</td>
<td>[expandtabs(tabsize=8)](<a href="http://www.runoob.com/python3/" target="_blank" rel="external">http://www.runoob.com/python3/</a></td>
</tr>
<tr>
<td></td>
<td>python3-string-expandtabs.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>把字符串 string 中的 tab</td>
</tr>
<tr>
<td></td>
<td>符号转为空格，tab</td>
</tr>
<tr>
<td></td>
<td>符号默认的空格数是 8 。</td>
</tr>
<tr>
<td>8</td>
<td>[find(str, beg=0</td>
</tr>
<tr>
<td></td>
<td>end=len(string))](<a href="http://www.runoob.com/python3/python" target="_blank" rel="external">http://www.runoob.com/python3/python</a></td>
</tr>
<tr>
<td></td>
<td>3-string-find.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>检测 str 是否包含在字符串中</td>
</tr>
<tr>
<td></td>
<td>中，如果 beg 和 end</td>
</tr>
<tr>
<td></td>
<td>指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则</td>
</tr>
<tr>
<td></td>
<td>返回-1</td>
</tr>
<tr>
<td>9</td>
<td>[index(str, beg=0,</td>
</tr>
<tr>
<td></td>
<td>end=len(string))](<a href="http://www.runoob.com/python3/python" target="_blank" rel="external">http://www.runoob.com/python3/python</a></td>
</tr>
<tr>
<td></td>
<td>3-string-index.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
</tr>
<tr>
<td>10</td>
<td>[isalnum()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isalnum.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串至少有一个字符并且所有字符都是字母或数字则返</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>回 True,否则返回 False</td>
</tr>
<tr>
<td>11</td>
<td>[isalpha()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isalpha.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串至少有一个字符并且所有字符都是字母则返回</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>True, 否则返回 False</td>
</tr>
<tr>
<td>12</td>
<td>[isdigit()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isdigit.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串只包含数字则返回 True</td>
</tr>
<tr>
<td></td>
<td>否则返回 False..</td>
</tr>
<tr>
<td>13</td>
<td>[islower()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-islower.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写</td>
</tr>
<tr>
<td></td>
<td>的)字符都是小写，则返回</td>
</tr>
<tr>
<td></td>
<td>True，否则返回 False</td>
</tr>
<tr>
<td>14</td>
<td>[isnumeric()](<a href="http://www.runoob.com/python3/python3-st" target="_blank" rel="external">http://www.runoob.com/python3/python3-st</a></td>
</tr>
<tr>
<td></td>
<td>ring-isnumeric.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串中只包含数字字符，则返回</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>True，否则返回 False</td>
</tr>
<tr>
<td>15</td>
<td>[isspace()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isspace.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串中只包含空格，则返回</td>
</tr>
<tr>
<td></td>
<td>True，否则返回 False.</td>
</tr>
<tr>
<td>16</td>
<td>[istitle()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-istitle.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串是标题化的(见</td>
</tr>
<tr>
<td></td>
<td>title())则返回 True，否则返回</td>
</tr>
<tr>
<td></td>
<td>False</td>
</tr>
<tr>
<td>17</td>
<td>[isupper()](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-isupper.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写</td>
</tr>
<tr>
<td></td>
<td>的)字符都是大写，则返回</td>
</tr>
<tr>
<td></td>
<td>True，否则返回 False</td>
</tr>
<tr>
<td>18</td>
<td>[join(seq)](<a href="http://www.runoob.com/python3/python3-stri" target="_blank" rel="external">http://www.runoob.com/python3/python3-stri</a></td>
</tr>
<tr>
<td></td>
<td>ng-join.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>以指定字符串作为分隔符，将 seq</td>
</tr>
<tr>
<td></td>
<td>中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr>
<td>19</td>
<td>[len(string)](<a href="http://www.runoob.com/python3/python3-st" target="_blank" rel="external">http://www.runoob.com/python3/python3-st</a></td>
</tr>
<tr>
<td></td>
<td>ring-len.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回字符串长度</td>
</tr>
<tr>
<td>20</td>
<td>[ljust(width[,</td>
</tr>
<tr>
<td></td>
<td>fillchar])](<a href="http://www.runoob.com/python3/python3-str" target="_blank" rel="external">http://www.runoob.com/python3/python3-str</a></td>
</tr>
<tr>
<td></td>
<td>ing-ljust.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回一个原字符串左对齐,并使用</td>
</tr>
<tr>
<td></td>
<td>fillchar 填充至长度 width</td>
</tr>
<tr>
<td></td>
<td>的新字符串，fillchar 默认为空格。</td>
</tr>
<tr>
<td>21</td>
<td>[lower()](<a href="http://www.runoob.com/python3/python3-string" target="_blank" rel="external">http://www.runoob.com/python3/python3-string</a></td>
</tr>
<tr>
<td></td>
<td>-lower.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>转换字符串中所有大写字符为小写.</td>
</tr>
<tr>
<td>22</td>
<td>[lstrip()](<a href="http://www.runoob.com/python3/python3-strin" target="_blank" rel="external">http://www.runoob.com/python3/python3-strin</a></td>
</tr>
<tr>
<td></td>
<td>g-lstrip.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>截掉字符串左边的空格</td>
</tr>
<tr>
<td>23</td>
<td>[maketrans()](<a href="http://www.runoob.com/python3/python3-st" target="_blank" rel="external">http://www.runoob.com/python3/python3-st</a></td>
</tr>
<tr>
<td></td>
<td>ring-maketrans.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参</td>
</tr>
<tr>
<td></td>
<td>数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标</td>
</tr>
<tr>
<td></td>
<td>。</td>
</tr>
<tr>
<td>24</td>
<td>[max(str)](<a href="http://www.runoob.com/python3/python3-strin" target="_blank" rel="external">http://www.runoob.com/python3/python3-strin</a></td>
</tr>
<tr>
<td></td>
<td>g-max.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回字符串 str 中最大的字母。</td>
</tr>
<tr>
<td>25</td>
<td>[min(str)](<a href="http://www.runoob.com/python3/python3-strin" target="_blank" rel="external">http://www.runoob.com/python3/python3-strin</a></td>
</tr>
<tr>
<td></td>
<td>g-min.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回字符串 str 中最小的字母。</td>
</tr>
<tr>
<td>26</td>
<td>[replace(old, new [,</td>
</tr>
<tr>
<td></td>
<td>max])](<a href="http://www.runoob.com/python3/python3-string-r" target="_blank" rel="external">http://www.runoob.com/python3/python3-string-r</a></td>
</tr>
<tr>
<td></td>
<td>eplace.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>把 将字符串中的 str1 替换成</td>
</tr>
<tr>
<td></td>
<td>str2,如果 max 指定，则替换不超过</td>
</tr>
<tr>
<td></td>
<td>max 次。</td>
</tr>
<tr>
<td>27</td>
<td>[rfind(str,</td>
</tr>
<tr>
<td></td>
<td>beg=0,end=len(string))](<a href="http://www.runoob.com/python3/" target="_blank" rel="external">http://www.runoob.com/python3/</a></td>
</tr>
<tr>
<td></td>
<td>python3-string-rfind.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>类似于</td>
</tr>
<tr>
<td></td>
<td>find()函数，不过是从右边开始查找.</td>
</tr>
<tr>
<td>28</td>
<td>[rindex( str, beg=0,</td>
</tr>
<tr>
<td></td>
<td>end=len(string))](<a href="http://www.runoob.com/python3/python" target="_blank" rel="external">http://www.runoob.com/python3/python</a></td>
</tr>
<tr>
<td></td>
<td>3-string-rindex.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>类似于 index()，不过是从右边开始.</td>
</tr>
<tr>
<td>29</td>
<td>[rjust(width,[,</td>
</tr>
<tr>
<td></td>
<td>fillchar])](<a href="http://www.runoob.com/python3/python3-str" target="_blank" rel="external">http://www.runoob.com/python3/python3-str</a></td>
</tr>
<tr>
<td></td>
<td>ing-rjust.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长</td>
</tr>
<tr>
<td></td>
<td>度</td>
</tr>
<tr>
<td></td>
<td>width 的新字符串</td>
</tr>
<tr>
<td>30</td>
<td>[rstrip()](<a href="http://www.runoob.com/python3/python3-strin" target="_blank" rel="external">http://www.runoob.com/python3/python3-strin</a></td>
</tr>
<tr>
<td></td>
<td>g-rstrip.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>删除字符串字符串末尾的空格.</td>
</tr>
<tr>
<td>31</td>
<td>[split(str=””,</td>
</tr>
<tr>
<td></td>
<td>num=string.count(str))](<a href="http://www.runoob.com/python3/" target="_blank" rel="external">http://www.runoob.com/python3/</a></td>
</tr>
<tr>
<td></td>
<td>python3-string-split.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>num=string.count(str)) 以 str</td>
</tr>
<tr>
<td></td>
<td>为分隔符截取字符串，如果 num</td>
</tr>
<tr>
<td></td>
<td>有指定值，则仅截取 num 个子字符串</td>
</tr>
<tr>
<td>32</td>
<td>[splitlines([keepends])]<a href="http://www.runoob.com(/pytho" target="_blank" rel="external">http://www.runoob.com(/pytho</a></td>
</tr>
<tr>
<td></td>
<td>n3/python3-string-splitlines.html</td>
</tr>
<tr>
<td></td>
<td>)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>按照行(‘\r’, ‘\r\n’,</td>
</tr>
<tr>
<td></td>
<td>\n’)分隔，返回一个包含各行作为元素的列表，如果参数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>keepends 为</td>
</tr>
<tr>
<td></td>
<td>False，不包含换行符，如果为</td>
</tr>
<tr>
<td></td>
<td>True，则保留换行符。</td>
</tr>
<tr>
<td>33</td>
<td>[startswith(str,</td>
</tr>
<tr>
<td></td>
<td>beg=0,end=len(string))](<a href="http://www.runoob.com/python3/" target="_blank" rel="external">http://www.runoob.com/python3/</a></td>
</tr>
<tr>
<td></td>
<td>python3-string-startswith.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>检查字符串是否是以 obj</td>
</tr>
<tr>
<td></td>
<td>开头，是则返回 True，否则返回</td>
</tr>
<tr>
<td></td>
<td>False。如果beg 和 end</td>
</tr>
<tr>
<td></td>
<td>指定值，则在指定范围内检查。</td>
</tr>
<tr>
<td>34</td>
<td>[strip([chars])](<a href="http://www.runoob.com/python3/pytho" target="_blank" rel="external">http://www.runoob.com/python3/pytho</a></td>
</tr>
<tr>
<td></td>
<td>n3-string-strip.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>在字符串上执行 lstrip()和</td>
</tr>
<tr>
<td></td>
<td>rstrip()</td>
</tr>
<tr>
<td>35</td>
<td>[swapcase()](<a href="http://www.runoob.com/python3/python3-str" target="_blank" rel="external">http://www.runoob.com/python3/python3-str</a></td>
</tr>
<tr>
<td></td>
<td>ing-swapcase.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>将字符串中大写转换为小写，小写转换为大写</td>
</tr>
<tr>
<td>36</td>
<td>[title()](<a href="http://www.runoob.com/python3/python3-string" target="_blank" rel="external">http://www.runoob.com/python3/python3-string</a></td>
</tr>
<tr>
<td></td>
<td>-title.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为</td>
</tr>
<tr>
<td></td>
<td>小写(见</td>
</tr>
<tr>
<td></td>
<td>istitle())</td>
</tr>
<tr>
<td>37</td>
<td>[translate(table,</td>
</tr>
<tr>
<td></td>
<td>deletechars=””)](<a href="http://www.runoob.com/python3/python3" target="_blank" rel="external">http://www.runoob.com/python3/python3</a></td>
</tr>
<tr>
<td></td>
<td>-string-translate.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>根据 str 给出的表(包含 256</td>
</tr>
<tr>
<td></td>
<td>个字符)转换 string 的字符,</td>
</tr>
<tr>
<td></td>
<td>要过滤掉的字符放到 deletechars</td>
</tr>
<tr>
<td></td>
<td>参数中</td>
</tr>
<tr>
<td>38</td>
<td>[upper()](<a href="http://www.runoob.com/python3/python3-string" target="_blank" rel="external">http://www.runoob.com/python3/python3-string</a></td>
</tr>
<tr>
<td></td>
<td>-upper.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>转换字符串中的小写字母为大写</td>
</tr>
<tr>
<td>39</td>
<td>[zfill</td>
</tr>
<tr>
<td></td>
<td>(width)](<a href="http://www.runoob.com/python3/python3-string-" target="_blank" rel="external">http://www.runoob.com/python3/python3-string-</a></td>
</tr>
<tr>
<td></td>
<td>zfill.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>返回长度为 width</td>
</tr>
<tr>
<td></td>
<td>的字符串，原字符串右对齐，前面填充0</td>
</tr>
<tr>
<td>40</td>
<td>[isdecimal()](<a href="http://www.runoob.com/python3/python3-st" target="_blank" rel="external">http://www.runoob.com/python3/python3-st</a></td>
</tr>
<tr>
<td></td>
<td>ring-isdecimal.html)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>\</td>
</tr>
<tr>
<td></td>
<td>检查字符串是否只包含十进制字符，如果是返回</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>true，否则返回 false。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Python3-列表"><a href="#Python3-列表" class="headerlink" title="Python3 列表"></a>Python3 列表</h2><p>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 -<br>它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。</p>
<p>Python有6个序列的内置类型，但最常见的是列表和元组。</p>
<p>序列都可以进行的操作包括索引，切片，加，乘，检查成员。</p>
<p>此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</p>
<p>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。</p>
<p>列表的数据项不需要具有相同的类型</p>
<p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：</p>
<pre><code>list1 = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000];
list2 = [1, 2, 3, 4, 5 ];
list3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
</code></pre><p>与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。</p>
<hr>
<p>访问列表中的值</p>
<p>使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示：</p>
<pre><code>#!/usr/bin/python3

list1 = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000];
list2 = [1, 2, 3, 4, 5, 6, 7 ];

print (&quot;list1[0]: &quot;, list1[0])
print (&quot;list2[1:5]: &quot;, list2[1:5])
</code></pre><p>以上实例输出结果：</p>
<pre><code>list1[0]:  Google
list2[1:5]:  [2, 3, 4, 5]
</code></pre><hr>
<p>更新列表</p>
<p>你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示：</p>
<pre><code>#!/usr/bin/python3

list = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000]

print (&quot;第三个元素为 : &quot;, list[2])
list[2] = 2001
print (&quot;更新后的第三个元素为 : &quot;, list[2])
</code></pre><p>以上实例输出结果：</p>
<pre><code>第三个元素为 :  1997
更新后的第三个元素为 :  2001
</code></pre><hr>
<p> 删除列表元素</p>
<p>可以使用 del 语句来删除列表的的元素，如下实例：</p>
<pre><code>#!/usr/bin/python3

list = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000]

print (list)
del list[2]
print (&quot;删除第三个元素 : &quot;, list)
</code></pre><p>以上实例输出结果：</p>
<pre><code>删除第三个元素 :  [&apos;Google&apos;, &apos;Runoob&apos;, 2000]
</code></pre><hr>
<p>列表脚本操作符</p>
<p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，*<br>号用于重复列表。</p>
<p>如下所示：</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len([1, 2, 3])</td>
<td>3</td>
<td>长度</td>
</tr>
<tr>
<td>[1, 2, 3] + [4, 5, 6]</td>
<td>[1, 2, 3, 4, 5, 6]</td>
<td>组合</td>
</tr>
<tr>
<td>[‘Hi!’] * 4</td>
<td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td>重复</td>
</tr>
<tr>
<td>3 in [1, 2, 3]</td>
<td>True</td>
<td>元素是否存在于列表中</td>
</tr>
<tr>
<td>for x in [1, 2, 3]: print x,</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody>
</table>
<hr>
<p>列表截取与拼接</p>
<p>Python的列表截取与字符串操作类型，如下所示：</p>
<pre><code>L=[&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;]
</code></pre><p>操作：</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>L[2]</td>
<td>‘Taobao’</td>
<td>读取第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td>‘Runoob’</td>
<td>从右侧开始读取倒数第二个元素: count from the right</td>
</tr>
<tr>
<td>L[1:]</td>
<td>[‘Runoob’, ‘Taobao’]</td>
<td>输出从第二个元素开始后的所有元素</td>
</tr>
</tbody>
</table>
<pre><code>&gt;&gt;&gt; L=[&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;]
&gt;&gt;&gt; L[2]
&apos;Taobao&apos;
&gt;&gt;&gt; L[-2]
&apos;Runoob&apos;
&gt;&gt;&gt; L[1:]
[&apos;Runoob&apos;, &apos;Taobao&apos;]
&gt;&gt;&gt;
</code></pre><p>列表还支持拼接操作：</p>
<pre><code>&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]
&gt;&gt;&gt; squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre><hr>
<p>嵌套列表</p>
<p>使用嵌套列表即在列表里创建其它列表，例如：</p>
<pre><code>&gt;&gt;&gt; a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
&gt;&gt;&gt; n = [1, 2, 3]
&gt;&gt;&gt; x = [a, n]
&gt;&gt;&gt; x
[[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [1, 2, 3]]
&gt;&gt;&gt; x[0]
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]
&gt;&gt;&gt; x[0][1]
&apos;b&apos;
</code></pre><hr>
<p>列表函数&amp;方法</p>
<p>Python包含以下函数:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="python3-att-list-len.html">len(list)</a>         列表元素个数</td>
</tr>
<tr>
<td>2</td>
<td><a href="python3-att-list-max.html">max(list)</a>        返回列表元素最大值</td>
</tr>
<tr>
<td>3</td>
<td><a href="python3-att-list-min.html">min(list)</a>         返回列表元素最小值</td>
</tr>
<tr>
<td>4</td>
<td><a href="python3-att-list-list.html">list(seq)</a>         将元组转换为列表</td>
</tr>
</tbody>
</table>
<p>Python包含以下方法:</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="python3-att-list-append.html">list.append(obj)</a>  在列表末尾添加新的对象</td>
</tr>
<tr>
<td>2</td>
<td><a href="python3-att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td>3</td>
<td><a href="python3-att-list-extend.html">list.extend(seq)</a>  在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td>4</td>
<td><a href="python3-att-list-index.html">list.index(obj)</a>        从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td>5</td>
<td><a href="python3-att-list-insert.html">list.insert(index, obj)</a>  将对象插入列表</td>
</tr>
<tr>
<td>6</td>
<td><a href="python3-att-list-pop.html">list.pop(obj=list[-1])</a>   移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td>7</td>
<td><a href="python3-att-list-remove.html">list.remove(obj)</a>         移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td>8</td>
<td><a href="python3-att-list-reverse.html">list.reverse()</a>          反向列表中元素</td>
</tr>
<tr>
<td>9</td>
<td><a href="python3-att-list-sort.html">list.sort([func])</a>          对原列表进行排序</td>
</tr>
<tr>
<td>10</td>
<td><a href="python3-att-list-clear.html">list.clear()</a>         清空列表</td>
</tr>
<tr>
<td>11</td>
<td><a href="python3-att-list-copy.html">list.copy()</a>         复制列表</td>
</tr>
</tbody>
</table>
<p><a href="http://www.cnblogs.com/lhj588/archive/2012/01/06/2314181.html" target="_blank" rel="external">http://www.cnblogs.com/lhj588/archive/2012/01/06/2314181.html</a></p>
<hr>
<h2 id="Python3-元组"><a href="#Python3-元组" class="headerlink" title="Python3 元组"></a>Python3 元组</h2><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p>
<p>元组使用小括号，列表使用方括号。</p>
<p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p>
<p>如下实例：</p>
<pre><code>tup1 = (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000);
tup2 = (1, 2, 3, 4, 5 );
tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;;
</code></pre><p>创建空元组</p>
<pre><code>tup1 = ();
</code></pre><p>元组中只包含一个元素时，需要在元素后面添加逗号</p>
<pre><code>tup1 = (50,);
</code></pre><p>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p>
<hr>
<p>访问元组</p>
<p>元组可以使用下标索引来访问元组中的值，如下实例:</p>
<pre><code>#!/usr/bin/python3

tup1 = (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000)
tup2 = (1, 2, 3, 4, 5, 6, 7 )

print (&quot;tup1[0]: &quot;, tup1[0])
print (&quot;tup2[1:5]: &quot;, tup2[1:5])
</code></pre><p>以上实例输出结果：</p>
<pre><code>tup1[0]:  Google
tup2[1:5]:  (2, 3, 4, 5)
</code></pre><hr>
<p>修改元组</p>
<p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:</p>
<pre><code>#!/usr/bin/python3

tup1 = (12, 34.56);
tup2 = (&apos;abc&apos;, &apos;xyz&apos;)

# 以下修改元组元素操作是非法的。
# tup1[0] = 100

# 创建一个新的元组
tup3 = tup1 + tup2;
print (tup3)
</code></pre><p>以上实例输出结果：</p>
<pre><code>(12, 34.56, &apos;abc&apos;, &apos;xyz&apos;)
</code></pre><hr>
<p>删除元组</p>
<p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p>
<pre><code>#!/usr/bin/python3

tup = (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000)

print (tup)
del tup;
print (&quot;删除后的元组 tup : &quot;)
print (tup)
</code></pre><p>以上实例元组被删除后，输出变量会有异常信息，输出如下所示：</p>
<pre><code>删除后的元组 tup :
Traceback (most recent call last):
  File &quot;test.py&quot;, line 8, in &lt;module&gt;
    print (tup)
NameError: name &apos;tup&apos; is not defined
</code></pre><hr>
<p>元组运算符</p>
<p>与字符串一样，元组之间可以使用 + 号和 *<br>号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len((1, 2, 3))</td>
<td>3</td>
<td>计算元素个数</td>
</tr>
<tr>
<td>(1, 2, 3) + (4, 5, 6)</td>
<td>(1, 2, 3, 4, 5, 6)</td>
<td>连接</td>
</tr>
<tr>
<td>(‘Hi!’,) * 4</td>
<td>(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td>
<td>复制</td>
</tr>
<tr>
<td>3 in (1, 2, 3)</td>
<td>True</td>
<td>元素是否存在</td>
</tr>
<tr>
<td>for x in (1, 2, 3): print x,</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody>
</table>
<hr>
<p>元组索引，截取</p>
<p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：</p>
<p>元组：</p>
<pre><code>L = (&apos;Google&apos;, &apos;Taobao&apos;, &apos;Runoob&apos;)
</code></pre><table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>L[2]</td>
<td>‘Runoob!’</td>
<td>读取第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td>‘Taobao’</td>
<td>反向读取；读取倒数第二个元素</td>
</tr>
<tr>
<td>L[1:]</td>
<td>(‘Taobao’, ‘Runoob!’)</td>
<td>截取元素，从第二个开始后的所有元素。</td>
</tr>
</tbody>
</table>
<p>运行实例如下：</p>
<pre><code>&gt;&gt;&gt; L = (&apos;Google&apos;, &apos;Taobao&apos;, &apos;Runoob&apos;)
&gt;&gt;&gt; L[2]
&apos;Runoob&apos;
&gt;&gt;&gt; L[-2]
&apos;Taobao&apos;
&gt;&gt;&gt; L[1:]
(&apos;Taobao&apos;, &apos;Runoob&apos;)
</code></pre><hr>
<p>元组内置函数</p>
<p>Python元组包含了以下内置函数</p>
<p>序号<br>方法及描述<br>实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line">len(tuple)\</div><div class="line">计算元组元素个数。</div><div class="line">    &gt;&gt;&gt; tuple1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>)</div><div class="line">    &gt;&gt;&gt; len(tuple1)</div><div class="line">    <span class="number">3</span></div><div class="line">    &gt;&gt;&gt;</div><div class="line"></div><div class="line"><span class="number">2</span></div><div class="line">max(tuple)\</div><div class="line">返回元组中元素最大值。</div><div class="line">    &gt;&gt;&gt; tuple2 = (<span class="string">'5'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>)</div><div class="line">    &gt;&gt;&gt; max(tuple2)</div><div class="line">    <span class="string">'8'</span></div><div class="line">    &gt;&gt;&gt;</div><div class="line"></div><div class="line"><span class="number">3</span></div><div class="line">min(tuple)</div><div class="line">返回元组中元素最小值。</div><div class="line"></div><div class="line"></div><div class="line">    &gt;&gt;&gt; tuple2 = (<span class="string">'5'</span>, <span class="string">'4'</span>, <span class="string">'8'</span>)</div><div class="line">    &gt;&gt;&gt; min(tuple2)</div><div class="line">    <span class="string">'4'</span></div><div class="line">    &gt;&gt;&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="number">4</span></div><div class="line">tuple(seq)</div><div class="line">将列表转换为元组。</div><div class="line"></div><div class="line"></div><div class="line">    &gt;&gt;&gt; list1= [<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Baidu'</span>]</div><div class="line">    &gt;&gt;&gt; tuple1=tuple(list1)</div><div class="line">    &gt;&gt;&gt; tuple1</div><div class="line">    (<span class="string">'Google'</span>, <span class="string">'Taobao'</span>, <span class="string">'Runoob'</span>, <span class="string">'Baidu'</span>)</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="Python3-字典"><a href="#Python3-字典" class="headerlink" title="Python3 字典"></a>Python3 字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值(key=&gt;value)对用冒号(<strong>:</strong>)分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号(<strong>{})</strong>中<br>,格式如下所示：</p>
<pre><code>d = {key1 : value1, key2 : value2 }
</code></pre><p>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p>
<p>一个简单的字典实例：</p>
<pre><code>dict = {&apos;Alice&apos;: &apos;2341&apos;, &apos;Beth&apos;: &apos;9102&apos;, &apos;Cecil&apos;: &apos;3258&apos;}
</code></pre><p>也可如此创建字典：</p>
<pre><code>dict1 = { &apos;abc&apos;: 456 };
dict2 = { &apos;abc&apos;: 123, 98.6: 37 };
</code></pre><hr>
<p>访问字典里的值</p>
<p>把相应的键放入熟悉的方括弧，如下实例:</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;}

print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])
print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])
</code></pre><p>以上实例输出结果：</p>
<pre><code>dict[&apos;Name&apos;]:  Runoob
dict[&apos;Age&apos;]:  7
</code></pre><p>如果用字典里没有的键访问数据，会输出错误如下：</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;};

print (&quot;dict[&apos;Alice&apos;]: &quot;, dict[&apos;Alice&apos;])
</code></pre><p>以上实例输出结果：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 5, in &lt;module&gt;
    print (&quot;dict[&apos;Alice&apos;]: &quot;, dict[&apos;Alice&apos;])
KeyError: &apos;Alice&apos;
</code></pre><hr>
<p>修改字典</p>
<p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;}

dict[&apos;Age&apos;] = 8;               # 更新 Age
dict[&apos;School&apos;] = &quot;菜鸟教程&quot;  # 添加信息


print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])
print (&quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;])
</code></pre><p>以上实例输出结果：<br>    dict[‘Age’]:  8<br>    dict[‘School’]:  菜鸟教程</p>
<hr>
<p>删除字典元素</p>
<p>能删单一的元素也能清空字典，清空只需一项操作。</p>
<p>显示删除一个字典用del命令，如下实例：</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;}

del dict[&apos;Name&apos;] # 删除键 &apos;Name&apos;
dict.clear()     # 删除字典
del dict         # 删除字典

print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])
print (&quot;dict[&apos;School&apos;]: &quot;, dict[&apos;School&apos;])
</code></pre><p>但这会引发一个异常，因为用执行 del 操作后字典不再存在：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 9, in &lt;module&gt;
    print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])
TypeError: &apos;type&apos; object is not subscriptable
</code></pre><p><strong>注：</strong>del() 方法后面也会讨论。</p>
<hr>
<p>字典键的特性</p>
<p>字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住：</p>
<p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p>
<pre><code>#!/usr/bin/python3

dict = {&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Name&apos;: &apos;小菜鸟&apos;}

print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])
</code></pre><p>以上实例输出结果：</p>
<pre><code>dict[&apos;Name&apos;]:  小菜鸟
</code></pre><p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：</p>
<pre><code>#!/usr/bin/python3

dict = {[&apos;Name&apos;]: &apos;Runoob&apos;, &apos;Age&apos;: 7}

print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])
</code></pre><p>以上实例输出结果：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 3, in &lt;module&gt;
    dict = {[&apos;Name&apos;]: &apos;Runoob&apos;, &apos;Age&apos;: 7}
TypeError: unhashable type: &apos;list&apos;
</code></pre><hr>
<p>字典内置函数&amp;方法</p>
<p>Python字典包含了以下内置函数：</p>
<p>+———————–+———————–+———————–+<br>| 序号                  | 函数及描述            | 实例                  |<br>+=======================+=======================+=======================+<br>| 1                     | len(dict)\            |     &gt;&gt;&gt; dict = {‘Name |<br>|                       | 计算字典元素个数，即键的总数。 | ‘: ‘Runoob’, ‘Age’: 7 |<br>|                       |                       | , ‘Class’: ‘First’}   |<br>|                       |                       |     &gt;&gt;&gt; len(dict)     |<br>|                       |                       |     3                 |<br>+———————–+———————–+———————–+<br>| 2                     | str(dict)\            |     &gt;&gt;&gt; dict = {‘Name |<br>|                       | 输出字典，以可打印的字符串表示。 | ‘: ‘Runoob’, ‘Age’: 7 |<br>|                       |                       | , ‘Class’: ‘First’}   |<br>|                       |                       |     &gt;&gt;&gt; str(dict)     |<br>|                       |                       |     “{‘Name’: ‘Runoob |<br>|                       |                       | ‘, ‘Class’: ‘First’,  |<br>|                       |                       | ‘Age’: 7}”            |<br>+———————–+———————–+———————–+<br>| 3                     | type(variable)\       |     &gt;&gt;&gt; dict = {‘Name |<br>|                       | 返回输入的变量类型，如果变量是字典就返回字 | ‘: ‘Runoob’, ‘Age’: 7 |<br>|                       | 典类型。              | , ‘Class’: ‘First’}   |<br>|                       |                       |     &gt;&gt;&gt; type(dict)    |<br>|                       |                       |     <class 'dict'="">    |<br>+———————–+———————–+———————–+</class></p>
<p>Python字典包含了以下内置方法：</p>
<hr>
<p>  序号   函数及描述</p>
<hr>
<p>  1      <a href="python3-att-dictionary-clear.html">radiansdict.clear()</a>\<br>         删除字典内所有元素</p>
<p>  2      <a href="python3-att-dictionary-copy.html">radiansdict.copy()</a>\<br>         返回一个字典的浅复制</p>
<p>  3      <a href="python3-att-dictionary-fromkeys.html">radiansdict.fromkeys()</a>\<br>         创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</p>
<p>  4      <a href="python3-att-dictionary-get.html">radiansdict.get(key, default=None)</a>\<br>         返回指定键的值，如果值不在字典中返回default值</p>
<p>  5      <a href="python3-att-dictionary-in.html">key in dict</a>\<br>         如果键在字典dict里返回true，否则返回false</p>
<p>  6      <a href="python3-att-dictionary-items.html">radiansdict.items()</a>\<br>         以列表返回可遍历的(键, 值) 元组数组</p>
<p>  7      <a href="python3-att-dictionary-keys.html">radiansdict.keys()</a>\<br>         以列表返回一个字典所有的键</p>
<p>  8      <a href="python3-att-dictionary-setdefault.html">radiansdict.setdefault(key, default=None)</a>\<br>         和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</p>
<p>  9      <a href="python3-att-dictionary-update.html">radiansdict.update(dict2)</a>\<br>         把字典dict2的键/值对更新到dict里</p>
<p>  10     <a href="python3-att-dictionary-values.html">radiansdict.values()</a>\</p>
<pre><code>以列表返回字典中的所有值
</code></pre><hr>
<hr>
<h2 id="Python3-Set"><a href="#Python3-Set" class="headerlink" title="Python3 Set"></a>Python3 Set</h2><p><a href="http://www.cnblogs.com/panwenbin-logs/p/5519617.html" target="_blank" rel="external">python中set和frozenset方法和区别</a></p>
<hr>
<h2 id="Python3-编程第一步"><a href="#Python3-编程第一步" class="headerlink" title="Python3 编程第一步"></a>Python3 编程第一步</h2><p>在前面的教程中我们已经学习了一些 Python3<br>的基本语法知识，下面我们尝试来写一个斐波纳契数列。</p>
<p>实例如下：</p>
<pre><code>#!/usr/bin/python3

# Fibonacci series: 斐波纳契数列
# 两个元素的总和确定了下一个数
a, b = 0, 1
while b &lt; 10:
    print(b)
    a, b = b, a+b
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>1
1
2
3
5
8
</code></pre><p>这个例子介绍了几个新特征。</p>
<ul>
<li>第一行包含了一个复合赋值：变量 a 和 b 同时得到新值 0 和<br>1。最后一行再次使用了同样的方法，可以看到，右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。</li>
</ul>
<!-- -->
<pre><code>&gt;&gt;&gt; i = 256*256
&gt;&gt;&gt; print(&apos;i 的值为：&apos;, i)
i 的值为： 65536
</code></pre><hr>
<p>end 关键字</p>
<p>关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：</p>
<pre><code>#!/usr/bin/python3

# Fibonacci series: 斐波纳契数列
# 两个元素的总和确定了下一个数
a, b = 0, 1
while b &lt; 1000:
    print(b, end=&apos;,&apos;)
    a, b = b, a+b
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
</code></pre><hr>
<h2 id="Python3-条件控制"><a href="#Python3-条件控制" class="headerlink" title="Python3 条件控制"></a>Python3 条件控制</h2><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。</p>
<p>可以通过下图来简单了解条件语句的执行过程:</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2013/11/if-condition.jpg" alt=""></p>
<hr>
<p>if 语句</p>
<p>Python中if语句的一般形式如下所示：</p>
<pre><code>if condition_1:
    statement_block_1
elif condition_2:
    statement_block_2
else:
    statement_block_3
</code></pre><ul>
<li>如果 “condition_1” 为 True 将执行 “statement_block_1” 块语句</li>
<li>如果 “condition_1” 为False，将判断 “condition_2”</li>
<li>如果”condition_2” 为 True 将执行 “statement_block_2” 块语句</li>
<li>如果 “condition_2” 为False，将执行”statement_block_3”块语句</li>
</ul>
<p>Python 中用 <strong>elif</strong> 代替了 <strong>else if</strong>，所以if语句的关键字为：<strong>if –<br>elif – else</strong>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、每个条件后面要使用冒号（:），表示接下来是满足条件后要执行的语句块。</li>
<li>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li>
<li>3、在Python中没有switch – case语句。</li>
</ul>
<hr>
<p>实例</p>
<p>以下是一个简单的 if 实例：</p>
<pre><code>#!/usr/bin/python3

var1 = 100
if var1:
   print (&quot;1 - if 表达式条件为 true&quot;)
   print (var1)

var2 = 0
if var2:
   print (&quot;2 - if 表达式条件为 true&quot;)
   print (var2)
print (&quot;Good bye!&quot;)
</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>1 - if 表达式条件为 true
100
Good bye!
</code></pre><p>从结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行。</p>
<p>以下实例演示了狗的年龄计算判断：</p>
<pre><code>#!/usr/bin/python3

age = int(input(&quot;请输入你家狗狗的年龄: &quot;))
print(&quot;&quot;)
if age &lt; 0:
    print(&quot;你是在逗我吧!&quot;)
elif age == 1:
    print(&quot;相当于 14 岁的人。&quot;)
elif age == 2:
    print(&quot;相当于 22 岁的人。&quot;)
elif age &gt; 2:
    human = 22 + (age -2)*5
    print(&quot;对应人类年龄: &quot;, human)

### 退出提示
input(&quot;点击 enter 键退出&quot;)
</code></pre><p>将以上脚本保存在dog.py文件中，并执行该脚本：</p>
<pre><code>$ python3 dog.py
请输入你家狗狗的年龄: 1

相当于 14 岁的人。
点击 enter 键退出
</code></pre><p>以下为if中常用的操作运算符:</p>
<p>  操作符   描述</p>
<p>  <code>&lt;</code>      小于<br>  <code>&lt;=</code>     小于或等于<br>  <code>&gt;</code>      大于<br>  <code>&gt;=</code>     大于或等于<br>  <code>==</code>     等于，比较对象是否相等<br>  <code>!=</code>     不等于</p>
<hr>
<p>实例</p>
<pre><code>#!/usr/bin/python3

# 程序演示了 == 操作符
# 使用数字
print(5 == 6)
# 使用变量
x = 5
y = 8
print(x == y)
</code></pre><p>以上实例输出结果：</p>
<pre><code>False
False
</code></pre><p>high_low.py文件演示了数字的比较运算：</p>
<pre><code>#!/usr/bin/python3

# 该实例演示了数字猜谜游戏
number = 7
guess = -1
print(&quot;数字猜谜游戏!&quot;)
while guess != number:
    guess = int(input(&quot;请输入你猜的数字：&quot;))

    if guess == number:
        print(&quot;恭喜，你猜对了！&quot;)
    elif guess &lt; number:
        print(&quot;猜的数字小了...&quot;)
    elif guess &gt; number:
        print(&quot;猜的数字大了...&quot;)
</code></pre><p>执行以上脚本，实例输出结果如下：</p>
<pre><code>$ python3 high_low.py
数字猜谜游戏!
请输入你猜的数字：1
猜的数字小了...
请输入你猜的数字：9
猜的数字大了...
请输入你猜的数字：7
恭喜，你猜对了！
</code></pre><hr>
<p>if 嵌套</p>
<p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个<br>if…elif…else 结构中。</p>
<pre><code>if 表达式1:
    语句
    if 表达式2:
        语句
    elif 表达式3:
        语句
    else
        语句
elif 表达式4:
    语句
else:
    语句
</code></pre><hr>
<p>实例</p>
<pre><code># !/usr/bin/python3

num=int(input(&quot;输入一个数字：&quot;))
if num%2==0:
    if num%3==0:
        print (&quot;你输入的数字可以整除 2 和 3&quot;)
    else:
        print (&quot;你输入的数字可以整除 2，但不能整除 3&quot;)
else:
    if num%3==0:
        print (&quot;你输入的数字可以整除 3，但不能整除 2&quot;)
    else:
        print  (&quot;你输入的数字不能整除 2 和 3&quot;)
</code></pre><p>将以上程序保存到 test_if.py 文件中，执行后输出结果为：</p>
<pre><code>$ python3 test.py
输入一个数字：6
你输入的数字可以整除 2 和 3
</code></pre><hr>
<h2 id="Python3-循环语句"><a href="#Python3-循环语句" class="headerlink" title="Python3 循环语句"></a>Python3 循环语句</h2><p>Python3 循环语句</p>
<p>本章节将为大家介绍Python循环语句的使用。</p>
<p>Python中的循环语句有 for 和 while。</p>
<p>Python循环语句的控制结构图如下所示：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/05/while_loop_1.png" alt=""></p>
<hr>
<p>while 循环</p>
<p>Python中while语句的一般形式：</p>
<pre><code>while 判断条件：
    语句
</code></pre><p>同样需要注意冒号和缩进。另外，在Python中没有do..while循环。</p>
<p>以下实例使用了 while 来计算 1 到 100 的总和：</p>
<pre><code>#!/usr/bin/env python3

n = 100

sum = 0
counter = 1
while counter &lt;= n:
    sum = sum + counter
    counter += 1

print(&quot;1 到 %d 之和为: %d&quot; % (n,sum))
</code></pre><p>执行结果如下：</p>
<pre><code>1 到 100 之和为: 5050
</code></pre><hr>
<p>无限循环</p>
<p>我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下：</p>
<pre><code>#!/usr/bin/python3

var = 1
while var == 1 :  # 表达式永远为 true
   num = int(input(&quot;输入一个数字  :&quot;))
   print (&quot;你输入的数字是: &quot;, num)

print (&quot;Good bye!&quot;)
</code></pre><p>执行以上脚本，输出结果如下：</p>
<pre><code>输入一个数字  :5
你输入的数字是:  5
输入一个数字  :
</code></pre><p>你可以使用 <strong>CTRL+C</strong> 来退出当前的无限循环。</p>
<p>无限循环在服务器上客户端的实时请求非常有用。</p>
<hr>
<p>while 循环使用 else 语句</p>
<p>在 while … else 在条件语句为 false 时执行 else 的语句块：</p>
<pre><code>#!/usr/bin/python3

count = 0
while count &lt; 5:
   print (count, &quot; 小于 5&quot;)
   count = count + 1
else:
   print (count, &quot; 大于或等于 5&quot;)
</code></pre><p>执行以上脚本，输出结果如下：</p>
<pre><code>0  小于 5
1  小于 5
2  小于 5
3  小于 5
4  小于 5
5  大于或等于 5
</code></pre><hr>
<p>简单语句组</p>
<p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中，<br>如下所示：</p>
<pre><code>#!/usr/bin/python

flag = 1

while (flag): print (&apos;欢迎访问菜鸟教程!&apos;)

print (&quot;Good bye!&quot;)
</code></pre><p><strong>注意：</strong>以上的无限循环你可以使用 CTRL+C 来中断循环。</p>
<p>执行以上脚本，输出结果如下：</p>
<hr>
<p>for 语句</p>
<p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p>
<p>for循环的一般格式如下：</p>
<pre><code>for &lt;variable&gt; in &lt;sequence&gt;:
    &lt;statements&gt;
else:
    &lt;statements&gt;
</code></pre><p>Python loop循环实例：</p>
<pre><code>&gt;&gt;&gt; languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;]
&gt;&gt;&gt; for x in languages:
...     print (x)
...
C
C++
Perl
Python
&gt;&gt;&gt;
</code></pre><p>以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体：</p>
<pre><code>#!/usr/bin/python3

sites = [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;]
for site in sites:
    if site == &quot;Runoob&quot;:
        print(&quot;菜鸟教程!&quot;)
        break
    print(&quot;循环数据 &quot; + site)
else:
    print(&quot;没有循环数据!&quot;)
print(&quot;完成循环!&quot;)
</code></pre><p>执行脚本后，在循环到 “Runoob”时会跳出循环体：</p>
<pre><code>循环数据 Baidu
循环数据 Google
菜鸟教程!
完成循环!
</code></pre><hr>
<p>range()函数</p>
<p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:</p>
<pre><code>&gt;&gt;&gt; for i in range(5):
...     print(i)
...
0
1
2
3
4
</code></pre><p>你也可以使用range指定区间的值：</p>
<pre><code>&gt;&gt;&gt; for i in range(5,9) :
    print(i)


5
6
7
8
&gt;&gt;&gt;
</code></pre><p>也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做’步长’):</p>
<pre><code>&gt;&gt;&gt; for i in range(0, 10, 3) :
    print(i)


0
3
6
9
&gt;&gt;&gt;
</code></pre><p>负数：</p>
<pre><code>&gt;&gt;&gt; for i in range(-10, -100, -30) :
    print(i)


-10
-40
-70
&gt;&gt;&gt;
</code></pre><p>您可以结合range()和len()函数以遍历一个序列的索引,如下所示:</p>
<pre><code>&gt;&gt;&gt; a = [&apos;Google&apos;, &apos;Baidu&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;, &apos;QQ&apos;]
&gt;&gt;&gt; for i in range(len(a)):
...     print(i, a[i])
...
0 Google
1 Baidu
2 Runoob
3 Taobao
4 QQ
&gt;&gt;&gt;
</code></pre><p>还可以使用range()函数来创建一个列表：</p>
<pre><code>&gt;&gt;&gt; list(range(5))
[0, 1, 2, 3, 4]
&gt;&gt;&gt;
</code></pre><hr>
<p>break和continue语句及循环中的else子句</p>
<p>break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while<br>循环中终止，任何对应的循环 else 块将不执行。 实例如下：</p>
<pre><code>#!/usr/bin/python3

for letter in &apos;Runoob&apos;:     # 第一个实例
   if letter == &apos;b&apos;:
      break
   print (&apos;当前字母为 :&apos;, letter)

var = 10                    # 第二个实例
while var &gt; 0:              
   print (&apos;当期变量值为 :&apos;, var)
   var = var -1
   if var == 5:
      break

print (&quot;Good bye!&quot;)
</code></pre><p>执行以上脚本输出结果为：</p>
<pre><code>当前字母为 : R
当前字母为 : u
当前字母为 : n
当前字母为 : o
当前字母为 : o
当期变量值为 : 10
当期变量值为 : 9
当期变量值为 : 8
当期变量值为 : 7
当期变量值为 : 6
Good bye!
</code></pre><p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p>
<pre><code>#!/usr/bin/python3

for letter in &apos;Runoob&apos;:     # 第一个实例
   if letter == &apos;o&apos;:        # 字母为 o 时跳过输出
      continue
   print (&apos;当前字母 :&apos;, letter)

var = 10                    # 第二个实例
while var &gt; 0:              
   var = var -1
   if var == 5:             # 变量为 5 时跳过输出
      continue
   print (&apos;当前变量值 :&apos;, var)
print (&quot;Good bye!&quot;)
</code></pre><p>执行以上脚本输出结果为：</p>
<pre><code>当前字母 : R
当前字母 : u
当前字母 : n
当前字母 : b
当前变量值 : 9
当前变量值 : 8
当前变量值 : 7
当前变量值 : 6
当前变量值 : 4
当前变量值 : 3
当前变量值 : 2
当前变量值 : 1
当前变量值 : 0
Good bye!
</code></pre><p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false<br>(以while循环)导致循环终止时被执行,但循环被break终止时不执行。</p>
<p>如下实例用于查询质数的循环例子:</p>
<pre><code>#!/usr/bin/python3

for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, &apos;等于&apos;, x, &apos;*&apos;, n//x)
            break
    else:
        # 循环中没有找到元素
        print(n, &apos; 是质数&apos;)
</code></pre><p>执行以上脚本输出结果为：</p>
<pre><code>2  是质数
3  是质数
4 等于 2 * 2
5  是质数
6 等于 2 * 3
7  是质数
8 等于 2 * 4
9 等于 3 * 3
</code></pre><hr>
<p>pass 语句</p>
<p>Python pass是空语句，是为了保持程序结构的完整性。</p>
<p>pass 不做任何事情，一般用做占位语句，如下实例</p>
<pre><code>&gt;&gt;&gt; while True:
...     pass  # 等待键盘中断 (Ctrl+C)
</code></pre><p>最小的类:</p>
<pre><code>&gt;&gt;&gt; class MyEmptyClass:
...     pass
</code></pre><p>以下实例在字母为 o 时 执行 pass 语句块:</p>
<pre><code>#!/usr/bin/python3

for letter in &apos;Runoob&apos;:
   if letter == &apos;o&apos;:
      pass
      print (&apos;执行 pass 块&apos;)
   print (&apos;当前字母 :&apos;, letter)

print (&quot;Good bye!&quot;)
</code></pre><p>执行以上脚本输出结果为：</p>
<pre><code>当前字母 : R
当前字母 : u
当前字母 : n
执行 pass 块
当前字母 : o
执行 pass 块
当前字母 : o
当前字母 : b
Good bye!
</code></pre><hr>
<h2 id="Python3-迭代器与生成器"><a href="#Python3-迭代器与生成器" class="headerlink" title="Python3 迭代器与生成器"></a>Python3 迭代器与生成器</h2><p>迭代器</p>
<p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<pre><code>&gt;&gt;&gt; list=[1,2,3,4]
&gt;&gt;&gt; it = iter(list)    # 创建迭代器对象
&gt;&gt;&gt; print (next(it))   # 输出迭代器的下一个元素
1
&gt;&gt;&gt; print (next(it))
2
&gt;&gt;&gt;
</code></pre><p>迭代器对象可以使用常规for语句进行遍历：</p>
<pre><code>#!/usr/bin/python3

list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象
for x in it:
    print (x, end=&quot; &quot;)
</code></pre><p>执行以上程序，输出结果如下：</p>
<pre><code>1 2 3 4
</code></pre><p>也可以使用 next() 函数：</p>
<pre><code>#!/usr/bin/python3

import sys         # 引入 sys 模块

list=[1,2,3,4]
it = iter(list)    # 创建迭代器对象

while True:
    try:
        print (next(it))
    except StopIteration:
        sys.exit()
</code></pre><p>执行以上程序，输出结果如下：</p>
<pre><code>1
2
3
4
</code></pre><hr>
<p>生成器</p>
<p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield<br>时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行<br>next()方法时从当前位置继续运行。</p>
<p>以下实例使用 yield 实现斐波那契数列：</p>
<pre><code>#!/usr/bin/python3

import sys

def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter &gt; n):
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成

while True:
    try:
        print (next(f), end=&quot; &quot;)
    except StopIteration:
        sys.exit()
</code></pre><p>执行以上程序，输出结果如下：</p>
<pre><code>0 1 1 2 3 5 8 13 21 34 55
</code></pre><hr>
<h2 id="Python3-函数"><a href="#Python3-函数" class="headerlink" title="Python3 函数"></a>Python3 函数</h2><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p>
<p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<hr>
<p>定义一个函数</p>
<p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 <strong>()</strong>。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li>
<li>函数内容以冒号起始，并且缩进。</li>
<li><strong>return [表达式]</strong><br>结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回<br>None。</li>
</ul>
<hr>
<p>语法</p>
<p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<pre><code>def 函数名（参数列表）:
    函数体
</code></pre><p>默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。</p>
<p>实例</p>
<p>让我们使用函数来输出”Hello World！”：</p>
<pre><code>&gt;&gt;&gt; def hello() :
   print(&quot;Hello World!&quot;)


&gt;&gt;&gt; hello()
Hello World!
&gt;&gt;&gt;
</code></pre><p>更复杂点的应用，函数中带上参数变量:</p>
<pre><code>#!/usr/bin/python3

# 计算面积函数
def area(width, height):
    return width * height

def print_welcome(name):
    print(&quot;Welcome&quot;, name)

print_welcome(&quot;Runoob&quot;)
w = 4
h = 5
print(&quot;width =&quot;, w, &quot; height =&quot;, h, &quot; area =&quot;, area(w, h))
</code></pre><p>以上实例输出结果：</p>
<pre><code>Welcome Runoob
width = 4  height = 5  area = 20
</code></pre><hr>
<p>函数调用</p>
<p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p>
<p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python 命令提示符执行。</p>
<p>如下实例调用了 <strong>printme()</strong> 函数：</p>
<pre><code>#!/usr/bin/python3

# 定义函数
def printme( str ):
   &quot;打印任何传入的字符串&quot;
   print (str);
   return;

# 调用函数
printme(&quot;我要调用用户自定义函数!&quot;);
printme(&quot;再次调用同一函数&quot;);
</code></pre><p>以上实例输出结果：</p>
<pre><code>我要调用用户自定义函数!
再次调用同一函数
</code></pre><hr>
<p>按值传递参数和按引用传递参数</p>
<p>在 Python中，所有参数（变量）都是按引用传递。如果你在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p>
<pre><code>#!/usr/bin/python3

# 可写函数说明
def changeme( mylist ):
   &quot;修改传入的列表&quot;
   mylist.append([1,2,3,4]);
   print (&quot;函数内取值: &quot;, mylist)
   return

# 调用changeme函数
mylist = [10,20,30];
changeme( mylist );
print (&quot;函数外取值: &quot;, mylist)
</code></pre><p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p>
<pre><code>函数内取值:  [10, 20, 30, [1, 2, 3, 4]]
函数外取值:  [10, 20, 30, [1, 2, 3, 4]]
</code></pre><hr>
<p>参数</p>
<p>以下是调用函数时可使用的正式参数类型：</p>
<ul>
<li>必需参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<hr>
<p>必需参数</p>
<p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<p>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p>
<pre><code>#!/usr/bin/python3

#可写函数说明
def printme( str ):
   &quot;打印任何传入的字符串&quot;
   print (str);
   return;

#调用printme函数
printme();
</code></pre><p>以上实例输出结果：</p>
<pre><code>Traceback (most recent call last):
  File &quot;test.py&quot;, line 10, in &lt;module&gt;
    printme();
TypeError: printme() missing 1 required positional argument: &apos;str&apos;
</code></pre><hr>
<p>关键字参数</p>
<p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python<br>解释器能够用参数名匹配参数值。</p>
<p>以下实例在函数 printme() 调用时使用参数名：</p>
<pre><code>#!/usr/bin/python3

#可写函数说明
def printme( str ):
   &quot;打印任何传入的字符串&quot;
   print (str);
   return;

#调用printme函数
printme( str = &quot;菜鸟教程&quot;);
</code></pre><p>以上实例输出结果：</p>
<pre><code>菜鸟教程
</code></pre><p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p>
<pre><code>#!/usr/bin/python3

#可写函数说明
def printinfo( name, age ):
   &quot;打印任何传入的字符串&quot;
   print (&quot;名字: &quot;, name);
   print (&quot;年龄: &quot;, age);
   return;

#调用printinfo函数
printinfo( age=50, name=&quot;runoob&quot; );
</code></pre><p>以上实例输出结果：</p>
<pre><code>名字:  runoob
年龄:  50
</code></pre><hr>
<p>默认参数</p>
<p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入<br>age 参数，则使用默认值：</p>
<pre><code>#!/usr/bin/python3

#可写函数说明
def printinfo( name, age = 35 ):
   &quot;打印任何传入的字符串&quot;
   print (&quot;名字: &quot;, name);
   print (&quot;年龄: &quot;, age);
   return;

#调用printinfo函数
printinfo( age=50, name=&quot;runoob&quot; );
print (&quot;------------------------&quot;)
printinfo( name=&quot;runoob&quot; );
</code></pre><p>以上实例输出结果：</p>
<pre><code>名字:  runoob
年龄:  50
------------------------
名字:  runoob
年龄:  35
</code></pre><hr>
<p>不定长参数</p>
<p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p>
<pre><code>def functionname([formal_args,] *var_args_tuple ):
   &quot;函数_文档字符串&quot;
   function_suite
   return [expression]
</code></pre><p>加了星号（*）的变量名会存放所有未命名的变量参数。如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p>
<pre><code>#!/usr/bin/python3

# 可写函数说明
def printinfo( arg1, *vartuple ):
   &quot;打印任何传入的参数&quot;
   print (&quot;输出: &quot;)
   print (arg1)
   for var in vartuple:
      print (var)
   return;

# 调用printinfo 函数
printinfo( 10 );
printinfo( 70, 60, 50 );
</code></pre><p>以上实例输出结果：</p>
<pre><code>输出:
10
输出:
70
60
50
</code></pre><hr>
<p>匿名函数</p>
<p>python 使用 lambda 来创建匿名函数。</p>
<p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。</p>
<ul>
<li>lambda 只是一个表达式，函数体比 def 简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda<br>函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li>
<li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<hr>
<p>语法</p>
<p>lambda 函数的语法只包含一个语句，如下：</p>
<pre><code>lambda [arg1 [,arg2,.....argn]]:expression
</code></pre><p>如下实例：</p>
<pre><code>#!/usr/bin/python3

# 可写函数说明
sum = lambda arg1, arg2: arg1 + arg2;

# 调用sum函数
print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))
print (&quot;相加后的值为 : &quot;, sum( 20, 20 ))
</code></pre><p>以上实例输出结果：</p>
<pre><code>相加后的值为 :  30
相加后的值为 :  40
</code></pre><hr>
<p>return语句</p>
<p><strong>return [表达式]</strong><br>语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了<br>return 语句的用法：</p>
<pre><code>#!/usr/bin/python3

# 可写函数说明
def sum( arg1, arg2 ):
   # 返回2个参数的和.&quot;
   total = arg1 + arg2
   print (&quot;函数内 : &quot;, total)
   return total;

# 调用sum函数
total = sum( 10, 20 );
print (&quot;函数外 : &quot;, total)
</code></pre><p>以上实例输出结果：</p>
<pre><code>函数内 :  30
函数外 :  30
</code></pre><hr>
<p>变量作用域</p>
<p>Python<br>中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p>
<p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。两种最基本的变量作用域如下：</p>
<ul>
<li>全局变量</li>
<li>局部变量</li>
</ul>
<hr>
<p>全局变量和局部变量</p>
<p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p>
<pre><code>#!/usr/bin/python3

total = 0; # 这是一个全局变量
# 可写函数说明
def sum( arg1, arg2 ):
    #返回2个参数的和.&quot;
    total = arg1 + arg2; # total在这里是局部变量.
    print (&quot;函数内是局部变量 : &quot;, total)
    return total;

#调用sum函数
sum( 10, 20 );
print (&quot;函数外是全局变量 : &quot;, total)
</code></pre><p>以上实例输出结果：</p>
<pre><code>函数内是局部变量 :  30
函数外是全局变量 :  0
</code></pre><hr>
<h2 id="Python3-数据结构"><a href="#Python3-数据结构" class="headerlink" title="Python3 数据结构"></a>Python3 数据结构</h2><p>本章节我们主要结合前面所学的知识点来介绍Python数据结构。</p>
<hr>
<p>列表</p>
<p>Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。</p>
<p>以下是 Python 中列表的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>list.append(x)</td>
<td>把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。</td>
</tr>
<tr>
<td>list.extend(L)</td>
<td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。</td>
</tr>
<tr>
<td>list.insert(i, x)</td>
<td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。</td>
</tr>
<tr>
<td>list.remove(x)</td>
<td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。</td>
</tr>
<tr>
<td>list.pop([i])</td>
<td>从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被删除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）</td>
</tr>
<tr>
<td>list.clear()</td>
<td>移除列表中的所有项，等于del a[:]。</td>
</tr>
<tr>
<td>list.index(x)</td>
<td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。</td>
</tr>
<tr>
<td>list.count(x)</td>
<td>返回 x 在列表中出现的次数。</td>
</tr>
<tr>
<td>list.sort()</td>
<td>对列表中的元素进行排序。</td>
</tr>
<tr>
<td>list.reverse()</td>
<td>倒排列表中的元素。</td>
</tr>
<tr>
<td>list.copy()</td>
<td>返回列表的浅复制，等于a[:]。</td>
</tr>
</tbody>
</table>
<p>下面示例演示了列表的大部分方法：</p>
<pre><code>&gt;&gt;&gt; a = [66.25, 333, 333, 1, 1234.5]
&gt;&gt;&gt; print(a.count(333), a.count(66.25), a.count(&apos;x&apos;))
2 1 0
&gt;&gt;&gt; a.insert(2, -1)
&gt;&gt;&gt; a.append(333)
&gt;&gt;&gt; a
[66.25, 333, -1, 333, 1, 1234.5, 333]
&gt;&gt;&gt; a.index(333)
1
&gt;&gt;&gt; a.remove(333)
&gt;&gt;&gt; a
[66.25, -1, 333, 1, 1234.5, 333]
&gt;&gt;&gt; a.reverse()
&gt;&gt;&gt; a
[333, 1234.5, 1, 333, -1, 66.25]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[-1, 1, 66.25, 333, 333, 1234.5]
</code></pre><p>注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。</p>
<hr>
<p>将列表当做堆栈使用</p>
<p>列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用<br>append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop()<br>方法可以把一个元素从堆栈顶释放出来。例如：</p>
<pre><code>&gt;&gt;&gt; stack = [3, 4, 5]
&gt;&gt;&gt; stack.append(6)
&gt;&gt;&gt; stack.append(7)
&gt;&gt;&gt; stack
[3, 4, 5, 6, 7]
&gt;&gt;&gt; stack.pop()
7
&gt;&gt;&gt; stack
[3, 4, 5, 6]
&gt;&gt;&gt; stack.pop()
6
&gt;&gt;&gt; stack.pop()
5
&gt;&gt;&gt; stack
[3, 4]
</code></pre><hr>
<p>将列表当作队列使用</p>
<p>也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。</p>
<pre><code>&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; queue = deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])
&gt;&gt;&gt; queue.append(&quot;Terry&quot;)           # Terry arrives
&gt;&gt;&gt; queue.append(&quot;Graham&quot;)          # Graham arrives
&gt;&gt;&gt; queue.popleft()                 # The first to arrive now leaves
&apos;Eric&apos;
&gt;&gt;&gt; queue.popleft()                 # The second to arrive now leaves
&apos;John&apos;
&gt;&gt;&gt; queue                           # Remaining queue in order of arrival
deque([&apos;Michael&apos;, &apos;Terry&apos;, &apos;Graham&apos;])
</code></pre><hr>
<p>列表推导式</p>
<p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。</p>
<p>每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if<br>子句。返回结果是一个根据表达从其后的 for 和 if<br>上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。</p>
<p>这里我们将列表中每个数值乘三，获得一个新的列表：</p>
<pre><code>&gt;&gt;&gt; vec = [2, 4, 6]
&gt;&gt;&gt; [3*x for x in vec]
[6, 12, 18]
</code></pre><p>现在我们玩一点小花样：</p>
<pre><code>&gt;&gt;&gt; [[x, x**2] for x in vec]
[[2, 4], [4, 16], [6, 36]]
</code></pre><p>这里我们对序列里每一个元素逐个调用某方法：</p>
<pre><code>&gt;&gt;&gt; freshfruit = [&apos;  banana&apos;, &apos;  loganberry &apos;, &apos;passion fruit  &apos;]
&gt;&gt;&gt; [weapon.strip() for weapon in freshfruit]
[&apos;banana&apos;, &apos;loganberry&apos;, &apos;passion fruit&apos;]
</code></pre><p>我们可以用 if 子句作为过滤器：</p>
<pre><code>&gt;&gt;&gt; [3*x for x in vec if x &gt; 3]
[12, 18]
&gt;&gt;&gt; [3*x for x in vec if x &lt; 2]
[]
</code></pre><p>以下是一些关于循环和其它技巧的演示：</p>
<pre><code>&gt;&gt;&gt; vec1 = [2, 4, 6]
&gt;&gt;&gt; vec2 = [4, 3, -9]
&gt;&gt;&gt; [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
&gt;&gt;&gt; [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
&gt;&gt;&gt; [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
</code></pre><p>列表推导式可以使用复杂表达式或嵌套函数：</p>
<pre><code>&gt;&gt;&gt; [str(round(355/113, i)) for i in range(1, 6)]
[&apos;3.1&apos;, &apos;3.14&apos;, &apos;3.142&apos;, &apos;3.1416&apos;, &apos;3.14159&apos;]
</code></pre><hr>
<p>嵌套列表解析</p>
<p>Python的列表还可以嵌套。</p>
<p>以下实例展示了3X4的矩阵列表：</p>
<pre><code>&gt;&gt;&gt; matrix = [
...     [1, 2, 3, 4],
...     [5, 6, 7, 8],
...     [9, 10, 11, 12],
... ]
</code></pre><p>以下实例将3X4的矩阵列表转换为4X3列表：</p>
<pre><code>&gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</code></pre><p>以下实例也可以使用以下方法来实现：</p>
<pre><code>&gt;&gt;&gt; transposed = []
&gt;&gt;&gt; for i in range(4):
...     transposed.append([row[i] for row in matrix])
...
&gt;&gt;&gt; transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</code></pre><p>另外一种实现方法：</p>
<pre><code>&gt;&gt;&gt; transposed = []
&gt;&gt;&gt; for i in range(4):
...     # the following 3 lines implement the nested listcomp
...     transposed_row = []
...     for row in matrix:
...         transposed_row.append(row[i])
...     transposed.append(transposed_row)
...
&gt;&gt;&gt; transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</code></pre><hr>
<p>del 语句</p>
<p>使用 del 语句可以从一个列表中依索引而不是值来删除一个元素。这与使用<br>pop() 返回一个值不同。可以用 del<br>语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：</p>
<pre><code>&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; a
[1, 66.25, 333, 333, 1234.5]
&gt;&gt;&gt; del a[2:4]
&gt;&gt;&gt; a
[1, 66.25, 1234.5]
&gt;&gt;&gt; del a[:]
&gt;&gt;&gt; a
[]
</code></pre><p>也可以用 del 删除实体变量：</p>
<pre><code>&gt;&gt;&gt; del a
</code></pre><hr>
<p>元组和序列</p>
<p>元组由若干逗号分隔的值组成，例如：</p>
<pre><code>&gt;&gt;&gt; t = 12345, 54321, &apos;hello!&apos;
&gt;&gt;&gt; t[0]
12345
&gt;&gt;&gt; t
(12345, 54321, &apos;hello!&apos;)
&gt;&gt;&gt; # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
&gt;&gt;&gt; u
((12345, 54321, &apos;hello!&apos;), (1, 2, 3, 4, 5))
</code></pre><p>如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号，<br>不过括号通常是必须的（如果元组是更大的表达式的一部分）。</p>
<hr>
<p>集合</p>
<p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。</p>
<p>可以用大括号({})创建集合。注意：如果要创建一个空集合，你必须用 set()<br>而不是 {} ；后者创建一个空的字典，下一节我们会介绍这个数据结构。</p>
<p>以下是一个简单的演示：</p>
<pre><code>&gt;&gt;&gt; basket = {&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;}
&gt;&gt;&gt; print(basket)                      # 删除重复的
{&apos;orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;}
&gt;&gt;&gt; &apos;orange&apos; in basket                 # 检测成员
True
&gt;&gt;&gt; &apos;crabgrass&apos; in basket
False

&gt;&gt;&gt; # 以下演示了两个集合的操作
...
&gt;&gt;&gt; a = set(&apos;abracadabra&apos;)
&gt;&gt;&gt; b = set(&apos;alacazam&apos;)
&gt;&gt;&gt; a                                  # a 中唯一的字母
{&apos;a&apos;, &apos;r&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;}
&gt;&gt;&gt; a - b                              # 在 a 中的字母，但不在 b 中
{&apos;r&apos;, &apos;d&apos;, &apos;b&apos;}
&gt;&gt;&gt; a | b                              # 在 a 或 b 中的字母
{&apos;a&apos;, &apos;c&apos;, &apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;}
&gt;&gt;&gt; a &amp; b                              # 在 a 和 b 中都有的字母
{&apos;a&apos;, &apos;c&apos;}
&gt;&gt;&gt; a ^ b                              # 在 a 或 b 中的字母，但不同时在 a 和 b 中
{&apos;r&apos;, &apos;d&apos;, &apos;b&apos;, &apos;m&apos;, &apos;z&apos;, &apos;l&apos;}
</code></pre><p>集合也支持推导式：</p>
<pre><code>&gt;&gt;&gt; a = {x for x in &apos;abracadabra&apos; if x not in &apos;abc&apos;}
&gt;&gt;&gt; a
{&apos;r&apos;, &apos;d&apos;}
</code></pre><hr>
<p>字典</p>
<p>另一个非常有用的 Python 内建数据类型是字典。</p>
<p>序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。</p>
<p>理解字典的最佳方式是把它看做无序的键=&gt;值对集合。在同一个字典之内，关键字必须是互不相同。</p>
<p>一对大括号创建一个空的字典：{}。</p>
<p>这是一个字典运用的简单例子：</p>
<pre><code>&gt;&gt;&gt; tel = {&apos;jack&apos;: 4098, &apos;sape&apos;: 4139}
&gt;&gt;&gt; tel[&apos;guido&apos;] = 4127
&gt;&gt;&gt; tel
{&apos;sape&apos;: 4139, &apos;guido&apos;: 4127, &apos;jack&apos;: 4098}
&gt;&gt;&gt; tel[&apos;jack&apos;]
4098
&gt;&gt;&gt; del tel[&apos;sape&apos;]
&gt;&gt;&gt; tel[&apos;irv&apos;] = 4127
&gt;&gt;&gt; tel
{&apos;guido&apos;: 4127, &apos;irv&apos;: 4127, &apos;jack&apos;: 4098}
&gt;&gt;&gt; list(tel.keys())
[&apos;irv&apos;, &apos;guido&apos;, &apos;jack&apos;]
&gt;&gt;&gt; sorted(tel.keys())
[&apos;guido&apos;, &apos;irv&apos;, &apos;jack&apos;]
&gt;&gt;&gt; &apos;guido&apos; in tel
True
&gt;&gt;&gt; &apos;jack&apos; not in tel
False
</code></pre><p>构造函数 dict()<br>直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：</p>
<pre><code>&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)])
{&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}
</code></pre><p>此外，字典推导可以用来创建任意键和值的表达式词典：</p>
<pre><code>&gt;&gt;&gt; {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
</code></pre><p>如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：</p>
<pre><code>&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)
{&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127}
</code></pre><hr>
<p>遍历技巧</p>
<p>在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：</p>
<pre><code>&gt;&gt;&gt; knights = {&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;}
&gt;&gt;&gt; for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
</code></pre><p>在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：</p>
<pre><code>&gt;&gt;&gt; for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):
...     print(i, v)
...
0 tic
1 tac
2 toe
</code></pre><p>同时遍历两个或更多的序列，可以使用 zip() 组合：</p>
<pre><code>&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]
&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]
&gt;&gt;&gt; for q, a in zip(questions, answers):
...     print(&apos;What is your {0}?  It is {1}.&apos;.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
</code></pre><p>要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：</p>
<pre><code>&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
</code></pre><p>要按顺序遍历一个序列，使用 sorted()<br>函数返回一个已排序的序列，并不修改原值：</p>
<pre><code>&gt;&gt;&gt; basket = [&apos;apple&apos;, &apos;orange&apos;, &apos;apple&apos;, &apos;pear&apos;, &apos;orange&apos;, &apos;banana&apos;]
&gt;&gt;&gt; for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
</code></pre><hr>
<p>参阅文档</p>
<ul>
<li><a href="/python3/python3-list.html">Python3 列表</a></li>
<li><a href="/python3/python3-tuple.html">Python3 元组</a></li>
<li><a href="/python3/python3-dictionary.html">Python3 字典</a></li>
</ul>
<hr>
<h2 id="Python3-模块"><a href="#Python3-模块" class="headerlink" title="Python3 模块"></a>Python3 模块</h2><p>在前面的几个章节中我们脚本上是用 python 解释器来编程，如果你从 Python解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p>
<p>为此 Python提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p>
<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用<br>python 标准库的方法。</p>
<p>下面是一个使用 python 标准库中模块的例子。</p>
<pre><code>#!/usr/bin/python3
# 文件名: using_sys.py

import sys

print(&apos;命令行参数如下:&apos;)
for i in sys.argv:
   print(i)

print(&apos;\n\nPython 路径为：&apos;, sys.path, &apos;\n&apos;)
</code></pre><p>执行结果如下所示：</p>
<pre><code>$ python using_sys.py 参数1 参数2
命令行参数如下:
using_sys.py
参数1
参数2


Python 路径为： [&apos;/root&apos;, &apos;/usr/lib/python3.4&apos;, &apos;/usr/lib/python3.4/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python3.4/lib-dynload&apos;, &apos;/usr/local/lib/python3.4/dist-packages&apos;, &apos;/usr/lib/python3/dist-packages&apos;]
</code></pre><ul>
<li>1、import sys 引入 python 标准库中的 sys.py<br>模块；这是引入某一模块的方法。</li>
<li>2、sys.argv 是一个包含命令行参数的列表。</li>
<li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li>
</ul>
<hr>
<p>import 语句</p>
<p>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：</p>
<pre><code>import module1[, module2[,... moduleN]
</code></pre><p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块<br>support，需要把命令放在脚本的顶端：</p>
<p>support.py 文件代码为：</p>
<pre><code>#!/usr/bin/python3
# Filename: support.py

def print_func( par ):
    print (&quot;Hello : &quot;, par)
    return
</code></pre><p>test.py 引入 support 模块：</p>
<pre><code>#!/usr/bin/python3
# Filename: test.py

# 导入模块
import support

# 现在可以调用模块里包含的函数了
support.print_func(&quot;Runoob&quot;)
</code></pre><p>以上实例输出结果：</p>
<pre><code>$ python3 test.py
Hello :  Runoob
</code></pre><p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p>
<p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p>
<p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。</p>
<p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p>
<p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&apos;&apos;, &apos;/usr/lib/python3.4&apos;, &apos;/usr/lib/python3.4/plat-x86_64-linux-gnu&apos;, &apos;/usr/lib/python3.4/lib-dynload&apos;, &apos;/usr/local/lib/python3.4/dist-packages&apos;, &apos;/usr/lib/python3/dist-packages&apos;]
&gt;&gt;&gt;
</code></pre><p>sys.path<br>输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p>
<p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p>
<p>现在，在解释器的当前目录或者 sys.path<br>中的一个目录里面来创建一个fibo.py的文件，代码如下：</p>
<pre><code># 斐波那契(fibonacci)数列模块

def fib(n):    # 定义到 n 的斐波那契数列
    a, b = 0, 1
    while b &lt; n:
        print(b, end=&apos; &apos;)
        a, b = b, a+b
    print()

def fib2(n): # 返回到 n 的斐波那契数列
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
</code></pre><p>然后进入Python解释器，使用下面的命令导入这个模块：</p>
<pre><code>&gt;&gt;&gt; import fibo
</code></pre><p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p>
<p>可以使用模块名称来访问函数：</p>
<pre><code>&gt;&gt;&gt; fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
&gt;&gt;&gt; fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
&gt;&gt;&gt; fibo.__name__
&apos;fibo&apos;
</code></pre><p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p>
<pre><code>&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><hr>
<p>from…import 语句</p>
<p>Python的from语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<pre><code>from modname import name1[, name2[, ... nameN]]
</code></pre><p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p>
<pre><code>&gt;&gt;&gt; from fibo import fib, fib2
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p>
<p>\</p>
<hr>
<p>From…import* 语句</p>
<p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<pre><code>from modname import *
</code></pre><p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<hr>
<p>深入模块</p>
<p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</p>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。</p>
<p>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。</p>
<p>从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname<br>这样的表示法来访问模块内的函数。</p>
<p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用<br>import<br>来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
<p>还有一种导入的方法，可以使用 import<br>直接把模块内（函数，变量的）名称导入到当前操作模块。比如:</p>
<pre><code>&gt;&gt;&gt; from fibo import fib, fib2
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo<br>这个名称是没有定义的）。</p>
<p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p>
<pre><code>&gt;&gt;&gt; from fibo import *
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</code></pre><p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况，<br>Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p>
<hr>
<p>__name__属性</p>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code>#!/usr/bin/python3
# Filename: using_name.py

if __name__ == &apos;__main__&apos;:
   print(&apos;程序自身在运行&apos;)
else:
   print(&apos;我来自另一模块&apos;)
</code></pre><p>运行输出如下：</p>
<pre><code>$ python using_name.py
</code></pre><p>程序自身在运行</p>
<pre><code>$ python
&gt;&gt;&gt; import using_name
我来自另一模块
&gt;&gt;&gt;
</code></pre><p><strong>说明：</strong><br>每个模块都有一个__name__属性，当其值是’__main__‘时，表明该模块自身在运行，否则是被引入。</p>
<hr>
<p>dir() 函数</p>
<p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fibo)</div><div class="line">[<span class="string">'__name__'</span>, <span class="string">'fib'</span>, <span class="string">'fib2'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sys)  </div><div class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>,</div><div class="line"> <span class="string">'__package__'</span>, <span class="string">'__stderr__'</span>, <span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>,</div><div class="line"> <span class="string">'_clear_type_cache'</span>, <span class="string">'_current_frames'</span>, <span class="string">'_debugmallocstats'</span>, <span class="string">'_getframe'</span>,</div><div class="line"> <span class="string">'_home'</span>, <span class="string">'_mercurial'</span>, <span class="string">'_xoptions'</span>, <span class="string">'abiflags'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>,</div><div class="line"> <span class="string">'base_exec_prefix'</span>, <span class="string">'base_prefix'</span>, <span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>,</div><div class="line"> <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>, <span class="string">'copyright'</span>, <span class="string">'displayhook'</span>,</div><div class="line"> <span class="string">'dont_write_bytecode'</span>, <span class="string">'exc_info'</span>, <span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>,</div><div class="line"> <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'flags'</span>, <span class="string">'float_info'</span>, <span class="string">'float_repr_style'</span>,</div><div class="line"> <span class="string">'getcheckinterval'</span>, <span class="string">'getdefaultencoding'</span>, <span class="string">'getdlopenflags'</span>,</div><div class="line"> <span class="string">'getfilesystemencoding'</span>, <span class="string">'getobjects'</span>, <span class="string">'getprofile'</span>, <span class="string">'getrecursionlimit'</span>,</div><div class="line"> <span class="string">'getrefcount'</span>, <span class="string">'getsizeof'</span>, <span class="string">'getswitchinterval'</span>, <span class="string">'gettotalrefcount'</span>,</div><div class="line"> <span class="string">'gettrace'</span>, <span class="string">'hash_info'</span>, <span class="string">'hexversion'</span>, <span class="string">'implementation'</span>, <span class="string">'int_info'</span>,</div><div class="line"> <span class="string">'intern'</span>, <span class="string">'maxsize'</span>, <span class="string">'maxunicode'</span>, <span class="string">'meta_path'</span>, <span class="string">'modules'</span>, <span class="string">'path'</span>,</div><div class="line"> <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>, <span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>,</div><div class="line"> <span class="string">'setcheckinterval'</span>, <span class="string">'setdlopenflags'</span>, <span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>,</div><div class="line"> <span class="string">'setswitchinterval'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>,</div><div class="line"> <span class="string">'thread_info'</span>, <span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>]</div></pre></td></tr></table></figure>
<p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:</p>
<pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; import fibo
&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; dir() # 得到一个当前模块中定义的属性列表
[&apos;__builtins__&apos;, &apos;__name__&apos;, &apos;a&apos;, &apos;fib&apos;, &apos;fibo&apos;, &apos;sys&apos;]
&gt;&gt;&gt; a = 5 # 建立一个新的变量 &apos;a&apos;
&gt;&gt;&gt; dir()
[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;a&apos;, &apos;sys&apos;]
&gt;&gt;&gt;
&gt;&gt;&gt; del a # 删除变量名a
&gt;&gt;&gt;
&gt;&gt;&gt; dir()
[&apos;__builtins__&apos;, &apos;__doc__&apos;, &apos;__name__&apos;, &apos;sys&apos;]
&gt;&gt;&gt;
</code></pre><hr>
<p>标准模块</p>
<p>Python 本身带着一些标准的模块库，在 Python<br>库参考文档中将会介绍到（就是后面的”库参考文档”）。</p>
<p>有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。</p>
<p>这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg<br>这个模块就只会提供给 Windows 系统。</p>
<p>应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量<br>sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p>
<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
&apos;&gt;&gt;&gt; &apos;
&gt;&gt;&gt; sys.ps2
&apos;... &apos;
&gt;&gt;&gt; sys.ps1 = &apos;C&gt; &apos;
C&gt; print(&apos;Yuck!&apos;)
Yuck!
C&gt;
</code></pre><hr>
<p>包</p>
<p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>
<p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p>
<p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p>
<p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p>
<p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如：<br>.wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p>
<p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所你还需要一组怎么也写不完的模块来处理这些操作。</p>
<p>这里给出了一种可能的包结构（在分层的文件系统中）:</p>
<pre><code>sound/                          顶层包
      __init__.py               初始化 sound 包
      formats/                  文件格式转换子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  声音效果子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  filters 子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</code></pre><p>在导入一个包的时候，Python 会根据 sys.path<br>中的目录来寻找这个包中包含的子目录。</p>
<p>目录只有包含一个叫做 __init__.py的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做string）不小心的影响搜索路径中的有效模块。</p>
<p>最简单的情况，放一个空的:file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的）__all__变量赋值。</p>
<p>用户可以每次只导入一个包里面的特定模块，比如:</p>
<pre><code>import sound.effects.echo
</code></pre><p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p>
<pre><code>sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre><p>还有一种导入子模块的方法是:</p>
<pre><code>from sound.effects import echo
</code></pre><p>这同样会导入子模块:<br>echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p>
<pre><code>echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre><p>还有一种变化就是直接导入一个函数或者变量:</p>
<pre><code>from sound.effects.echo import echofilter
</code></pre><p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter()<br>函数:</p>
<pre><code>echofilter(input, output, delay=0.7, atten=4)
</code></pre><p>注意当使用from package import<br>item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p>
<p>import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError<br>异常被抛出了。</p>
<p>反之，如果使用形如import<br>item.subitem.subsubitem这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p>
<hr>
<p>从一个包中导入*</p>
<p>设想一下，如果我们使用 from sound.effects import *会发生什么？</p>
<p>Python会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。</p>
<p>但是很不幸，这个方法在Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。</p>
<p>在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是Echo 甚至 ECHO。</p>
<p>（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的8+3 命名规则对长模块名称的处理会把问题搞得更纠结。</p>
<p>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。</p>
<p>导入语句遵循如下规则：如果包定义文件 __init__.py 存在一个叫做<br>__all__ 的列表变量，那么在使用 from package import *<br>的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>作为包的作者，可别忘了在更新包之后保证 __all__<br>也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/__init__.py中包含如下代码:</p>
<pre><code>__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre><p>这表示当你使用<code>from sound.effects import *</code>这种用法时，你只会导入包里面这三个子模块。</p>
<p>如果 <strong>__all__</strong> 真的没有定义，那么使用<strong>from sound.effects import<br>*</strong>这种语法的时候，就不会导入包 sound.effects<br>里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行__init__.py里定义的初始化代码）。</p>
<p>这会把 __init__.py<br>里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<pre><code>import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code></pre><p>这个例子中，在执行from…import前，包sound.effects中的echo和surround模块都被导入到当前的命名空间中了。（当然如果定义了__all__就更没问题了）</p>
<p>通常我们并不主张使用*这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>记住，使用from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder<br>要使用包sound.effects中的模块echo，你就要写成 from sound.effects import<br>echo。</p>
<pre><code>from . import echo
from .. import formats
from ..filters import equalizer
</code></pre><p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”__main__“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p>
<p>包还提供一个额外的属性__path__。这是一个目录列表，里面每一个包含的目录都有为这个包服务的__init__.py，你得在其他__init__.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>
<p>这个功能并不常用，一般用来扩展包里面的模块。</p>
<hr>
<h2 id="Python3-输入和输出"><a href="#Python3-输入和输出" class="headerlink" title="Python3 输入和输出"></a>Python3 输入和输出</h2><p>在前面几个章节中，我们其实已经接触了 Python<br>的输入输出的功能。本章节我们将具体介绍 Python 的输入输出。</p>
<hr>
<p>输出格式美化</p>
<p>Python两种输出值的方式: 表达式语句和 print() 函数。</p>
<p>第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout引用。</p>
<p>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</p>
<p>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。</p>
<ul>
<li><strong>str()：</strong> 函数返回一个用户易读的表达形式。</li>
<li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li>
</ul>
<p>— 例如</p>
<pre><code>&gt;&gt;&gt; s = &apos;Hello, Runoob&apos;
&gt;&gt;&gt; str(s)
&apos;Hello, Runoob&apos;
&gt;&gt;&gt; repr(s)
&quot;&apos;Hello, Runoob&apos;&quot;
&gt;&gt;&gt; str(1/7)
&apos;0.14285714285714285&apos;
&gt;&gt;&gt; x = 10 * 3.25
&gt;&gt;&gt; y = 200 * 200
&gt;&gt;&gt; s = &apos;x 的值为： &apos; + repr(x) + &apos;,  y 的值为：&apos; + repr(y) + &apos;...&apos;
&gt;&gt;&gt; print(s)
x 的值为： 32.5,  y 的值为：40000...
&gt;&gt;&gt; #  repr() 函数可以转义字符串中的特殊字符
... hello = &apos;hello, runoob\n&apos;
&gt;&gt;&gt; hellos = repr(hello)
&gt;&gt;&gt; print(hellos)
&apos;hello, runoob\n&apos;
&gt;&gt;&gt; # repr() 的参数可以是 Python 的任何对象
... repr((x, y, (&apos;Google&apos;, &apos;Runoob&apos;)))
&quot;(32.5, 40000, (&apos;Google&apos;, &apos;Runoob&apos;))&quot;
</code></pre><p>这里有两种方式输出一个平方与立方的表:</p>
<pre><code>&gt;&gt;&gt; for x in range(1, 11):
...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=&apos; &apos;)
...     # 注意前一行 &apos;end&apos; 的使用
...     print(repr(x*x*x).rjust(4))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000

&gt;&gt;&gt; for x in range(1, 11):
...     print(&apos;{0:2d} {1:3d} {2:4d}&apos;.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
</code></pre><p><strong>注意：</strong>在第一个例子中, 每列间的空格由 print() 添加。</p>
<p>这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右,<br>并在左边填充空格。</p>
<p>还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西,<br>它们仅仅返回新的字符串。</p>
<p>另一个方法 zfill(), 它会在数字的左边填充 0，如下所示：</p>
<pre><code>&gt;&gt;&gt; &apos;12&apos;.zfill(5)
&apos;00012&apos;
&gt;&gt;&gt; &apos;-3.14&apos;.zfill(7)
&apos;-003.14&apos;
&gt;&gt;&gt; &apos;3.14159265359&apos;.zfill(5)
&apos;3.14159265359&apos;
</code></pre><p>str.format() 的基本使用如下:</p>
<pre><code>&gt;&gt;&gt; print(&apos;{}网址： &quot;{}!&quot;&apos;.format(&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;))
菜鸟教程网址： &quot;www.runoob.com!&quot;
</code></pre><p>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。</p>
<p>在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：</p>
<pre><code>&gt;&gt;&gt; print(&apos;{0} 和 {1}&apos;.format(&apos;Google&apos;, &apos;Runoob&apos;))
Google 和 Runoob
&gt;&gt;&gt; print(&apos;{1} 和 {0}&apos;.format(&apos;Google&apos;, &apos;Runoob&apos;))
Runoob 和 Google
</code></pre><p>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p>
<pre><code>&gt;&gt;&gt; print(&apos;{name}网址： {site}&apos;.format(name=&apos;菜鸟教程&apos;, site=&apos;www.runoob.com&apos;))
菜鸟教程网址： www.runoob.com
</code></pre><p>位置及关键字参数可以任意的结合:</p>
<pre><code>&gt;&gt;&gt; print(&apos;站点列表 {0}, {1}, 和 {other}。&apos;.format(&apos;Google&apos;, &apos;Runoob&apos;,
                                                       other=&apos;Taobao&apos;))
站点列表 Google, Runoob, 和 Taobao。
</code></pre><p>‘!a’ (使用 ascii()), ‘!s’ (使用 str()) 和 ‘!r’ (使用 repr())<br>可以用于在格式化某个值之前对其进行转化:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; print(&apos;常量 PI 的值近似为： {}。&apos;.format(math.pi))
常量 PI 的值近似为： 3.141592653589793。
&gt;&gt;&gt; print(&apos;常量 PI 的值近似为： {!r}。&apos;.format(math.pi))
常量 PI 的值近似为： 3.141592653589793。
</code></pre><p>可选项 ‘:’ 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。<br>下面的例子将 Pi 保留到小数点后三位：</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; print(&apos;常量 PI 的值近似为 {0:.3f}。&apos;.format(math.pi))
常量 PI 的值近似为 3.142。
</code></pre><p>在 ‘:’ 后传入一个整数, 可以保证该域至少有这么多的宽度。<br>用于美化表格时很有用。</p>
<pre><code>&gt;&gt;&gt; table = {&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3}
&gt;&gt;&gt; for name, number in table.items():
...     print(&apos;{0:10} ==&gt; {1:10d}&apos;.format(name, number))
...
Runoob     ==&gt;          2
Taobao     ==&gt;          3
Google     ==&gt;          1
</code></pre><p>如果你有一个很长的格式化字符串, 而你不想将它们分开,<br>那么在格式化时通过变量名而非位置会是很好的事情。</p>
<p>最简单的就是传入一个字典, 然后使用方括号 ‘[]‘ 来访问键值 :</p>
<pre><code>&gt;&gt;&gt; table = {&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3}
&gt;&gt;&gt; print(&apos;Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; &apos;
          &apos;Taobao: {0[Taobao]:d}&apos;.format(table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre><p>也可以通过在 table 变量前使用 ‘**‘ 来实现相同的功能：</p>
<pre><code>&gt;&gt;&gt; table = {&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3}
&gt;&gt;&gt; print(&apos;Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}&apos;.format(**table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre><hr>
<p>旧式字符串格式化</p>
<p>% 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf()<br>式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:</p>
<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; print(&apos;常量 PI 的值近似为：%5.3f。&apos; % math.pi)
常量 PI 的值近似为：3.142。
</code></pre><p>因为 str.format() 比较新的函数， 大多数的 Python 代码仍然使用 %<br>操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().</p>
<hr>
<p>读取键盘输入</p>
<p>Python提供了 input()<br>置函数从标准输入读入一行文本，默认的标准输入是键盘。</p>
<p>input 可以接收一个Python表达式作为输入，并将运算结果返回。</p>
<pre><code>#!/usr/bin/python3

str = input(&quot;请输入：&quot;);
print (&quot;你输入的内容是: &quot;, str)
</code></pre><p>这会产生如下的对应着输入的结果：</p>
<pre><code>请输入：菜鸟教程
你输入的内容是:  菜鸟教程
</code></pre><hr>
<p>读和写文件</p>
<p>open() 将会返回一个 file 对象，基本语法格式如下:</p>
<pre><code>open(filename, mode)
</code></pre><ul>
<li>filename：filename 变量是一个包含了你要访问的文件名称的字符串值。</li>
<li>mode：mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li>
</ul>
<p>不同模式打开文件的完全列表：</p>
<p>  模式   描述</p>
<hr>
<p>  r      以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。<br>  rb     以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。<br>  r+     打开一个文件用于读写。文件指针将会放在文件的开头。<br>  rb+    以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。<br>  w      打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>  wb     以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>  w+     打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>  wb+    以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。<br>  a      打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>  ab     以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。<br>  a+     打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<br>  ab+    以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</p>
<p>以下实例将字符串写入到文件 foo.txt 中：</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)

f.write( &quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot; )

# 关闭打开的文件
f.close()
</code></pre><ul>
<li>第一个参数为要打开的文件名。</li>
<li>第二个参数描述文件如何使用的字符。 mode 可以是 ‘r’ 如果文件只读, ‘w’<br>只用于写 (如果存在同名文件则将被删除), 和 ‘a’ 用于追加文件内容;<br>所写的任何数据都会被自动增加到末尾. ‘r+’ 同时用于读写。 mode<br>参数是可选的; ‘r’ 将是默认值。</li>
</ul>
<p>此时打开文件 foo.txt,显示如下：</p>
<pre><code>$ cat /tmp/foo.txt
Python 是一个非常好的语言。
是的，的确非常好!!
</code></pre><hr>
<p>文件对象的方法</p>
<p>本节中剩下的例子假设已经创建了一个称为 f 的文件对象。</p>
<hr>
<p>f.read()</p>
<p>为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据,<br>然后作为字符串或字节对象返回。</p>
<p>size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负,<br>那么该文件的所有内容都将被读取并且返回。</p>
<p>以下实例假定文件 foo.txt 已存在（上面实例中已创建）：</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)

str = f.read()
print(str)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>Python 是一个非常好的语言。
是的，的确非常好!!
</code></pre><hr>
<p>f.readline()</p>
<p>f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline()<br>如果返回一个空字符串, 说明已经已经读取到最后一行。</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)

str = f.readline()
print(str)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>Python 是一个非常好的语言。
</code></pre><hr>
<p>f.readlines()</p>
<p>f.readlines() 将返回该文件中包含的所有行。</p>
<p>如果设置可选参数 sizehint, 则读取指定长度的字节,<br>并且将这些字节按行分割。</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)

str = f.readlines()
print(str)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>[&apos;Python 是一个非常好的语言。\n&apos;, &apos;是的，的确非常好!!\n&apos;]
</code></pre><p>另一种方式是迭代一个文件对象然后读取每行:</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)

for line in f:
    print(line, end=&apos;&apos;)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>Python 是一个非常好的语言。
是的，的确非常好!!
</code></pre><p>这个方法很简单, 但是并没有提供一个很好的控制。 因为两者的处理机制不同,<br>最好不要混用。</p>
<hr>
<p>f.write()</p>
<p>f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)

num = f.write( &quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot; )
print(num)
# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，输出结果为：</p>
<pre><code>29
</code></pre><p>如果要写入一些不是字符串的东西, 那么将需要先进行转换:</p>
<pre><code>#!/usr/bin/python3

# 打开一个文件
f = open(&quot;/tmp/foo1.txt&quot;, &quot;w&quot;)

value = (&apos;www.runoob.com&apos;, 14)
s = str(value)
f.write(s)

# 关闭打开的文件
f.close()
</code></pre><p>执行以上程序，打开 foo1.txt 文件：</p>
<pre><code>$ cat /tmp/foo1.txt
(&apos;www.runoob.com&apos;, 14)
</code></pre><hr>
<p>f.tell()</p>
<p>f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。</p>
<hr>
<p>f.seek()</p>
<p>如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。</p>
<p>from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2<br>表示文件的结尾，例如：</p>
<ul>
<li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符</li>
<li>seek(x,1) ： 表示从当前位置往后移动x个字符</li>
<li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li>
</ul>
<p>from_what 值为默认为0，即文件开头。下面给出一个完整的例子：</p>
<pre><code>&gt;&gt;&gt; f = open(&apos;/tmp/foo.txt&apos;, &apos;rb+&apos;)
&gt;&gt;&gt; f.write(b&apos;0123456789abcdef&apos;)
16
&gt;&gt;&gt; f.seek(5)     # 移动到文件的第六个字节
5
&gt;&gt;&gt; f.read(1)
b&apos;5&apos;
&gt;&gt;&gt; f.seek(-3, 2) # 移动到文件的倒数第三字节
13
&gt;&gt;&gt; f.read(1)
b&apos;d&apos;
</code></pre><hr>
<p>f.close()</p>
<p>在文本文件中 (那些打开文件的模式下没有 b 的),<br>只会相对于文件起始位置进行定位。<br>当你处理完一个文件后, 调用 f.close()<br>来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。</p>
<pre><code>&gt;&gt;&gt; f.close()
&gt;&gt;&gt; f.read()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
ValueError: I/O operation on closed file
&lt;pre&gt;
&lt;p&gt;
当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:&lt;/p&gt;
&lt;pre&gt;
&gt;&gt;&gt; with open(&apos;/tmp/foo.txt&apos;, &apos;r&apos;) as f:
...     read_data = f.read()
&gt;&gt;&gt; f.closed
True
</code></pre><p>文件对象还有其他方法, 如 isatty() 和 trucate(), 但这些通常比较少用。</p>
<hr>
<p>pickle 模块</p>
<p>python的pickle模块实现了基本的数据序列和反序列化。</p>
<p>通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</p>
<p>通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p>
<p>基本接口：</p>
<pre><code>pickle.dump(obj, file, [,protocol])
</code></pre><p>有了 pickle 这个对象, 就能对 file 以读取的形式打开:</p>
<pre><code>x = pickle.load(file)
</code></pre><p><strong>注解：</strong>从 file 中读取一个字符串，并将它重构为原来的python对象。</p>
<p><strong>file:</strong> 类文件对象，有read()和readline()接口。</p>
<p>实例1：</p>
<pre><code>#!/usr/bin/python3
import pickle

# 使用pickle模块将数据对象保存到文件
data1 = {&apos;a&apos;: [1, 2.0, 3, 4+6j],
         &apos;b&apos;: (&apos;string&apos;, u&apos;Unicode string&apos;),
         &apos;c&apos;: None}

selfref_list = [1, 2, 3]
selfref_list.append(selfref_list)

output = open(&apos;data.pkl&apos;, &apos;wb&apos;)

# Pickle dictionary using protocol 0.
pickle.dump(data1, output)

# Pickle the list using the highest protocol available.
pickle.dump(selfref_list, output, -1)

output.close()
</code></pre><p>实例2：</p>
<pre><code>#!/usr/bin/python3
import pprint, pickle

#使用pickle模块从文件中重构python对象
pkl_file = open(&apos;data.pkl&apos;, &apos;rb&apos;)

data1 = pickle.load(pkl_file)
pprint.pprint(data1)

data2 = pickle.load(pkl_file)
pprint.pprint(data2)

pkl_file.close()
</code></pre><hr>
<h2 id="Python3-File"><a href="#Python3-File" class="headerlink" title="Python3 File"></a>Python3 File</h2><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p>
<p>+———————————–+———————————–+<br>| 序号                              | 方法及描述                        |<br>+===================================+===================================+<br>| 1                                 | <a href="/python3/python3-f |
|                                   | ile-close.html">file.close()</a>                   |<br>|                                   |                                   |<br>|                                   | 关闭文件。关闭后文件不能再进行读写操作。 |<br>+———————————–+———————————–+<br>| 2                                 | <a href="/python3/python3-f |
|                                   | ile-flush.html">file.flush()</a>                   |<br>|                                   |                                   |<br>|                                   | 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, |<br>|                                   |                                   |<br>|                                   | 而不是被动的等待输出缓冲区写入。  |<br>+———————————–+———————————–+<br>| 3                                 | <a href="/python3/python3- |
|                                   | file-fileno.html">file.fileno()</a>                 |<br>|                                   |                                   |<br>|                                   | 返回一个整型的文件描述符(file     |<br>|                                   | descriptor FD 整型),              |<br>|                                   | 可以用在如os模块的read方法等一些底层操作上。 |<br>+———————————–+———————————–+<br>| 4                                 | <a href="/python3/python3- |
|                                   | file-isatty.html">file.isatty()</a>                 |<br>|                                   |                                   |<br>|                                   | 如果文件连接到一个终端设备返回    |<br>|                                   | True，否则返回 False。            |<br>+———————————–+———————————–+<br>| 5                                 | <a href="/python3/python3-fi |
|                                   | le-next.html">file.next()</a>                     |<br>|                                   |                                   |<br>|                                   | 返回文件下一行。                  |<br>+———————————–+———————————–+<br>| 6                                 | <a href="/python3/py |
|                                   | thon3-file-read.html">file.read([size])</a>             |<br>|                                   |                                   |<br>|                                   | 从文件读取指定的字节数，如果未给定或为负则读取所有。 |<br>+———————————–+———————————–+<br>| 7                                 | <a href="/python |
|                                   | 3/python3-file-readline.html">file.readline([size])</a>     |<br>|                                   |                                   |<br>|                                   | 读取整行，包括 “\n” 字符。       |<br>+———————————–+———————————–+<br>| 8                                 | <a href="/p |
|                                   | ython3/python3-file-readlines.htm |
|                                   | l">file.readlines([sizehint])</a>                                |<br>|                                   |                                   |<br>|                                   | 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约 |<br>|                                   | 为sizeint字节的行,                |<br>|                                   | 实际读取值可能比sizhint较大,      |<br>|                                   | 因为需要填充缓冲区。              |<br>+———————————–+———————————–+<br>| 9                                 | <a href="/python3/python3-file- |
|                                   | seek.html">file.seek(offset[,              |<br>|                                   | whence])</a>                        |<br>|                                   |                                   |<br>|                                   | 设置文件当前位置                  |<br>+———————————–+———————————–+<br>| 10                                | <a href="/python3/python3-fi |
|                                   | le-tell.html">file.tell()</a>                     |<br>|                                   |                                   |<br>|                                   | 返回文件当前位置。                |<br>+———————————–+———————————–+<br>| 11                                | <a href="/python |
|                                   | 3/python3-file-truncate.html">file.truncate([size])</a>     |<br>|                                   |                                   |<br>|                                   | 截取文件，截取的字节通过size指定，默认为当前文件位置。 |<br>+———————————–+———————————–+<br>| 12                                | <a href="/python3/python |
|                                   | 3-file-write.html">file.write(str)</a>                |<br>|                                   |                                   |<br>|                                   | 将字符串写入文件，没有返回值。    |<br>+———————————–+———————————–+<br>| 13                                | <a href="/pyth |
|                                   | on3/python3-file-writelines.html">file.writelines(sequence)</a> |<br>|                                   |                                   |<br>|                                   | 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符 |<br>|                                   | 。                                |<br>+———————————–+———————————–+</p>
<hr>
<h2 id="Python3-OS"><a href="#Python3-OS" class="headerlink" title="Python3 OS"></a>Python3 OS</h2><p>os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>os.access(path, mode)</td>
<td>检验权限模式</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>os.chdir(path)</td>
<td>改变当前工作目录</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>os.chflags(path, flags)</td>
<td>设置路径的标记为数字标记。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>os.chmod(path, mode)</td>
<td>更改权限</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>os.chown(path, uid, gid)</td>
<td>更改文件所有者</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td>os.chroot(path)</td>
<td>改变当前进程的根目录</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td>os.close(fd)</td>
<td>关闭文件描述符 fd</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td>os.closerange(fd_low, fd_high)</td>
<td>关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td>os.dup(fd)</td>
<td>复制文件描述符 fd</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td>os.dup2(fd, fd2)</td>
<td>将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td>os.fchdir(fd)</td>
<td>通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td>os.fchmod(fd, mode)</td>
<td>改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td>os.fchown(fd, uid, gid)</td>
<td>修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td>os.fdatasync(fd)</td>
<td>强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td>os.fdopen(fd[, mode[, bufsize]])</td>
<td>通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td>os.fpathconf(fd, name)</td>
<td>返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td>os.fstat(fd)</td>
<td>返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td>os.fstatvfs(fd)</td>
<td>返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td>os.fsync(fd)</td>
<td>强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td>os.ftruncate(fd, length)</td>
<td>裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td>os.getcwd()</td>
<td>返回当前工作目录</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td>os.getcwdu()</td>
<td>返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td>os.isatty(fd)</td>
<td>如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td>os.lchflags(path, flags)</td>
<td>设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td>os.lchmod(path, mode)</td>
<td>修改连接文件权限</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td>os.lchown(path, uid, gid)</td>
<td>更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td>os.link(src, dst)</td>
<td>创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td>os.listdir(path)</td>
<td>返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td>os.lseek(fd, pos, how)</td>
<td>设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td>os.lstat(path)</td>
<td>像stat(),但是没有软链接</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td>os.major(device)</td>
<td>从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td style="text-align:center">32</td>
<td>os.makedev(major, minor)</td>
<td>以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td>os.makedirs(path[, mode])</td>
<td>递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td style="text-align:center">34</td>
<td>os.minor(device)</td>
<td>从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td style="text-align:center">35</td>
<td>os.mkdir(path[, mode])</td>
<td>以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td style="text-align:center">36</td>
<td>os.mkfifo(path[, mode])</td>
<td>创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td style="text-align:center">37</td>
<td>os.mknod(filename[, mode=0600, device])</td>
<td>创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td style="text-align:center">38</td>
<td>os.open(file, flags[, mode])</td>
<td>打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td style="text-align:center">39</td>
<td>os.openpty()</td>
<td>打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td>os.pathconf(path, name)</td>
<td>返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td style="text-align:center">41</td>
<td>os.pipe()</td>
<td>创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td>
</tr>
<tr>
<td style="text-align:center">42</td>
<td>os.popen(command[, mode[, bufsize]])</td>
<td>从一个 command 打开一个管道</td>
</tr>
<tr>
<td style="text-align:center">43</td>
<td>os.read(fd, n)</td>
<td>从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td style="text-align:center">44</td>
<td>os.readlink(path)</td>
<td>返回软链接所指向的文件</td>
</tr>
<tr>
<td style="text-align:center">45</td>
<td>os.remove(path)</td>
<td>删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td style="text-align:center">46</td>
<td>os.removedirs(path)</td>
<td>递归删除目录。</td>
</tr>
<tr>
<td style="text-align:center">47</td>
<td>os.rename(src, dst)</td>
<td>重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td>os.renames(old, new)</td>
<td>递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td style="text-align:center">49</td>
<td>os.rmdir(path)</td>
<td>删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
</tbody>
</table>
<p>50<br>os.stat(path)</p>
<p>获取path指定的路径的信息，功能等同于C API中的stat()系统调用。<br>51<br>os.stat_float_times([newvalue])<br>决定stat_result是否以float对象显示时间戳<br>52<br>os.statvfs(path)</p>
<p>获取指定路径的文件系统统计信息<br>53<br>os.symlink(src, dst)</p>
<p>创建一个软链接<br>54<br>os.tcgetpgrp(fd)</p>
<p>返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组<br>55<br>os.tcsetpgrp(fd, pg)</p>
<p>设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。<br>56<br>os.tempnam([dir[, prefix]])</p>
<p>返回唯一的路径名用于创建临时文件。<br>57<br>os.tmpfile()</p>
<p>返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。<br>58<br>os.tmpnam()</p>
<p>为创建一个临时文件返回一个唯一的路径<br>59<br>os.ttyname(fd)</p>
<p>返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。<br>60<br>os.unlink(path)</p>
<p>删除文件路径<br>61<br>os.utime(path, times)</p>
<p>返回指定的path文件的访问和修改的时间。<br>62<br>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</p>
<p>输出在文件夹中的文件名通过在树中游走，向上或者向下。<br>63<br>os.write(fd, str)</p>
<p>写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</p>
<hr>
<h2 id="Python3-错误和异常"><a href="#Python3-错误和异常" class="headerlink" title="Python3 错误和异常"></a>Python3 错误和异常</h2><p>作为Python初学者，在刚学习Python编程时，经常会看到一些报错信息，在前面我们没有提及，这章节我们会专门介绍。</p>
<p>Python有两种错误很容易辨认：语法错误和异常。</p>
<hr>
<p>Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例</p>
<pre><code>&gt;&gt;&gt; while True print(&apos;Hello world&apos;)
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
    while True print(&apos;Hello world&apos;)
                   ^
SyntaxError: invalid syntax
</code></pre><p>这个例子中，函数 print() 被检查到有错误，是它前面缺少了一个冒号（:）。</p>
<p>语法分析器指出了出错的一行，并且在最先找到的错误的位置标记了一个小小的箭头。</p>
<hr>
<p>异常</p>
<p>即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。</p>
<p>大多数的异常都不会被程序处理，都以错误信息的形式展现在这里:</p>
<pre><code>&gt;&gt;&gt; 10 * (1/0)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
ZeroDivisionError: division by zero
&gt;&gt;&gt; 4 + spam*3
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: name &apos;spam&apos; is not defined
&gt;&gt;&gt; &apos;2&apos; + 2
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
TypeError: Can&apos;t convert &apos;int&apos; object to str implicitly
</code></pre><p>异常以不同的类型出现，这些类型都作为信息的一部分打印出来: 例子中的类型有<br>ZeroDivisionError，NameError 和 TypeError。</p>
<p>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p>
<hr>
<p>异常处理</p>
<p>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用<br>Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个<br>KeyboardInterrupt 异常。</p>
<pre><code>&gt;&gt;&gt; while True:
        try:
            x = int(input(&quot;Please enter a number: &quot;))
            break
        except ValueError:
            print(&quot;Oops!  That was no valid number.  Try again   &quot;)
</code></pre><p>try语句按照如下方式工作；</p>
<ul>
<li>首先，执行try子句（在关键字try和关键字except之间的语句）</li>
<li>如果没有异常发生，忽略except子句，try子句执行后结束。</li>
<li>如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和    except 之后的名称相符，那么对应的except子句将被执行。最后执行 try    语句之后的代码。</li>
<li>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。</li>
</ul>
<p>一个 try语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p>
<p>处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try<br>的处理程序中的异常。</p>
<p>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p>
<pre><code>except (RuntimeError, TypeError, NameError):
    pass
</code></pre><p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p>
<pre><code>import sys

try:
    f = open(&apos;myfile.txt&apos;)
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print(&quot;OS error: {0}&quot;.format(err))
except ValueError:
    print(&quot;Could not convert data to an integer.&quot;)
except:
    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])
    raise
</code></pre><p>try except<br>语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。例如:</p>
<pre><code>for arg in sys.argv[1:]:
    try:
        f = open(arg, &apos;r&apos;)
    except IOError:
        print(&apos;cannot open&apos;, arg)
    else:
        print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;)
        f.close()
</code></pre><p>使用 else 子句比把所有的语句都放在 try<br>子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。</p>
<p>异常处理并不仅仅处理那些直接发生在try子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p>
<pre><code>&gt;&gt;&gt; def this_fails():
        x = 1/0

&gt;&gt;&gt; try:
        this_fails()
    except ZeroDivisionError as err:
        print(&apos;Handling run-time error:&apos;, err)

Handling run-time error: int division or modulo by zero
</code></pre><hr>
<p>抛出异常</p>
<p>Python 使用 raise 语句抛出一个指定的异常。例如:</p>
<pre><code>&gt;&gt;&gt; raise NameError(&apos;HiThere&apos;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: HiThere
</code></pre><p>raise<br>唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是<br>Exception 的子类）。</p>
<p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise<br>语句就可以再次把它抛出。</p>
<pre><code>&gt;&gt;&gt; try:
        raise NameError(&apos;HiThere&apos;)
    except NameError:
        print(&apos;An exception flew by!&apos;)
        raise

An exception flew by!
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in ?
NameError: HiThere
</code></pre><hr>
<p>用户自定义异常</p>
<p>你可以通过创建一个新的exception类来拥有自己的异常。异常应该继承自<br>Exception 类，或者直接继承，或者间接继承，例如:</p>
<pre><code>&gt;&gt;&gt; class MyError(Exception):
        def __init__(self, value):
            self.value = value
        def __str__(self):
            return repr(self.value)

&gt;&gt;&gt; try:
        raise MyError(2*2)
    except MyError as e:
        print(&apos;My exception occurred, value:&apos;, e.value)

My exception occurred, value: 4
&gt;&gt;&gt; raise MyError(&apos;oops!&apos;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
__main__.MyError: &apos;oops!&apos;
</code></pre><p>在这个例子中，类 Exception 默认的 __init__() 被覆盖。</p>
<p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p>
<pre><code>class Error(Exception):
    &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;
    pass

class InputError(Error):
    &quot;&quot;&quot;Exception raised for errors in the input.

    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    &quot;&quot;&quot;

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class TransitionError(Error):
    &quot;&quot;&quot;Raised when an operation attempts a state transition that&apos;s not
    allowed.

    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    &quot;&quot;&quot;

    def __init__(self, previous, next, message):
        self.previous = previous
        self.next = next
        self.message = message
</code></pre><p>大多数的异常的名字都以”Error”结尾，就跟标准的异常命名一样。</p>
<hr>
<p>定义清理行为</p>
<p>try<br>语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。<br>例如:</p>
<pre><code>&gt;&gt;&gt; try:
        raise KeyboardInterrupt
    finally:
        print(&apos;Goodbye, world!&apos;)

Goodbye, world!
KeyboardInterrupt
</code></pre><p>以上例子不管try子句里面有没有发生异常，finally子句都会执行。</p>
<p>如果一个异常在 try 子句里（或者在 except 和 else子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。</p>
<p>下面是一个更加复杂的例子（在同一个 try 语句里包含 except 和 finally<br>子句）:</p>
<pre><code>&gt;&gt;&gt; def divide(x, y):
        try:
            result = x / y
        except ZeroDivisionError:
            print(&quot;division by zero!&quot;)
        else:
            print(&quot;result is&quot;, result)
        finally:
            print(&quot;executing finally clause&quot;)

&gt;&gt;&gt; divide(2, 1)
result is 2.0
executing finally clause
&gt;&gt;&gt; divide(2, 0)
division by zero!
executing finally clause
&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)
executing finally clause
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
  File &quot;&lt;stdin&gt;&quot;, line 3, in divide
TypeError: unsupported operand type(s) for /: &apos;str&apos; and &apos;str&apos;
</code></pre><hr>
<p>预定义的清理行为</p>
<p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。</p>
<p>这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p>
<pre><code>for line in open(&quot;myfile.txt&quot;):
    print(line, end=&quot;&quot;)
</code></pre><p>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。</p>
<p>关键词 with<br>语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p>
<pre><code>with open(&quot;myfile.txt&quot;) as f:
    for line in f:
        print(line, end=&quot;&quot;)
</code></pre><p>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。</p>
<hr>
<h2 id="Python3-面向对象"><a href="#Python3-面向对象" class="headerlink" title="Python3 面向对象"></a>Python3 面向对象</h2><p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。</p>
<p>如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。</p>
<p>接下来我们先来简单的了解下面向对象的一些基本特征。</p>
<hr>
<p>面向对象技术简介</p>
<ul>
<li><strong>类(Class):</strong><br>用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>
<li><strong>实例变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li>
<li><strong>继承：</strong>即一个派生类（derived class）继承基类（base<br>class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li>
<li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li>
<li><strong>方法：</strong>类中定义的函数。</li>
<li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ul>
<p>和其它编程语言相比，Python在尽可能不增加新的语法和语义的情况下加入了类机制。</p>
<p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p>
<p>对象可以包含任意数量和类型的数据。</p>
<hr>
<p>类定义</p>
<p>语法格式如下：</p>
<pre><code>class ClassName:
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p>
<hr>
<p>类对象</p>
<p>类对象支持两种操作：属性引用和实例化。</p>
<p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p>
<p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p>
<pre><code>#!/usr/bin/python3

class MyClass:
    &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;
    i = 12345
    def f(self):
        return &apos;hello world&apos;

# 实例化类
x = MyClass()

# 访问类的属性和方法
print(&quot;MyClass 类的属性 i 为：&quot;, x.i)
print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())
</code></pre><p>实例化类：</p>
<pre><code># 实例化类
x = MyClass()
# 访问类的属性和方法
</code></pre><p>以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。</p>
<p>执行以上程序输出结果为：</p>
<pre><code>MyClass 类的属性 i 为： 12345
MyClass 类的方法 f 输出为： hello world
</code></pre><hr>
<p>很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为<br>__init__() 的特殊方法（构造方法），像下面这样：</p>
<pre><code>def __init__(self):
    self.data = []
</code></pre><p>类定义了 __init__() 方法的话，类的实例化操作会自动调用<br>__init__() 方法。所以在下例中，可以这样创建一个新的实例:</p>
<pre><code>x = MyClass()
</code></pre><p>当然， __init__() 方法可以有参数，参数通过 __init__()<br>传递到类的实例化操作上。例如:</p>
<pre><code>&gt;&gt;&gt; class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
...
&gt;&gt;&gt; x = Complex(3.0, -4.5)
&gt;&gt;&gt; x.r, x.i
(3.0, -4.5)
</code></pre><hr>
<p>self代表类的实例，而非类</p>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>,<br>按照惯例它的名称是 self。</p>
<pre><code>class Test:
    def prt(self):
        print(self)
        print(self.__class__)

t = Test()
t.prt()
</code></pre><p>以上实例执行结果为：</p>
<pre><code>&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
</code></pre><p>从执行结果可以很明显的看出，self<br>代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。</p>
<p>self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</p>
<pre><code>class Test:
    def prt(runoob):
        print(runoob)
        print(runoob.__class__)

t = Test()
t.prt()
</code></pre><p>以上实例执行结果为：</p>
<pre><code>&lt;__main__.Test instance at 0x100771878&gt;
__main__.Test
</code></pre><hr>
<p>类的方法</p>
<p>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数:</p>
<pre><code>#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &apos;&apos;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

# 实例化类
p = people(&apos;runoob&apos;,10,30)
p.speak()
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>runoob 说: 我 10 岁。
</code></pre><hr>
<p>继承</p>
<p>Python<br>同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p>
<pre><code>class DerivedClassName(BaseClassName1):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索即方法在子类中未找到时，从左到右查找基类中是否包含方法。</p>
<p>BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p>
<pre><code>class DerivedClassName(modname.BaseClassName):
</code></pre><hr>
<p>实例</p>
<pre><code>#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &apos;&apos;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

#单继承示例
class student(people):
    grade = &apos;&apos;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))



s = student(&apos;ken&apos;,10,60,3)
s.speak()
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>ken 说: 我 10 岁了，我在读 3 年级
</code></pre><hr>
<p>多继承</p>
<p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p>
<pre><code>class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</code></pre><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索<br>即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>
<pre><code>#!/usr/bin/python3

#类定义
class people:
    #定义基本属性
    name = &apos;&apos;
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))

#单继承示例
class student(people):
    grade = &apos;&apos;
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))

#另一个类，多重继承之前的准备
class speaker():
    topic = &apos;&apos;
    name = &apos;&apos;
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))

#多重继承
class sample(speaker,student):
    a =&apos;&apos;
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)

test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre><hr>
<p>方法重写</p>
<p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p>
<pre><code>#!/usr/bin/python3

class Parent:        # 定义父类
   def myMethod(self):
      print (&apos;调用父类方法&apos;)

class Child(Parent): # 定义子类
   def myMethod(self):
      print (&apos;调用子类方法&apos;)

c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>调用子类方法
</code></pre><hr>
<p>类属性与方法</p>
<p>— 类的私有属性</p>
<p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时<br><strong>self.__private_attrs</strong>。</p>
<p>— 类的方法</p>
<p>在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数</p>
<p>— 类的私有方法</p>
<p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用<br><strong>self.__private_methods</strong>。</p>
<p>— 实例</p>
<p>类的私有属性实例如下：</p>
<pre><code>#!/usr/bin/python3

class JustCounter:
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量

    def count(self):
        self.__secretCount += 1
        self.publicCount += 1
        print (self.__secretCount)

counter = JustCounter()
counter.count()
counter.count()
print (counter.publicCount)
print (counter.__secretCount)  # 报错，实例不能访问私有变量
</code></pre><p>执行以上程序输出结果为：</p>
<pre><code>1
2
2
Traceback (most recent call last):
  File &quot;test.py&quot;, line 16, in &lt;module&gt;
    print (counter.__secretCount)  # 报错，实例不能访问私有变量
AttributeError: &apos;JustCounter&apos; object has no attribute &apos;__secretCount&apos;
</code></pre><p>类的私有方法实例如下：</p>
<pre><code>#!/usr/bin/python3

class Site:
    def __init__(self, name, url):
        self.name = name       # public
        self.__url = url   # private

    def who(self):
        print(&apos;name  : &apos;, self.name)
        print(&apos;url : &apos;, self.__url)

    def __foo(self):          # 私有方法
        print(&apos;这是私有方法&apos;)

    def foo(self):            # 公共方法
        print(&apos;这是公共方法&apos;)
        self.__foo()

x = Site(&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;)
x.who()        # 正常输出
x.foo()        # 正常输出
x.__foo()      # 报错
</code></pre><p>以上实例执行结果：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/05/F5C2A308-3A88-42B4-B575-C719EB8F1CC4.jpg" alt="">{width=”70%”}</p>
<p>— 类的专有方法：</p>
<ul>
<li><strong>__init__ :</strong> 构造函数，在生成对象时调用</li>
<li><strong>__del__ :</strong> 析构函数，释放对象时使用</li>
<li><strong>__repr__ :</strong> 打印，转换</li>
<li><strong>__setitem__ :</strong> 按照索引赋值</li>
<li><strong>__getitem__:</strong> 按照索引获取值</li>
<li><strong>__len__:</strong> 获得长度</li>
<li><strong>__cmp__:</strong> 比较运算</li>
<li><strong>__call__:</strong> 函数调用</li>
<li><strong>__add__:</strong> 加运算</li>
<li><strong>__sub__:</strong> 减运算</li>
<li><strong>__mul__:</strong> 乘运算</li>
<li><strong>__div__:</strong> 除运算</li>
<li><strong>__mod__:</strong> 求余运算</li>
<li><strong>__pow__:</strong> 称方</li>
</ul>
<p>— 运算符重载</p>
<p>Python同样支持运算符重载，我么可以对类的专有方法进行重载，实例如下：</p>
<pre><code>#!/usr/bin/python3

class Vector:
   def __init__(self, a, b):
      self.a = a
      self.b = b

   def __str__(self):
      return &apos;Vector (%d, %d)&apos; % (self.a, self.b)

   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)

v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)
</code></pre><p>以上代码执行结果如下所示:</p>
<pre><code>Vector(7,8)
</code></pre><hr>
<h2 id="Python3-标准库概览"><a href="#Python3-标准库概览" class="headerlink" title="Python3 标准库概览"></a>Python3 标准库概览</h2><p>到python官网下载http: // pypi.python.org / pypi / xlrd模块安装，前提是已经安装了python<br>环境。</p>
<p>二、使用介绍</p>
<p>1、导入模块</p>
<p>import xlrd</p>
<p>2、打开Excel文件读取数据</p>
<p>data = xlrd.open_workbook(‘excelFile.xls’)</p>
<p>3、使用技巧</p>
<p>获取一个工作表</p>
<p>table = data.sheets()[0]  # 通过索引顺序获取</p>
<p>table = data.sheet_by_index(0)  # 通过索引顺序获取</p>
<p>table = data.sheet_by_name(u’Sheet1’)  # 通过名称获取</p>
<p>获取整行和整列的值（数组）<br>　　<br>table.row_values(i)</p>
<p>table.col_values(i)</p>
<p>获取行数和列数<br>　　<br>nrows = table.nrows</p>
<p>ncols = table.ncols</p>
<p>循环行列表数据<br>for i in range(nrows):<br>    print<br>table.row_values(i)</p>
<p>单元格<br>cell_A1 = table.cell(0, 0).value</p>
<p>cell_C4 = table.cell(2, 3).value</p>
<p>使用行列索引<br>cell_A1 = table.row(0)[0].value</p>
<p>cell_A2 = table.col(1)[0].value</p>
<p>简单的写入</p>
<pre><code>row = 0

col = 0

# 类型 0 empty,1 string, 2 number, 3 date, 4 boolean, 5 error
</code></pre><p>ctype = 1<br>value = ‘单元格的值’</p>
<p>xf = 0  # 扩展的格式化</p>
<p>table.put_cell(row, col, ctype, value, xf)</p>
<p>table.cell(0, 0)  # 单元格的值’</p>
<p>table.cell(0, 0).value  # 单元格的值’</p>
<pre><code># -*- coding: utf-8 -*-
</code></pre><p>import  xdrlib ,sys<br>import xlrd<br>def open_excel(file= ‘file.xls’):<br>    try:<br>        data = xlrd.open_workbook(file)<br>        return data<br>    except Exception,e:<br>        print str(e)</p>
<pre><code>#根据索引获取Excel表格中的数据   参数:file：Excel文件路径     colnameindex：表头列名所在行的所以  ，by_index：表的索引
</code></pre><p>def excel_table_byindex(file= ‘file.xls’,colnameindex=0,by_index=0):<br>    data = open_excel(file)<br>    table = data.sheets()[by_index]<br>    nrows = table.nrows #行数<br>    ncols = table.ncols #列数<br>    colnames =  table.row_values(colnameindex) #某一行数据<br>    list =[]<br>    for rownum in range(1,nrows):</p>
<pre><code>     row = table.row_values(rownum)
     if row:
         app = {}
         for i in range(len(colnames)):
            app[colnames[i]] = row[i]
         list.append(app)
return list

#根据名称获取Excel表格中的数据   参数:file：Excel文件路径     colnameindex：表头列名所在行的所以  ，by_name：Sheet1名称
</code></pre><p>def excel_table_byname(file= ‘file.xls’,colnameindex=0,by_name=u’Sheet1’):<br>    data = open_excel(file)<br>    table = data.sheet_by_name(by_name)<br>    nrows = table.nrows #行数<br>    colnames =  table.row_values(colnameindex) #某一行数据<br>    list =[]<br>    for rownum in range(1,nrows):<br>         row = table.row_values(rownum)<br>         if row:<br>             app = {}<br>             for i in range(len(colnames)):<br>                app[colnames[i]] = row[i]<br>             list.append(app)<br>    return list</p>
<p>def main():<br>   tables = excel_table_byindex()<br>   for row in tables:<br>       print row</p>
<p>   tables = excel_table_byname()<br>   for row in tables:<br>       print row</p>
<p>if <strong>name</strong>==”<strong>main</strong>“:<br>    main()</p>
<hr>
<h2 id="Python3-扩展包"><a href="#Python3-扩展包" class="headerlink" title="Python3 扩展包"></a>Python3 扩展包</h2><hr>
<p>thread 多线程(MT)</p>
<pre><code>&gt;&gt; import thread
</code></pre><p>Python 的 threading 模块</p>
<p>Python 供了几个用于多线程编程的模块，包括 thread, threading 和 Queue 等。thread 和 threading 模块允许程序员创建和管理线程。thread 模块 供了基本的线程和锁的支持，而 threading 供了更高级别，功能更强的线程管理的功能。Queue 模块允许用户创建一个可以用于多个线程之间 共享数据的队列数据结构。</p>
<p>出于以下几点考虑，我们不建议您使用 thread 模块。</p>
<ul>
<li><p>更高级别的 threading 模块更为先 进，对线程的支持更为完善，而且使用 thread 模块里的属性有可能会与 threading 出现冲突。其次， 低级别的 thread 模块的同步原语很少(实际上只有一个)，而 threading 模块则有很多。</p>
</li>
<li><p>对于你的进程什么时候应该结束完全没有控制，当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作。至少 threading 模块能确保重要的子线程退出后进程才退出。</p>
</li>
</ul>
<hr>
<p>thread 模块</p>
<p>除了产生线程外，thread 模块也提供了基本的同步数 据结构锁对象(lock object，也叫原语锁，简单锁，互斥锁，互斥量，二值信号量)。</p>
<p>thread 模块函数</p>
<pre><code>start_new_thread(function, args, kwargs=None)：产生一个新的线程，在新线程中用指定的参数和可选的 kwargs 来调用这个函数。

allocate_lock()：分配一个 LockType 类型的锁对象

exit()：让线程退出

acquire(wait=None)：尝试获取锁对象

locked()：如果获取了锁对象返回 True，否则返回 False

release()：释放锁
</code></pre><p>下面是一个使用 thread 的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> thread</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, nsec, lock)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'start loop %s at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    sleep(nsec)</div><div class="line"></div><div class="line">    print(<span class="string">'loop %s done at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    <span class="comment"># 每个线程都会被分配一个事先已经获得的锁，在 sleep()的时间到了之后就释放 相应的锁以通知主线程，这个线程已经结束了。</span></div><div class="line"></div><div class="line">    lock.release()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'starting at:'</span>, time())</div><div class="line"></div><div class="line">    locks = []</div><div class="line"></div><div class="line">    nloops = range(len(loops))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># 调用 thread.allocate_lock()函数创建一个锁的列表</span></div><div class="line"></div><div class="line">        lock = thread.allocate_lock()</div><div class="line"></div><div class="line">        <span class="comment"># 分别调用各个锁的 acquire()函数获得, 获得锁表示“把锁锁上”</span></div><div class="line"></div><div class="line">        lock.acquire()</div><div class="line"></div><div class="line">        locks.append(lock)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># 创建线程，每个线程都用各自的循环号，睡眠时间和锁为参数去调用 loop()函数</span></div><div class="line"></div><div class="line">        thread.start_new_thread(loop, (, iloops[], ilocks[i]))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># 在线程结束的时候，线程要自己去做解锁操作</span></div><div class="line"></div><div class="line">        <span class="comment"># 当前循环只是坐在那一直等(达到暂停主 线程的目的)，直到两个锁都被解锁为止才继续运行。</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> locks[].ilocked(): <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    print(<span class="string">'all DONE at:'</span>, time())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>start_new_thread()要求一定要有前两个参数。所以，就算我们想要运行的函数不要参数，也要传一个空的元组。</p>
<p>为什么要加上sleep(6)这一句呢? 因为，如果我们没有让主线程停下来，那主线程就会运行下一条语句，显示 “all done”，然后就关闭运行着 loop()和 loop1()的两个线程，退出了。</p>
<p>我们有没有更好的办法替换使用sleep() 这种不靠谱的同步方式呢？答案是使用锁，使用了锁，我们就可以在两个线程都退出之后马上退出。</p>
<p>为什么我们不在创建锁的循环里创建线程呢?有以下几个原因:</p>
<ul>
<li><p>我们想到实现线程的同步，所以要让“所有的马同时冲出栅栏”。</p>
</li>
<li><p>获取锁要花一些时间，如果你的 线程退出得“太快”，可能会导致还没有获得锁，线程就已经结束了的情况。</p>
</li>
</ul>
<hr>
<p>threading 模块</p>
<p>threading 模块不仅提供了 Thread 类，还 供了各 种非常好用的同步机制。</p>
<p>下面是threading 模块里所有的对象：</p>
<ul>
<li><p>Thread： 表示一个线程的执行的对象</p>
</li>
<li><p>Lock： 锁原语对象(跟 thread 模块里的锁对象相同)</p>
</li>
<li><p>RLock： 可重入锁对象。使单线程可以再次获得已经获得了的锁(递归锁定)。</p>
</li>
<li><p>Condition： 条件变量对象能让一个线程停下来，等待其它线程满足了某个“条件”。如，状态的改变或值的改变。</p>
</li>
<li><p>Event： 通用的条件变量。多个线程可以等待某个事件的发生，在事件发生后， 所有的线程都会被激活。</p>
</li>
<li><p>Semaphore： 为等待锁的线程 供一个类似“等候室”的结构</p>
</li>
<li><p>BoundedSemaphore： 与 Semaphore 类似，只是它不允许超过初始值</p>
</li>
<li><p>Timer： 与 Thread 相似，只是，它要等待一段时间后才开始运行。</p>
</li>
</ul>
<p>守护线程</p>
<p>另一个避免使用 thread 模块的原因是，它不支持守护线程。当主线程退出时，所有的子线程不 论它们是否还在工作，都会被强行退出。有时，我们并不期望这种行为，这时，就引入了守护线程 的概念</p>
<p>threading 模块支持守护线程，它们是这样工作的:守护线程一般是一个等待客户请求的服务器， 如果没有客户 出请求，它就在那等着。如果你设定一个线程为守护线程，就表示你在说这个线程 是不重要的，在进程退出的时候，不用等待这个线程退出。</p>
<p>如果你的主线程要退出的时候，不用等待那些子线程完成，那就设定这些线程的 daemon 属性。 即，在线程开始(调用 thread.start())之前，调用setDaemon()函数设定线程的 daemon 标志 (thread.setDaemon(True))就表示这个线程“不重要”</p>
<p>如果你想要等待子线程完成再退出，那就什么都不用做，或者显式地调用 thread.setDaemon(False)以保证其 daemon 标志为 False。你可以调用thread.isDaemon()函数来判 断其 daemon 标志的值。新的子线程会继承其父线程的 daemon 标志。整个 Python 会在所有的非守护 线程退出后才会结束,即进程中没有非守护线程存在的时候才结束。</p>
<hr>
<p>Thread 类</p>
<p>Thread类提供了以下方法:</p>
<ul>
<li><p>run(): 用以表示线程活动的方法。</p>
</li>
<li><p>start():启动线程活动。</p>
</li>
<li><p>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</p>
</li>
<li><p>is_alive(): 返回线程是否活动的。</p>
</li>
<li><p>name(): 设置/返回线程名。</p>
</li>
<li><p>daemon(): 返回/设置线程的 daemon 标志，一定要在调用 start()函数前设置</p>
</li>
</ul>
<p>用 Thread 类，你可以用多种方法来创建线程。我们在这里介绍三种比较相像的方法。</p>
<ul>
<li><p>创建一个Thread的实例，传给它一个函数</p>
</li>
<li><p>创建一个Thread的实例，传给它一个可调用的类对象</p>
</li>
<li><p>从Thread派生出一个子类，创建一个这个子类的实例</p>
</li>
</ul>
<p>下边是三种不同方式的创建线程的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, nsec, lock)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'start loop %s at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    sleep(nsec)</div><div class="line"></div><div class="line">    print(<span class="string">'loop %s done at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    <span class="comment"># 每个线程都会被分配一个事先已经获得的锁，在 sleep()的时间到了之后就释放 相应的锁以通知主线程，这个线程已经结束了。</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'starting at:'</span>, time())</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line">    nloops = range(len(loops))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">         = tthreading.Thread(target=loop, args=(, iloops[i]))</div><div class="line"></div><div class="line">        threads.append()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    tfor  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># start threads</span></div><div class="line"></div><div class="line">        threads[].istart()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># wait for all</span></div><div class="line"></div><div class="line">        <span class="comment"># join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。</span></div><div class="line"></div><div class="line">        <span class="comment"># 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为"spinlock")</span></div><div class="line"></div><div class="line">        threads[].ijoin()  <span class="comment"># threads to finish</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    print(<span class="string">'all DONE at:'</span>, time())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>与传一个函数很相似的另一个方法是在创建线程的时候，传一个可调用的类的实例供线程启动 的时候执行——这是多线程编程的一个更为面向对象的方法。相对于一个或几个函数来说，由于类 对象里可以使用类的强大的功能，可以保存更多的信息，这种方法更为灵活</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadFunc</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">""</span>)</span>:</span></div><div class="line"></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">        self.args = args</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。</span></div><div class="line"></div><div class="line">        self.func(*self.args)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, nsec)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'start loop %s at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    sleep(nsec)</div><div class="line"></div><div class="line">    print(<span class="string">'loop %s done at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'starting at:'</span>, time())</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line">    nloops = range(len(loops))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        t = Thread(target=ThreadFunc(loop, (, iloops[i]), loop.__name__))</div><div class="line"></div><div class="line">        threads.append()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    tfor  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># start threads</span></div><div class="line"></div><div class="line">        threads[].istart()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># wait for all</span></div><div class="line"></div><div class="line">        <span class="comment"># join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。</span></div><div class="line"></div><div class="line">        <span class="comment"># 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为"spinlock")</span></div><div class="line"></div><div class="line">        threads[].ijoin()  <span class="comment"># threads to finish</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    print(<span class="string">'all DONE at:'</span>, time())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>最后一个例子介绍如何子类化 Thread 类，这与上一个例子中的创建一个可调用的类非常像。使 用子类化创建线程(第 29-30 行)使代码看上去更清晰明了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">loops = [<span class="number">4</span>, <span class="number">2</span>]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">""</span>)</span>:</span></div><div class="line"></div><div class="line">        super(MyThread, self).__init__()</div><div class="line"></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">        self.args = args</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getResult</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。</span></div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">'starting'</span>, self.name, <span class="string">'at:'</span>, time()</div><div class="line"></div><div class="line">        self.res = self.func(*self.args)</div><div class="line"></div><div class="line">        <span class="keyword">print</span> self.name, <span class="string">'finished at:'</span>, time()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">(nloop, nsec)</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'start loop %s at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line">    sleep(nsec)</div><div class="line"></div><div class="line">    print(<span class="string">'loop %s done at: %s'</span> % (nloop, time()))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    print(<span class="string">'starting at:'</span>, time())</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line">    nloops = range(len(loops))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        t = MyThread(loop, (, iloops[i]), loop.__name__)</div><div class="line"></div><div class="line">        threads.append()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    tfor  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># start threads</span></div><div class="line"></div><div class="line">        threads[].istart()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> inloops:</div><div class="line"></div><div class="line">        <span class="comment"># wait for all</span></div><div class="line"></div><div class="line">        <span class="comment"># join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。</span></div><div class="line"></div><div class="line">        <span class="comment"># 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为"spinlock")</span></div><div class="line"></div><div class="line">        threads[].ijoin()  <span class="comment"># threads to finish</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    print(<span class="string">'all DONE at:'</span>, time())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>除了各种同步对象和线程对象外，threading 模块还 供了一些函数。</p>
<ul>
<li><p>active_count(): 当前活动的线程对象的数量</p>
</li>
<li><p>current_thread(): 返回当前线程对象</p>
</li>
<li><p>enumerate(): 返回当前活动线程的列表</p>
</li>
<li><p>settrace(func): 为所有线程设置一个跟踪函数</p>
</li>
<li><p>setprofile(func): 为所有线程设置一个 profile 函数</p>
</li>
</ul>
<hr>
<p>Lock &amp; RLock</p>
<p>原语锁定是一个同步原语，状态是锁定或未锁定。两个方法acquire()和release() 用于加锁和释放锁。</p>
<p>RLock 可重入锁是一个类似于Lock对象的同步原语，但同一个线程可以多次调用。</p>
<p>Lock 不支持递归加锁，也就是说即便在同 线程中，也必须等待锁释放。通常建议改 RLock， 它会处理 “owning thread” 和 “recursion level” 状态，对于同 线程的多次请求锁 为，只累加计数器。每次调 release() 将递减该计数器，直到 0 时释放锁，因此 acquire() 和 release() 必须 要成对出现。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqOVvR9rGR63zFhl4GsziamgiaK57Bz5e5DQwnkcJFESr6INibDrNtZYh3Gbibh6ibzTE2P57aVmspLO2w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<hr>
<p>Event</p>
<p>事件用于在线程间通信。一个线程发出一个信号，其他一个或多个线程等待。</p>
<p>Event 通过通过 个内部标记来协调多线程运 。 法 wait() 阻塞线程执 ，直到标记为 True。 set() 将标记设为 True，clear() 更改标记为 False。isSet() 用于判断标记状态。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqOVvR9rGR63zFhl4GsziamgzmVv3krdzPmiaEghdLfxx8ic37iaBMnPianJYiby96KbGiaMUJjxYVHmPFcw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<hr>
<p>Condition</p>
<p>条件变量和 Lock 参数一样，也是一个，也是一个同步原语，当需要线程关注特定的状态变化或事件的发生时使用这个锁定。</p>
<p>可以认为，除了Lock带有的锁定池外，Condition还包含一个等待池，池中的线程处于状态图中的等待阻塞状态，直到另一个线程调用notify()/notifyAll()通知；得到通知后线程进入锁定池等待锁定。</p>
<p>构造方法：</p>
<p>Condition([lock/rlock])</p>
<p>Condition 有以下这些方法：</p>
<ul>
<li><p>acquire([timeout])/release(): 调用关联的锁的相应方法。</p>
</li>
<li><p>wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。</p>
</li>
<li><p>notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。</p>
</li>
<li><p>notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。</p>
</li>
</ul>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqOVvR9rGR63zFhl4GsziamgOKibrfhsMI7icHyVNVH54HcIoia5gmuwfIT9ibEbCEmA0zAMt3GycO5Ltg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>只有获取锁的线程才能调用 wait() 和 notify()，因此必须在锁释放前调用。</p>
<p>当 wait() 释放锁后，其他线程也可进入 wait 状态。notifyAll() 激活所有等待线程，让它们去抢锁然后完成后续执行。</p>
<p>生产者-消费者问题和 Queue 模块</p>
<p>现在我们用一个经典的(生产者消费者)例子来介绍一下 Queue模块。</p>
<p>生产者消费者的场景是： 生产者生产货物，然后把货物放到一个队列之类的数据结构中，生产货物所要花费的时间无法预先确定。消费者消耗生产者生产的货物的时间也是不确定的。</p>
<p>常用的 Queue 模块的属性:</p>
<ul>
<li><p>queue(size): 创建一个大小为size的Queue对象。</p>
</li>
<li><p>qsize(): 返回队列的大小(由于在返回的时候，队列可能会被其它线程修改，所以这个值是近似值)</p>
</li>
<li><p>empty(): 如果队列为空返回 True，否则返回 False</p>
</li>
<li><p>full(): 如果队列已满返回 True，否则返回 False</p>
</li>
<li><p>put(item,block=0): 把item放到队列中，如果给了block(不为0)，函数会一直阻塞到队列中有空间为止</p>
</li>
<li><p>get(block=0): 从队列中取一个对象，如果给了 block(不为 0)，函数会一直阻塞到队列中有对象为止</p>
</li>
</ul>
<p>Queue 模块可以用来进行线程间通讯，让各个线程之间共享数据。</p>
<p>现在，我们创建一个队列，让 生产者(线程)把新生产的货物放进去供消费者(线程)使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</div><div class="line"></div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, time</div><div class="line"></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args, name=<span class="string">""</span>)</span>:</span></div><div class="line"></div><div class="line">        super(MyThread, self).__init__()</div><div class="line"></div><div class="line">        self.name = name</div><div class="line"></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">        self.args = args</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getResult</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> self.res</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        <span class="comment"># 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。</span></div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">'starting'</span>, self.name, <span class="string">'at:'</span>, time()</div><div class="line"></div><div class="line">        self.res = self.func(*self.args)</div><div class="line"></div><div class="line">        <span class="keyword">print</span> self.name, <span class="string">'finished at:'</span>, time()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># writeQ()和 readQ()函数分别用来把对象放入队列和消耗队列中的一个对象。在这里我们使用 字符串'xxx'来表示队列中的对象。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeQ</span><span class="params">(queue)</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">'producing object for Q...'</span></div><div class="line"></div><div class="line">    queue.put(<span class="string">'xxx'</span>, <span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">"size now"</span>, queue.qsize()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">readQ</span><span class="params">(queue)</span>:</span></div><div class="line"></div><div class="line">    queue.get(<span class="number">1</span>)</div><div class="line"></div><div class="line">    print(<span class="string">"consumed object from Q... size now"</span>, queue.qsize())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(queue, loops)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># writer()函数只做一件事，就是一次往队列中放入一个对象，等待一会，然后再做同样的事</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> irange(loops):</div><div class="line"></div><div class="line">        writeQ(queue)</div><div class="line"></div><div class="line">        sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(queue, loops)</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># reader()函数只做一件事，就是一次从队列中取出一个对象，等待一会，然后再做同样的事</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> irange(loops):</div><div class="line"></div><div class="line">        readQ(queue)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 设置有多少个线程要被运行</span></div><div class="line"></div><div class="line">funcs = [writer, reader]</div><div class="line"></div><div class="line">nfuncs = range(len(funcs))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    nloops = randint(<span class="number">10</span>, <span class="number">20</span>)</div><div class="line"></div><div class="line">    q = Queue(<span class="number">32</span>)</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> infuncs:</div><div class="line"></div><div class="line">        t = MyThread(funcs[], (, qinloops), funcs[i].__name__)</div><div class="line"></div><div class="line">        threads.append()</div><div class="line"></div><div class="line"></div><div class="line">    tfor  <span class="keyword">in</span> infuncs:</div><div class="line"></div><div class="line">        threads[].istart()</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">for</span>  <span class="keyword">in</span> infuncs:</div><div class="line"></div><div class="line">        threads[].ijoin()</div><div class="line"></div><div class="line">        <span class="keyword">print</span> threads[].igetResult()</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">'all DONE'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">    main()</div></pre></td></tr></table></figure>
<hr>
<p>FAQ</p>
<p>进程与线程。线程与进程的区别是什么?</p>
<p>进程(有时被称为重量级进程)是程序的一次 执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。</p>
<p>线程(有时被称为轻量级进程)跟进程有些相似，不同的是，所有的线程运行在同一个进程中， 共享相同的运行环境。它们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。</p>
<p>这篇文章很好的解释了 线程和进程的区别，推荐阅读: <a href="http://www.ruanyifeng.com/blo…" target="_blank" rel="external">http://www.ruanyifeng.com/blo…</a></p>
<p>Python 的线程。在 Python 中，哪一种多线程的程序表现得更好，I/O 密集型的还是计算 密集型的?</p>
<p>由于GIL的缘故，对所有面向 I/O 的(会调用内建的操作系统 C 代码的)程序来说，GIL 会在这个 I/O 调用之 前被释放，以允许其它的线程在这个线程等待 I/O 的时候运行。如果某线程并未使用很多 I/O 操作， 它会在自己的时间片内一直占用处理器(和 GIL)。也就是说，I/O 密集型的 Python 程序比计算密集 型的程序更能充分利用多线程环境的好处。</p>
<p>线程。你认为，多 CPU 的系统与一般的系统有什么大的不同?多线程的程序在这种系统上的表现会怎么样?</p>
<p>Python的线程就是C语言的一个pthread，并通过操作系统调度算法进行调度（例如linux是CFS）。为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度（当然是否真正进行上下文切换由操作系统自主决定）。</p>
<hr>
<p>伪代码</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7TqOVvR9rGR63zFhl4GsziamgmicjiaRklkib0EjLq9mFbcicbbOhNtTH6oxlAbYtSJDA1jdgibiaNElk3D6A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<p>这种模式在只有一个CPU核心的情况下毫无问题。任何一个线程被唤起时都能成功获得到GIL（因为只有释放了GIL才会引发线程调度）。</p>
<p>但当CPU有多个核心的时候，问题就来了。从伪代码可以看到，从release GIL到acquire GIL之间几乎是没有间隙的。所以当其他在其他核心上的线程被唤醒时，大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤醒执行的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。然后达到切换时间后进入待调度状态，再被唤醒，再等待，以此往复恶性循环。</p>
<p>简单的总结下就是：Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。</p>
<p>线程池。修改 生成者消费者 的代码，不再是一个生产者和一个消费者，而是可以有任意个 消费者线程(一个线程池)，每个线程可以在任意时刻处理或消耗任意多个产品。</p>
<hr>
<h2 id="Python3-实例"><a href="#Python3-实例" class="headerlink" title="Python3 实例"></a>Python3 实例</h2><hr>
<h2 id="Python3-正则表达式"><a href="#Python3-正则表达式" class="headerlink" title="Python3 正则表达式"></a>Python3 正则表达式</h2><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p>
<p>Python 自1.5版本起增加了<code>re</code>模块，它提供 Perl 风格的正则表达式模式。</p>
<p>re 模块使 Python 语言拥有全部的正则表达式功能。</p>
<p>compile函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。</p>
<p>re模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</p>
<p>本章节主要介绍Python中常用的正则表达式处理函数。</p>
<hr>
<p>re.match函数</p>
<p>re.match尝试从字符串的<strong>起始位置</strong>匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p>
<p><strong>函数语法</strong>：</p>
<pre><code>re.match(pattern, string, flags=0)
</code></pre><p>函数参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>匹配的正则表达式</td>
</tr>
<tr>
<td>string</td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td>flags</td>
<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>
</tr>
</tbody>
</table>
<p>匹配成功re.match方法返回一个匹配的对象，否则返回None。</p>
<p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">匹配对象方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">group(num=0)</td>
<td style="text-align:left">匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>
</tr>
<tr>
<td style="text-align:left">groups()</td>
<td style="text-align:left">返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>
</tr>
</tbody>
</table>
<p>实例 1：</p>
<pre><code>#!/usr/bin/python
# -*- coding: UTF-8 -*-

import re
print(re.match(&apos;www&apos;, &apos;www.runoob.com&apos;).span())  # 在起始位置匹配
print(re.match(&apos;com&apos;, &apos;www.runoob.com&apos;))         # 不在起始位置匹配
</code></pre><p>以上实例运行输出结果为：</p>
<pre><code>(0, 3)
None
</code></pre><p>实例 2：</p>
<pre><code>#!/usr/bin/python3
import re

line = &quot;Cats are smarter than dogs&quot;

matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)

if matchObj:
   print (&quot;matchObj.group() : &quot;, matchObj.group())
   print (&quot;matchObj.group(1) : &quot;, matchObj.group(1))
   print (&quot;matchObj.group(2) : &quot;, matchObj.group(2))
else:
   print (&quot;No match!!&quot;)
</code></pre><p>以上实例执行结果如下：</p>
<pre><code>matchObj.group() :  Cats are smarter than dogs
matchObj.group(1) :  Cats
matchObj.group(2) :  smarter
</code></pre><hr>
<p>re.search方法</p>
<p>re.search 扫描整个字符串并返回第一个成功的匹配。</p>
<p>函数语法：</p>
<pre><code>re.search(pattern, string, flags=0)
</code></pre><p>函数参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pattern</td>
<td>匹配的正则表达式</td>
</tr>
<tr>
<td>string</td>
<td>要匹配的字符串。</td>
</tr>
<tr>
<td>flags</td>
<td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</td>
</tr>
</tbody>
</table>
<p>匹配成功re.search方法返回一个匹配的对象，否则返回None。</p>
<p>我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。</p>
<table>
<thead>
<tr>
<th>匹配对象方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>group(num=0)</td>
<td>匹配的整个表达式的字符串，group()可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</td>
</tr>
<tr>
<td>groups()</td>
<td>返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</td>
</tr>
</tbody>
</table>
<p>实例 1：</p>
<pre><code>#!/usr/bin/python3

import re

print(re.search(&apos;www&apos;, &apos;www.runoob.com&apos;).span())  # 在起始位置匹配
print(re.search(&apos;com&apos;, &apos;www.runoob.com&apos;).span())         # 不在起始位置匹配
</code></pre><p>以上实例运行输出结果为：</p>
<pre><code>(0, 3)
(11, 14)
</code></pre><p>实例 2：</p>
<pre><code>#!/usr/bin/python3

import re

line = &quot;Cats are smarter than dogs&quot;;

searchObj = re.search( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)

if searchObj:
   print (&quot;searchObj.group() : &quot;, searchObj.group())
   print (&quot;searchObj.group(1) : &quot;, searchObj.group(1))
   print (&quot;searchObj.group(2) : &quot;, searchObj.group(2))
else:
   print (&quot;Nothing found!!&quot;)
</code></pre><p>以上实例执行结果如下：</p>
<pre><code>searchObj.group() :  Cats are smarter than dogs
searchObj.group(1) :  Cats
searchObj.group(2) :  smarter
</code></pre><hr>
<p>re.match与re.search的区别</p>
<p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>
<p>实例：</p>
<pre><code>#!/usr/bin/python3

import re

line = &quot;Cats are smarter than dogs&quot;;

matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I)
if matchObj:
   print (&quot;match --&gt; matchObj.group() : &quot;, matchObj.group())
else:
   print (&quot;No match!!&quot;)

matchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I)
if matchObj:
   print (&quot;search --&gt; matchObj.group() : &quot;, matchObj.group())
else:
   print (&quot;No match!!&quot;)
</code></pre><p>以上实例运行结果如下：</p>
<pre><code>No match!!
search --&gt; matchObj.group() :  dogs
</code></pre><hr>
<p>检索和替换</p>
<p>Python 的re模块提供了re.sub用于替换字符串中的匹配项。</p>
<p>语法：</p>
<pre><code>re.sub(pattern, repl, string, count=0)
</code></pre><p>参数：</p>
<ul>
<li>pattern : 正则中的模式字符串。</li>
<li>repl : 替换的字符串，也可为一个函数。</li>
<li>string : 要被查找替换的原始字符串。</li>
<li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li>
</ul>
<p>实例：</p>
<pre><code>#!/usr/bin/python3
import re

phone = &quot;2004-959-559 # 这是一个电话号码&quot;

# 删除注释
num = re.sub(r&apos;#.*$&apos;, &quot;&quot;, phone)
print (&quot;电话号码 : &quot;, num)

# 移除非数字的内容
num = re.sub(r&apos;\D&apos;, &quot;&quot;, phone)
print (&quot;电话号码 : &quot;, num)
</code></pre><p>以上实例执行结果如下：</p>
<pre><code>电话号码 :  2004-959-559
电话号码 :  2004959559
</code></pre><hr>
<p>repl 参数是一个函数</p>
<p>以下实例中将字符串中的匹配的数字乘于 2：</p>
<pre><code>#!/usr/bin/python

import re

# 将匹配的数字乘于 2
def double(matched):
    value = int(matched.group(&apos;value&apos;))
    return str(value * 2)

s = &apos;A23G4HFD567&apos;
print(re.sub(&apos;(?P&lt;value&gt;\d+)&apos;, double, s))
</code></pre><p>执行输出结果为：</p>
<pre><code>A46G8HFD1134
</code></pre><hr>
<p>正则表达式修饰符 - 可选标志</p>
<p>正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>re.I</td>
<td>使匹配对大小写不敏感</td>
</tr>
<tr>
<td>re.L</td>
<td>做本地化识别（local-aware）匹配</td>
</tr>
<tr>
<td>re.M</td>
<td>多行匹配，影响 ^ 和 \$</td>
</tr>
<tr>
<td>re.S</td>
<td>使 . 匹配包括换行在内的所有字符</td>
</tr>
<tr>
<td>re.U</td>
<td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td>
</tr>
<tr>
<td>re.X</td>
<td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td>
</tr>
</tbody>
</table>
<hr>
<p>正则表达式模式</p>
<p>模式字符串使用特殊的语法来表示一个正则表达式：</p>
<ul>
<li><p>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。</p>
</li>
<li><p>多数字母和数字前加一个反斜杠时会拥有不同的含义。</p>
</li>
<li><p>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。</p>
</li>
<li><p>反斜杠本身需要使用反斜杠转义。</p>
</li>
<li><p>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如<br>r’/t’，等价于’//t’)匹配相应的特殊字符。</p>
</li>
</ul>
<p>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td>\$</td>
<td>匹配字符串的末尾。</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td>[…]</td>
<td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td>
</tr>
<tr>
<td>[^…]</td>
<td>不在[]中的字符：[\^abc] 匹配除了a,b,c之外的字符。</td>
</tr>
<tr>
<td>re*</td>
<td>匹配0个或多个的表达式。</td>
</tr>
<tr>
<td>re+</td>
<td>匹配1个或多个的表达式。</td>
</tr>
<tr>
<td>re?</td>
<td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td>re{ n}</td>
</tr>
<tr>
<td>re{ n,}</td>
<td>精确匹配n个前面表达式。</td>
</tr>
<tr>
<td>re{ n, m}</td>
<td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td>a\</td>
<td>b</td>
<td>匹配a或b</td>
</tr>
<tr>
<td>(re)</td>
<td>G匹配括号内的表达式，也表示一个组</td>
</tr>
<tr>
<td>(?imx)</td>
<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>
</tr>
<tr>
<td>(?-imx)</td>
<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>
</tr>
<tr>
<td>(?: re)</td>
<td>类似 (…), 但是不表示一个组</td>
</tr>
<tr>
<td>(?imx: re)</td>
<td>在括号中使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>(?-imx: re)</td>
<td>在括号中不使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>(?#…)</td>
<td>注释.</td>
</tr>
<tr>
<td>(?= re)</td>
<td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td>(?! re)</td>
<td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>
</tr>
<tr>
<td>(?&gt; re)</td>
<td>匹配的独立模式，省去回溯。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母数字</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意空白字符，等价于 [\t\n\r\f].</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意非空字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任意数字，等价于 [0-9].</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字</td>
</tr>
<tr>
<td>\A</td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td>\Z</td>
<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c</td>
</tr>
<tr>
<td>\z</td>
<td>匹配字符串结束</td>
</tr>
<tr>
<td>\G</td>
<td>匹配最后匹配完成的位置。</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td>\n, \t, etc.</td>
<td>匹配一个换行符。匹配一个制表符。等</td>
</tr>
<tr>
<td>\1…\9</td>
<td>匹配第n个分组的子表达式。</td>
</tr>
<tr>
<td>\10</td>
<td>匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。</td>
</tr>
</tbody>
</table>
<hr>
<p>正则表达式实例</p>
<hr>
<p>字符匹配</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>python</td>
<td>匹配 “python”.</td>
</tr>
</tbody>
</table>
<hr>
<p>字符类</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[Pp]ython</td>
<td>匹配 “Python” 或 “python”</td>
</tr>
<tr>
<td>rub[ye]</td>
<td>匹配 “ruby” 或 “rube”</td>
</tr>
<tr>
<td>[aeiou]</td>
<td>匹配中括号内的任意一个字母</td>
</tr>
<tr>
<td>[0-9]</td>
<td>匹配任何数字。类似于 [0123456789]</td>
</tr>
<tr>
<td>[a-z]</td>
<td>匹配任何小写字母</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>匹配任何大写字母</td>
</tr>
<tr>
<td>[a-zA-Z0-9]</td>
<td>匹配任何字母及数字</td>
</tr>
<tr>
<td>[^aeiou]</td>
<td>除了aeiou字母以外的所有字符</td>
</tr>
<tr>
<td>[^0-9]</td>
<td>匹配除了数字外的字符</td>
</tr>
</tbody>
</table>
<hr>
<p>特殊字符类</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]‘ 的模式。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 [\^0-9]。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]‘。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任何非单词字符。等价于 ‘[\^A-Za-z0-9_]‘。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Python3-CGI编程"><a href="#Python3-CGI编程" class="headerlink" title="Python3 CGI编程"></a>Python3 CGI编程</h2><hr>
<h2 id="Python3-MySQL"><a href="#Python3-MySQL" class="headerlink" title="Python3 MySQL"></a>Python3 MySQL</h2><hr>
<h2 id="Python3-网络编程"><a href="#Python3-网络编程" class="headerlink" title="Python3 网络编程"></a>Python3 网络编程</h2><hr>
<h2 id="Python3-SMTP发送邮件"><a href="#Python3-SMTP发送邮件" class="headerlink" title="Python3 SMTP发送邮件"></a>Python3 SMTP发送邮件</h2><p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。</p>
<p>python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。</p>
<p>Python创建 SMTP 对象语法如下：</p>
<pre><code>import smtplib

smtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )
</code></pre><p>参数说明：</p>
<ul>
<li>host: SMTP 服务器主机。<br>你可以指定主机的ip地址或者域名如:w3cschool.cc，这个是可选参数。</li>
<li>port: 如果你提供了 host 参数, 你需要指定 SMTP服务使用的端口号，一般情况下SMTP端口号为25。</li>
<li>local_hostname: 如果SMTP在你的本机上，你只需要指定服务器地址为localhost 即可。</li>
</ul>
<p>Python SMTP对象使用sendmail方法发送邮件，语法如下：</p>
<pre><code>SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options]
</code></pre><p>参数说明：</p>
<ul>
<li>from_addr: 邮件发送者地址。</li>
<li>to_addrs: 字符串列表，邮件发送地址。</li>
<li>msg: 发送消息</li>
</ul>
<p>这里要注意一下第三个参数，msg是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意msg的格式。这个格式就是smtp协议中定义的格式。</p>
<p>实例</p>
<p>以下是一个使用Python发送邮件简单的实例：</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.text import MIMEText
from email.header import Header

sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

# 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码
message = MIMEText(&apos;Python 邮件发送测试...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)
message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)

subject = &apos;Python SMTP 邮件测试&apos;
message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)


try:
    smtpObj = smtplib.SMTP(&apos;localhost&apos;)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)
</code></pre><p>我们使用三个引号来设置邮件信息，标准邮件需要三个头部信息： <strong>From</strong>,<br><strong>To</strong>, 和 <strong>Subject</strong> ，每个信息直接使用空行分割。</p>
<p>我们通过实例化 smtplib 模块的 SMTP 对象 <em>smtpObj</em> 来连接到 SMTP<br>访问，并使用 <em>sendmail</em> 方法来发送信息。</p>
<p>执行以上程序，如果你本机安装sendmail，就会输出：</p>
<pre><code>$ python3 test.py
邮件发送成功
</code></pre><p>查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2016/04/smtp1.jpg" alt=""></p>
<p>如果我们本机没有 sendmail 访问，也可以使用其他服务商的 SMTP访问（QQ、网易、Google等）。</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.text import MIMEText
from email.header import Header

# 第三方 SMTP 服务
mail_host=&quot;smtp.XXX.com&quot;  #设置服务器
mail_user=&quot;XXXX&quot;    #用户名
mail_pass=&quot;XXXXXX&quot;   #口令


sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

message = MIMEText(&apos;Python 邮件发送测试...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)
message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)

subject = &apos;Python SMTP 邮件测试&apos;
message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)


try:
    smtpObj = smtplib.SMTP()
    smtpObj.connect(mail_host, 25)    # 25 为 SMTP 端口号
    smtpObj.login(mail_user,mail_pass)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)
</code></pre><hr>
<p>发送HTML格式的邮件</p>
<p>Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中_subtype设置为html。具体代码如下：</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.text import MIMEText
from email.header import Header

sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

mail_msg = &quot;&quot;&quot;
&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot;&gt;这是一个链接&lt;/a&gt;&lt;/p&gt;
&quot;&quot;&quot;
message = MIMEText(mail_msg, &apos;html&apos;, &apos;utf-8&apos;)
message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)

subject = &apos;Python SMTP 邮件测试&apos;
message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)


try:
    smtpObj = smtplib.SMTP(&apos;localhost&apos;)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)
</code></pre><p>执行以上程序，如果你本机安装sendmail，就会输出：</p>
<pre><code>$ python3 test.py
邮件发送成功
</code></pre><p>查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2016/04/smtp2.jpg" alt=""></p>
<hr>
<p>发送带附件的邮件</p>
<p>发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header

sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

#创建一个带附件的实例
message = MIMEMultipart()
message[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
message[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)
subject = &apos;Python SMTP 邮件测试&apos;
message[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)

#邮件正文内容
message.attach(MIMEText(&apos;这是菜鸟教程Python 邮件发送测试……&apos;, &apos;plain&apos;, &apos;utf-8&apos;))

# 构造附件1，传送当前目录下的 test.txt 文件
att1 = MIMEText(open(&apos;test.txt&apos;, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;)
att1[&quot;Content-Type&quot;] = &apos;application/octet-stream&apos;
# 这里的filename可以任意写，写什么名字，邮件中显示什么名字
att1[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;test.txt&quot;&apos;
message.attach(att1)

# 构造附件2，传送当前目录下的 runoob.txt 文件
att2 = MIMEText(open(&apos;runoob.txt&apos;, &apos;rb&apos;).read(), &apos;base64&apos;, &apos;utf-8&apos;)
att2[&quot;Content-Type&quot;] = &apos;application/octet-stream&apos;
att2[&quot;Content-Disposition&quot;] = &apos;attachment; filename=&quot;runoob.txt&quot;&apos;
message.attach(att2)

try:
    smtpObj = smtplib.SMTP(&apos;localhost&apos;)
    smtpObj.sendmail(sender, receivers, message.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)

$ python3 test.py
邮件发送成功
</code></pre><p>查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2013/11/smtp3.jpg" alt=""></p>
<hr>
<p>HTML 文本中添加图片</p>
<p>邮件的 HTML<br>文本中一般邮件服务商添加外链是无效的，正确添加突破的实例如下所示：</p>
<pre><code>#!/usr/bin/python3

import smtplib
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.header import Header

sender = &apos;from@runoob.com&apos;
receivers = [&apos;429240967@qq.com&apos;]  # 接收邮件，可设置为你的QQ邮箱或者其他邮箱

msgRoot = MIMEMultipart(&apos;related&apos;)
msgRoot[&apos;From&apos;] = Header(&quot;菜鸟教程&quot;, &apos;utf-8&apos;)
msgRoot[&apos;To&apos;] =  Header(&quot;测试&quot;, &apos;utf-8&apos;)
subject = &apos;Python SMTP 邮件测试&apos;
msgRoot[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)

msgAlternative = MIMEMultipart(&apos;alternative&apos;)
msgRoot.attach(msgAlternative)


mail_msg = &quot;&quot;&quot;
&lt;p&gt;Python 邮件发送测试...&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com&quot;&gt;菜鸟教程链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图片演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;cid:image1&quot;&gt;&lt;/p&gt;
&quot;&quot;&quot;
msgAlternative.attach(MIMEText(mail_msg, &apos;html&apos;, &apos;utf-8&apos;))

# 指定图片为当前目录
fp = open(&apos;test.png&apos;, &apos;rb&apos;)
msgImage = MIMEImage(fp.read())
fp.close()

# 定义图片 ID，在 HTML 文本中引用
msgImage.add_header(&apos;Content-ID&apos;, &apos;&lt;image1&gt;&apos;)
msgRoot.attach(msgImage)

try:
    smtpObj = smtplib.SMTP(&apos;localhost&apos;)
    smtpObj.sendmail(sender, receivers, msgRoot.as_string())
    print (&quot;邮件发送成功&quot;)
except smtplib.SMTPException:
    print (&quot;Error: 无法发送邮件&quot;)

$ python3 test.py
邮件发送成功
</code></pre><p>查看我们的收件箱(如果在垃圾箱可能需要移动到收件箱才可正常显示)，就可以查看到邮件信息：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2016/04/smtp4.jpg" alt=""></p>
<p>更多内容请参阅：<a href="https://docs.python.org/3/library/email-examples.html" target="_blank" rel="external">https://docs.python.org/3/library/email-examples.html</a>。</p>
<hr>
<h2 id="Python3-多线程"><a href="#Python3-多线程" class="headerlink" title="Python3 多线程"></a>Python3 多线程</h2><hr>
<h2 id="Python3-XML解析"><a href="#Python3-XML解析" class="headerlink" title="Python3 XML解析"></a>Python3 XML解析</h2><hr>
<h2 id="Python3-JSON"><a href="#Python3-JSON" class="headerlink" title="Python3 JSON"></a>Python3 JSON</h2><hr>
<h2 id="Python3-日期和时间"><a href="#Python3-日期和时间" class="headerlink" title="Python3 日期和时间"></a>Python3 日期和时间</h2><hr>
<h2 id="Python-输出指定范围内的素数"><a href="#Python-输出指定范围内的素数" class="headerlink" title="Python 输出指定范围内的素数"></a>Python 输出指定范围内的素数</h2><hr>
<h2 id="Python-装饰器"><a href="#Python-装饰器" class="headerlink" title="Python 装饰器"></a>Python 装饰器</h2><p>我们知道，在 Python 中，我们可以像使用变量一样使用函数：</p>
<ul>
<li>函数可以被赋值给其他变量</li>
<li>函数可以被删除</li>
<li>可以在函数里面再定义函数</li>
<li>函数可以作为参数传递给另外一个函数</li>
<li>函数可以作为另一个函数的返回</li>
</ul>
<p>简而言之，函数就是一个对象。</p>
<hr>
<p>对一个简单的函数进行装饰</p>
<p>为了更好地理解装饰器，我们先从一个简单的例子开始，假设有下面的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<p>在上面，我们将 hello 函数传给 makeitalic，再将返回赋给 hello，此时调用 hello() 就得到了我们想要的结果。</p>
<p>不过要注意的是，由于我们将 makeitalic 的返回赋给了 hello，此时 hello() 函数仍然存在，但是它的函数名不再是 hello 了，而是 wrapped，正是 makeitalic 返回函数的名称，可以验证一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello.__name__</div><div class="line"><span class="string">'wrapped'</span></div></pre></td></tr></table></figure></p>
<p>对于这个小瑕疵，后文将会给出解决方法。</p>
<p>现在，我们梳理一下上面的例子，为了增强原函数 hello 的功能，我们定义了一个函数，它接收原函数作为参数，并返回一个新的函数，完整的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div><div class="line"></div><div class="line">hello = makeitalic(hello)</div></pre></td></tr></table></figure></p>
<p>事实上，makeitalic 就是一个装饰器（decorator），它『装饰』了函数 hello，并返回一个函数，将其赋给 hello。</p>
<p>一般情况下，我们使用装饰器提供的 @ 语法糖（Syntactic Sugar），来简化上面的写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<p>像上面的情况，可以动态修改函数（或类）功能的函数就是装饰器。本质上，它是一个高阶函数，以被装饰的函数（比如上面的 hello）为参数，并返回一个包装后的函数（比如上面的 wrapped）给被装饰函数（hello）。</p>
<hr>
<p>装饰器的使用形式</p>
<p>装饰器的一般使用形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>等价于下面的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line">func = decorator(func)</div></pre></td></tr></table></figure>
<p>装饰器可以定义多个，离函数定义最近的装饰器先被调用，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator_one</span></div><div class="line"><span class="meta">@decorator_two</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">func = decorator_one(decorator_two(func))</div></pre></td></tr></table></figure>
<p>装饰器还可以带参数，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@decorator(arg1, arg2)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">等价于：</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">func = decorator(arg1, arg2)(func)</div></pre></td></tr></table></figure>
<p>下面我们再看一些具体的例子，以加深对它的理解。</p>
<p>对带参数的函数进行装饰</p>
<p>前面的例子中，被装饰的函数 hello() 是没有带参数的，我们看看被装饰函数带参数的情况。对前面例子中的 hello() 函数进行改写，使其带参数，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        ret = func(*args, **kwargs)</div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;i&gt;'</span> + ret + <span class="string">'&lt;/i&gt;'</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">(name1, name2)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s, %s'</span> % (name1, name2)</div></pre></td></tr></table></figure>
<p>由于函数 hello 带参数，因此内嵌包装函数 wrapped 也做了一点改变：</p>
<p>内嵌包装函数的参数传给了 func，即被装饰函数，也就是说内嵌包装函数的参数跟被装饰函数的参数对应，这里使用了 (<em>args, *</em>kwargs)，是为了适应可变参数。</p>
<p>看看使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello(<span class="string">'python'</span>)</div><div class="line"><span class="string">'&lt;i&gt;hello python&lt;/i&gt;'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello2(<span class="string">'python'</span>, <span class="string">'java'</span>)</div><div class="line"><span class="string">'&lt;i&gt;hello python, java&lt;/i&gt;'</span></div></pre></td></tr></table></figure>
<hr>
<p>带参数的装饰器</p>
<p>上面的例子，我们增强了函数 hello 的功能，给它的返回加上了标签 <code>&lt;i&gt;…&lt;/i&gt;</code>，现在，我们想改用标签 <code>&lt;b&gt;…&lt;/b&gt;</code> 或 <code>&lt;p&gt;…&lt;/p&gt;</code>。是不是要像前面一样，再定义一个类似 makeitalic 的装饰器呢？其实，我们可以定义一个函数，将标签作为参数，返回一个装饰器，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrap_in_tag</span><span class="params">(tag)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            ret = func(*args, **kwargs)</div><div class="line">            <span class="keyword">return</span> <span class="string">'&lt;'</span> + tag + <span class="string">'&gt;'</span> + ret + <span class="string">'&lt;/'</span> + tag + <span class="string">'&gt;'</span></div><div class="line">        <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p>现在，我们可以根据需要生成想要的装饰器了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">makebold = wrap_in_tag(<span class="string">'b'</span>)  <span class="comment"># 根据 'b' 返回 makebold 生成器</span></div><div class="line"></div><div class="line"><span class="meta">@makebold</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello(<span class="string">'world'</span>)</div><div class="line"><span class="string">'&lt;b&gt;hello world&lt;/b&gt;'</span></div></pre></td></tr></table></figure>
<p>上面的形式也可以写得更加简洁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@wrap_in_tag('b')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div></pre></td></tr></table></figure>
<p>这就是带参数的装饰器，其实就是在装饰器外面多了一层包装，根据不同的参数返回不同的装饰器。</p>
<hr>
<p>多个装饰器</p>
<p>现在，让我们来看看多个装饰器的例子，为了简单起见，下面的例子就不使用带参数的装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makebold</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;b&gt;'</span> + func() + <span class="string">'&lt;/b&gt;'</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;i&gt;'</span> + func() + <span class="string">'&lt;/i&gt;'</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makebold</span></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<p>上面定义了两个装饰器，对 hello 进行装饰，上面的最后几行代码相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div><div class="line"></div><div class="line">hello = makebold(makeitalic(hello))</div></pre></td></tr></table></figure>
<p>调用函数 hello：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello()</div><div class="line"><span class="string">'&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;'</span></div></pre></td></tr></table></figure>
<p>基于类的装饰器</p>
<p>前面的装饰器都是一个函数，其实也可以基于类定义装饰器，看下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bold</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'&lt;b&gt;'</span> + self.func(*args, **kwargs) + <span class="string">'&lt;/b&gt;'</span></div><div class="line"></div><div class="line"><span class="meta">@Bold</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello(<span class="string">'world'</span>)</div><div class="line"><span class="string">'&lt;b&gt;hello world&lt;/b&gt;'</span></div></pre></td></tr></table></figure>
<p>可以看到，类 Bold 有两个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__init__()：它接收一个函数作为参数，也就是被装饰的函数</div><div class="line">__call__()：让类对象可调用，就像函数调用一样，在调用被装饰函数时被调用</div></pre></td></tr></table></figure>
<p>还可以让类装饰器带参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tag)</span>:</span></div><div class="line">        self.tag = tag</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">            <span class="keyword">return</span> <span class="string">"&lt;&#123;tag&#125;&gt;&#123;res&#125;&lt;/&#123;tag&#125;&gt;"</span>.format(</div><div class="line">                res=func(*args, **kwargs), tag=self.tag</div><div class="line">            )</div><div class="line">        <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@Tag('b')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello %s'</span> % name</div></pre></td></tr></table></figure>
<p>需要注意的是，如果类装饰器有参数，则 <code>__init__</code> 接收参数，而 <code>__call__</code> 接收 func。</p>
<hr>
<p>装饰器的副作用</p>
<p>前面提到，使用装饰器有一个瑕疵，就是被装饰的函数，它的函数名称已经不是原来的名称了，回到最开始的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>
<p>函数 hello 被 makeitalic 装饰后，它的函数名称已经改变了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello.__name__</div><div class="line"><span class="string">'wrapped'</span></div></pre></td></tr></table></figure>
<p>为了消除这样的副作用，Python 中的 functool 包提供了一个 wraps 的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">    @wraps(func)       # 加上 wraps 装饰器</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + func() + <span class="string">"&lt;/i&gt;"</span></div><div class="line">    <span class="keyword">return</span> wrapped</div><div class="line"></div><div class="line"><span class="meta">@makeitalic</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello.__name__</div><div class="line"><span class="string">'hello'</span></div></pre></td></tr></table></figure>
<p>小结</p>
<ul>
<li>本质上，装饰器就是一个返回函数的高阶函数。</li>
<li>装饰器可以动态地修改一个类或函数的功能，通过在原有的类或者函数上包裹一层修饰类或修饰函数实现。</li>
<li>事实上，装饰器就是闭包的一种应用，但它比较特别，接收被装饰函数为参数，并返回一个函数，赋给被装饰函数，闭包则没这种限制。</li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3.5/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Python 3.5.3 documentation&lt;/a&gt;&lt;/p&gt;
&lt;/bl
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>DBMSSAS Assignment3</title>
    <link href="http://mingotang.github.io/2017/09/29/DBMSSAS-Assignment3/"/>
    <id>http://mingotang.github.io/2017/09/29/DBMSSAS-Assignment3/</id>
    <published>2017-09-29T08:06:23.000Z</published>
    <updated>2017-10-09T13:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>The E-R diagram of the Student – Course Database showed as:</p>
<p><img src="http://ox3grgjnx.bkt.clouddn.com/DBMSSAS%20Assignment3%20001.png" alt=""></p>
<ol>
<li>Convert the E/R diagram to relations</li>
<li>Create the tables by using SQL Server Management Studio.</li>
<li>Draw database diagram of the three tables.</li>
</ol>
<hr>
<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p><strong>Relations</strong>:</p>
<ul>
<li>Student (<u>Sno</u>, Sname, Ssex, Sage, Sdept)</li>
<li>Course (<u>Cno</u>, Cname, Cpno, Ccredit)</li>
<li>SC (<u>Sno</u>, <u>Cno</u>, Grade)</li>
</ul>
<p><strong>Create tables</strong></p>
<p>使用MS-SQL图形界面创建表：</p>
<ul>
<li>数据库 - （右键）- 新建数据库</li>
</ul>
<p><img src="http://ox3grgjnx.bkt.clouddn.com/DBMSSAS%20Assignment3%20002b.png" alt="新建数据库"></p>
<ul>
<li>数据库 - 表 - （右键）- 新建表</li>
</ul>
<p><img src="http://ox3grgjnx.bkt.clouddn.com/DBMSSAS%20Assignment3%20003b.png" alt="表Student"></p>
<p><img src="http://ox3grgjnx.bkt.clouddn.com/DBMSSAS%20Assignment3%20004b.png" alt="表Course"></p>
<p><img src="http://ox3grgjnx.bkt.clouddn.com/DBMSSAS%20Assignment3%20005b.png" alt="表SC"></p>
<blockquote>
<p>表 SC 需要设置双键</p>
</blockquote>
<p>使用SQL语句创建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student(</div><div class="line">    Sno <span class="built_in">CHAR</span>(<span class="number">100</span>) PRIMARY <span class="keyword">KEY</span>,</div><div class="line">    Sname <span class="built_in">CHAR</span>(<span class="number">100</span>),</div><div class="line">    Ssex <span class="built_in">CHAR</span>(<span class="number">100</span>),</div><div class="line">    Sage <span class="built_in">CHAR</span>(<span class="number">100</span>),</div><div class="line">    Sdept <span class="built_in">CHAR</span>(<span class="number">100</span>)</div><div class="line">    );</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course(</div><div class="line">    Cno <span class="built_in">CHAR</span>(<span class="number">100</span>) PRIMARY <span class="keyword">KEY</span>,</div><div class="line">    Cname <span class="built_in">CHAR</span>(<span class="number">100</span>),</div><div class="line">    Cpno <span class="built_in">CHAR</span>(<span class="number">100</span>),</div><div class="line">    Credit <span class="built_in">CHAR</span>(<span class="number">100</span>)</div><div class="line">    );</div></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC(</div><div class="line">    Sno <span class="built_in">CHAR</span>(<span class="number">100</span>) <span class="keyword">REFERENCES</span> Student(Sno),</div><div class="line">    Cno <span class="built_in">CHAR</span>(<span class="number">100</span>) <span class="keyword">REFERENCES</span> Course(Cno),</div><div class="line">    Grade <span class="built_in">INT</span>,</div><div class="line">    PRIMARY <span class="keyword">KEY</span>(Sno, Cno)</div><div class="line">);</div></pre></td></tr></table></figure>
<p><strong>Draw database diagram</strong></p>
<p>使用MS-SQL图形界面关系图：</p>
<ul>
<li>数据库关系图 - （右键）- 新建数据库关系图 - 添加表<ul>
<li>按住表SC的Sno拖到表Student的Sno设定外键</li>
</ul>
</li>
</ul>
<p><img src="http://ox3grgjnx.bkt.clouddn.com/DBMSSAS%20Assignment3%20006.png" alt="添加外键"><br><img src="http://ox3grgjnx.bkt.clouddn.com/DBMSSAS%20Assignment3%20007.png" alt="数据库关系图"></p>
<hr>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>关系表达式当中表不设置关键字<ul>
<li>键需要用下划线标出</li>
</ul>
</li>
<li>使用MS-SQL图形界面创建的表SC没有设定键：<ul>
<li>在表SC的编辑页面按住 Ctrl 同时选中 Sno 与 Cno 设定键</li>
<li>虽然在设定数据库关系图之后SC不设置双键在MS-SQL当中也可以运行，但是作为严谨的初学者，SC不管用还是不用都是需要设置键的，这一点不会因为SC设置外键而改变。（MS-SQL会根据外键自动设定SC的键，但是其他SQL系统并不一定有这个功能）</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;p&gt;The E-R diagram of the Student –
    
    </summary>
    
    
      <category term="TA" scheme="http://mingotang.github.io/tags/TA/"/>
    
  </entry>
  
  <entry>
    <title>Python 资源包大全</title>
    <link href="http://mingotang.github.io/2017/09/28/Python-%E8%B5%84%E6%BA%90%E5%8C%85%E5%A4%A7%E5%85%A8/"/>
    <id>http://mingotang.github.io/2017/09/28/Python-资源包大全/</id>
    <published>2017-09-28T08:59:46.000Z</published>
    <updated>2017-10-01T12:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>转载自：<a href="http://hao.jobbole.com/" target="_blank" rel="external">伯乐在线</a></p>
</blockquote>
<p>GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">awesome-python</a> 是 vinta 发起维护的 Python 资源列表，内容包括：Web框架、网络爬虫、网络内容提取、模板引擎、数据库、数据可视化、图片处理、文本处理、自然语言处理、机器学习、日志、代码分析等。</p>
<p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是<a href="http://hao.jobbole.com/" target="_blank" rel="external">伯乐在线</a>发起这个开源项目的初衷。</p>
<a id="more"></a>
<h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul>
<li>基于 awesome-python 列表，对其中的各个资源项进行编译整理。此外还将从其他来源补充资源。</li>
<li>整理后的内容，将收录在<a href="http://hao.jobbole.com/" target="_blank" rel="external">伯乐在线资源频道</a>。可参考已整理的内容：<ul>
<li>《<a href="http://hao.jobbole.com/python-scrapy/" target="_blank" rel="external">Scrapy：Python的爬虫框架</a>》</li>
<li>《<a href="http://hao.jobbole.com/flask/" target="_blank" rel="external">Flask：一个使用Python编写的轻量级Web应用框架</a>》</li>
</ul>
</li>
</ul>
<hr>
<h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul>
<li>维护者：</li>
<li>贡献者：<a href="https://github.com/hanxiaomax" target="_blank" rel="external">艾凌风</a>、Namco、<a href="https://github.com/Daetalus" target="_blank" rel="external">Daetalus</a>、<a href="http://www.jobbole.com/members/huanglimin/" target="_blank" rel="external">黄利民</a>、<a href="http://www.jobbole.com/members/atupal/" target="_blank" rel="external">atupal</a>、<a href="http://www.jobbole.com/members/rainbow/" target="_blank" rel="external">rainbow</a>、<a href="https://github.com/mutoulbj" target="_blank" rel="external">木头lbj</a>、<a href="http://www.jobbole.com/members/beyondwu/" target="_blank" rel="external">beyondwu</a>、<a href="https://github.com/cissoid" target="_blank" rel="external">cissoid</a>、<a href="https://github.com/liguangsheng" target="_blank" rel="external">李广胜</a>、<a href="https://github.com/polyval" target="_blank" rel="external">polyval</a>、<a href="http://www.jobbole.com/members/libing1209/" target="_blank" rel="external">冰斌</a>、<a href="http://www.jobbole.com/members/nelsonzhao/" target="_blank" rel="external">赵叶宇</a>、<a href="http://www.jobbole.com/members/fengfeng19910805/" target="_blank" rel="external">л stalgic</a>、<a href="http://www.jobbole.com/members/shawnw/" target="_blank" rel="external">硕恩</a>、<a href="https://github.com/strongit" target="_blank" rel="external">strongit</a>、<a href="http://www.jobbole.com/members/yuukilp/" target="_blank" rel="external">yuukilp</a></li>
</ul>
<p>注：名单不分排名，不定期补充更新</p>
<hr>
<h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>管理 Python 版本和环境的工具</p>
<ul>
<li>p：非常简单的交互式 python 版本管理工具。<a href="https://github.com/qw3rtman/p" target="_blank" rel="external">官网</a></li>
<li>pyenv：简单的 Python 版本管理工具。<a href="https://github.com/yyuu/pyenv" target="_blank" rel="external">官网</a></li>
<li>Vex：可以在虚拟环境中执行命令。<a href="https://github.com/sashahart/vex" target="_blank" rel="external">官网</a></li>
<li>virtualenv：创建独立 Python 环境的工具。<a href="https://pypi.python.org/pypi/virtualenv" target="_blank" rel="external">官网</a></li>
<li>virtualenvwrapper：virtualenv 的一组扩展。<a href="https://pypi.python.org/pypi/virtualenvwrapper" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>管理包和依赖的工具。</p>
<ul>
<li>pip：Python 包和依赖关系管理工具。<a href="https://pip.pypa.io/" target="_blank" rel="external">官网</a></li>
<li>pip-tools：保证 Python 包依赖关系更新的一组工具。<a href="https://github.com/nvie/pip-tools" target="_blank" rel="external">官网</a></li>
<li>conda：跨平台，Python 二进制包管理工具。<a href="https://github.com/conda/conda/" target="_blank" rel="external">官网</a></li>
<li>Curdling：管理 Python 包的命令行工具。<a href="http://clarete.li/curdling/" target="_blank" rel="external">官网</a></li>
<li>wheel：Python 分发的新标准，意在取代 eggs。<a href="http://pythonwheels.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="包仓库"><a href="#包仓库" class="headerlink" title="包仓库"></a>包仓库</h3><p>本地 PyPI 仓库服务和代理。</p>
<ul>
<li>warehouse：下一代 PyPI。<a href="https://github.com/pypa/warehouse" target="_blank" rel="external">官网</a><ul>
<li>Warehouse：PyPA 提供的 PyPI 镜像工具。<a href="https://warehouse.python.org/" target="_blank" rel="external">官网</a> <a href="https://bitbucket.org/pypa/bandersnatch" target="_blank" rel="external">bandersnatch</a></li>
</ul>
</li>
<li>devpi：PyPI 服务和打包/测试/分发工具。<a href="http://doc.devpi.net/" target="_blank" rel="external">官网</a></li>
<li>localshop：本地 PyPI 服务（自定义包并且自动对 PyPI 镜像）。<a href="https://github.com/mvantellingen/localshop" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h3><p>打包为可执行文件以便分发。</p>
<ul>
<li>PyInstaller：将 Python 程序转换成独立的执行文件（跨平台）。<a href="https://github.com/pyinstaller/pyinstaller" target="_blank" rel="external">官网</a></li>
<li>dh-virtualenv：构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。<a href="http://dh-virtualenv.readthedocs.org/" target="_blank" rel="external">官网</a></li>
<li>Nuitka：将脚本、模块、包编译成可执行文件或扩展模块。<a href="http://nuitka.net/" target="_blank" rel="external">官网</a></li>
<li>py2app：将 Python 脚本变为独立软件包（Mac OS X）。<a href="http://pythonhosted.org/py2app/" target="_blank" rel="external">官网</a></li>
<li>py2exe：将 Python 脚本变为独立软件包（Windows）。<a href="http://www.py2exe.org/" target="_blank" rel="external">官网</a></li>
<li>pynsist：一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python本身。<a href="http://pynsist.readthedocs.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>将源码编译成软件。</p>
<ul>
<li>buildout：一个构建系统，从多个组件来创建，组装和部署应用。<a href="http://www.buildout.org/" target="_blank" rel="external">官网</a></li>
<li>BitBake：针对嵌入式 Linux 的类似 make 的构建工具。<a href="http://www.yoctoproject.org/docs/1.6/bitbake-user-manual/bitbake-user-manual.html" target="_blank" rel="external">官网</a></li>
<li>fabricate：对任何语言自动找到依赖关系的构建工具。<a href="https://code.google.com/archive/p/fabricate" target="_blank" rel="external">官网</a></li>
<li>PlatformIO：多平台命令行构建工具。<a href="https://github.com/platformio/platformio" target="_blank" rel="external">官网</a></li>
<li>PyBuilder：纯 Python 实现的持续化构建工具。<a href="https://github.com/pybuilder/pybuilder" target="_blank" rel="external">官网</a></li>
<li>SCons：软件构建工具。<a href="http://www.scons.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="交互式解析器"><a href="#交互式解析器" class="headerlink" title="交互式解析器"></a>交互式解析器</h3><p>交互式 Python 解析器。</p>
<ul>
<li>IPython：功能丰富的工具，非常有效的使用交互式 Python。<a href="https://github.com/ipython/ipython" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/bpython/" target="_blank" rel="external">bpython</a>：界面丰富的 Python 解析器。<a href="http://bpython-interpreter.org/" target="_blank" rel="external">官网</a></li>
<li>ptpython：高级交互式Python解析器， 构建于<a href="https://github.com/jonathanslenders/python-prompt-toolkit" target="_blank" rel="external">python-prompt-toolkit</a> 之上。<a href="https://github.com/jonathanslenders/ptpython" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件管理和 MIME（多用途的网际邮件扩充协议）类型检测。</p>
<ul>
<li>imghdr：（Python 标准库）检测图片类型。<a href="https://docs.python.org/2/library/imghdr.html" target="_blank" rel="external">官网</a></li>
<li>mimetypes：（Python 标准库）将文件名映射为 MIME 类型。<a href="https://docs.python.org/2/library/mimetypes.html" target="_blank" rel="external">官网</a></li>
<li>path.py：对 os.path 进行封装的模块。<a href="https://github.com/jaraco/path.py" target="_blank" rel="external">官网</a></li>
<li>pathlib：（Python3.4+ 标准库）跨平台的、面向对象的路径操作库。<a href="https://pathlib.readthedocs.org/en/pep428/" target="_blank" rel="external">官网</a></li>
<li>python-magic：文件类型检测的第三方库 libmagic 的 Python 接口。<a href="https://github.com/ahupp/python-magic" target="_blank" rel="external">官网</a></li>
<li>Unipath：用面向对象的方式操作文件和目录。<a href="https://github.com/mikeorr/Unipath" target="_blank" rel="external">官网</a></li>
<li>watchdog：管理文件系统事件的 API 和 shell 工具<a href="https://github.com/gorakhargosh/watchdog" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>操作日期和时间的类库。</p>
<ul>
<li>arrow：更好的 Python 日期时间操作类库。<a href="https://github.com/crsmithdev/arrow" target="_blank" rel="external">官网</a></li>
<li>Chronyk：Python 3 的类库，用于解析手写格式的时间和日期。<a href="https://github.com/KoffeinFlummi/Chronyk" target="_blank" rel="external">官网</a></li>
<li>dateutil：Python datetime 模块的扩展。<a href="https://pypi.python.org/pypi/python-dateutil" target="_blank" rel="external">官网</a></li>
<li>delorean：解决 Python 中有关日期处理的棘手问题的库。<a href="https://github.com/myusuf3/delorean/" target="_blank" rel="external">官网</a></li>
<li>moment：一个用来处理时间和日期的Python库。灵感来自于Moment.js。<a href="https://github.com/zachwill/moment" target="_blank" rel="external">官网</a></li>
<li>PyTime：一个简单易用的Python模块，用于通过字符串来操作日期/时间。<a href="https://github.com/shinux/PyTime" target="_blank" rel="external">官网</a></li>
<li>pytz：现代以及历史版本的世界时区定义。将时区数据库引入Python。<a href="https://launchpad.net/pytz" target="_blank" rel="external">官网</a></li>
<li>when.py：提供用户友好的函数来帮助用户进行常用的日期和时间操作。<a href="https://github.com/dirn/When.py" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>用于解析和操作文本的库。</p>
<ul>
<li>通用<ul>
<li><a href="http://hao.jobbole.com/chardet/" target="_blank" rel="external">chardet</a>：字符编码检测器，兼容 Python2 和 Python3。<a href="https://github.com/chardet/chardet" target="_blank" rel="external">官网</a></li>
<li>difflib：(Python 标准库)帮助我们进行差异化比较。<a href="https://docs.python.org/2/library/difflib.html" target="_blank" rel="external">官网</a></li>
<li>ftfy：让Unicode文本更完整更连贯。<a href="https://github.com/LuminosoInsight/python-ftfy" target="_blank" rel="external">官网</a></li>
<li>fuzzywuzzy：模糊字符串匹配。<a href="https://github.com/seatgeek/fuzzywuzzy" target="_blank" rel="external">官网</a></li>
<li>Levenshtein：快速计算编辑距离以及字符串的相似度。<a href="https://github.com/ztane/python-Levenshtein/" target="_blank" rel="external">官网</a></li>
<li>pangu.py：在中日韩语字符和数字字母之间添加空格。<a href="https://github.com/vinta/pangu.py" target="_blank" rel="external">官网</a></li>
<li>yfiglet-figlet：<a href="https://github.com/pwaller/pyfiglet" target="_blank" rel="external">pyfiglet -figlet</a> 的 Python实现。</li>
<li>shortuuid：一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID。<a href="https://github.com/stochastic-technologies/shortuuid" target="_blank" rel="external">官网</a></li>
<li>unidecode：Unicode 文本的 ASCII 转换形式 。<a href="https://pypi.python.org/pypi/Unidecode" target="_blank" rel="external">官网</a></li>
<li>uniout：打印可读的字符，而不是转义的字符串。<a href="https://github.com/moskytw/uniout" target="_blank" rel="external">官网</a></li>
<li>xpinyin：一个用于把汉字转换为拼音的库。<a href="https://github.com/lxneng/xpinyin" target="_blank" rel="external">官网</a></li>
<li>simplejson：Python的JSON编码、解码器。<a href="https://simplejson.readthedocs.io/en/latest/" target="_blank" rel="external">官网</a>、<a href="https://github.com/simplejson/simplejson" target="_blank" rel="external">GitHub</a></li>
</ul>
</li>
<li>Slug化<ul>
<li>awesome-slugify：一个 Python slug 化库，可以保持 Unicode。<a href="https://github.com/dimka665/awesome-slugify" target="_blank" rel="external">官网</a></li>
<li>python-slugify：Python slug 化库，可以把 unicode 转化为 ASCII。<a href="https://github.com/un33k/python-slugify" target="_blank" rel="external">官网</a></li>
<li>unicode-slugify：一个 slug 工具，可以生成 unicode slugs ,需要依赖 Django 。<a href="https://github.com/mozilla/unicode-slugify" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>解析器<ul>
<li>phonenumbers：解析，格式化，储存，验证电话号码。<a href="https://github.com/daviddrysdale/python-phonenumbers" target="_blank" rel="external">官网</a></li>
<li>PLY：lex 和 yacc 解析工具的 Python 实现。<a href="http://www.dabeaz.com/ply/" target="_blank" rel="external">官网</a></li>
<li>Pygments：通用语法高亮工具。<a href="http://pygments.org/" target="_blank" rel="external">官网</a></li>
<li>pyparsing：生成通用解析器的框架。<a href="http://pyparsing.wikispaces.com/" target="_blank" rel="external">官网</a></li>
<li>python-nameparser：把一个人名分解为几个独立的部分。<a href="https://github.com/derek73/python-nameparser" target="_blank" rel="external">官网</a></li>
<li>python-user-agents：浏览器 user agent 解析器。<a href="https://github.com/selwin/python-user-agents" target="_blank" rel="external">官网</a></li>
<li>sqlparse：一个无验证的 SQL 解析器。<a href="https://sqlparse.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="特殊文本格式处理"><a href="#特殊文本格式处理" class="headerlink" title="特殊文本格式处理"></a>特殊文本格式处理</h3><p>一些用来解析和操作特殊文本格式的库。</p>
<ul>
<li>通用<ul>
<li>tablib：一个用来处理中表格数据的模块。<a href="https://github.com/kennethreitz/tablib" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Office<ul>
<li>Marmir：把输入的Python 数据结构转换为电子表单。<a href="https://github.com/brianray/mm" target="_blank" rel="external">官网</a></li>
<li>openpyxl：一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的库。<a href="https://openpyxl.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>python-docx：读取，查询以及修改 Microsoft Word 2007/2008 docx 文件。<a href="https://github.com/python-openxml/python-docx" target="_blank" rel="external">官网</a></li>
<li>unoconv：在 LibreOffice/OpenOffice 支持的任意文件格式之间进行转换。<a href="https://github.com/dagwieers/unoconv" target="_blank" rel="external">官网</a></li>
<li>XlsxWriter：一个用于创建 Excel .xlsx 文件的 Python 模块。<a href="https://xlsxwriter.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>xlwings：一个使得在 Excel 中方便调用 Python 的库（反之亦然），基于 BSD 协议。<a href="http://xlwings.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/xlwt/" target="_blank" rel="external">xlwt</a>：读写 Excel 文件的数据和格式信息。<a href="https://github.com/python-excel/xlwt" target="_blank" rel="external">官网</a> / <a href="https://github.com/python-excel/xlrd" target="_blank" rel="external">xlrd</a></li>
<li>relatorio：模板化OpenDocument 文件。<a href="http://relatorio.tryton.org/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>PDF<ul>
<li>PDFMiner：一个用于从PDF文档中抽取信息的工具。<a href="https://github.com/euske/pdfminer" target="_blank" rel="external">官网</a></li>
<li>PyPDF2：一个可以分割，合并和转换 PDF 页面的库。<a href="https://github.com/mstamy2/PyPDF2" target="_blank" rel="external">官网</a></li>
<li>ReportLab：快速创建富文本 PDF 文档。<a href="http://www.reportlab.com/opensource/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Markdown<ul>
<li>Mistune：快速并且功能齐全的纯 Python 实现的 Markdown 解析器。<a href="https://github.com/lepture/mistune" target="_blank" rel="external">官网</a></li>
<li>Python-Markdown：John Gruber’s Markdown 的 Python 版实现。<a href="https://github.com/waylan/Python-Markdown" target="_blank" rel="external">官网</a></li>
<li>Python-Markdiwn2：纯 Python 实现的 Markdown 解析器，比 Python-Markdown 更快，更准确，可扩展。<a href="https://github.com/trentm/python-markdown2" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>YAML<ul>
<li>PyYAML：Python 版本的 YAML 解析器。<a href="http://pyyaml.org/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>CSV<ul>
<li>csvkit：用于转换和操作 CSV 的工具。<a href="https://github.com/wireservice/csvkit" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Archive<ul>
<li>unp：一个用来方便解包归档文件的命令行工具。<a href="https://github.com/mitsuhiko/unp" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><p>用来处理人类语言的库。</p>
<ul>
<li><a href="http://hao.jobbole.com/nltk/" target="_blank" rel="external">NLTK</a>：一个先进的平台，用以构建处理人类语言数据的 Python 程序。<a href="http://www.nltk.org/" target="_blank" rel="external">官网</a></li>
<li>jieba：中文分词工具。<a href="https://github.com/fxsjy/jieba" target="_blank" rel="external">官网</a></li>
<li>langid.py：独立的语言识别系统。<a href="https://github.com/saffsd/langid.py" target="_blank" rel="external">官网</a></li>
<li>Pattern：Python 网络信息挖掘模块。<a href="http://www.clips.ua.ac.be/pattern" target="_blank" rel="external">官网</a></li>
<li>SnowNLP：一个用来处理中文文本的库。<a href="https://github.com/isnowfy/snownlp" target="_blank" rel="external">官网</a></li>
<li>TextBlob：为进行普通自然语言处理任务提供一致的 API。<a href="http://textblob.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>TextGrocery：一简单高效的短文本分类工具，基于 LibLinear 和 Jieba。<a href="https://github.com/2shou/TextGrocery" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>用以生成项目文档的库。</p>
<ul>
<li><a href="http://hao.jobbole.com/sphinx/" target="_blank" rel="external">Sphinx</a>：Python 文档生成器。<a href="http://www.sphinx-doc.org/en/latest/" target="_blank" rel="external">官网</a><ul>
<li>awesome-sphinxdoc：<a href="https://github.com/yoloseem/awesome-sphinxdoc" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>MkDocs：对 Markdown 友好的文档生成器。<a href="http://www.mkdocs.org/" target="_blank" rel="external">官网</a></li>
<li>pdoc：一个可以替换Epydoc 的库，可以自动生成 Python 库的 API 文档。<a href="https://github.com/BurntSushi/pdoc" target="_blank" rel="external">官网</a></li>
<li>Pycco：文学编程（literate-programming）风格的文档生成器。<a href="https://github.com/pycco-docs/pycco" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>用来保存和解析配置的库。</p>
<ul>
<li>config：<a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="external">logging</a> 模块作者写的分级配置模块。<a href="https://www.red-dove.com/config-doc/" target="_blank" rel="external">官网</a></li>
<li>ConfigObj：INI 文件解析器，带验证功能。<a href="http://www.voidspace.org.uk/python/configobj.html" target="_blank" rel="external">官网</a></li>
<li>ConfigParser：(Python 标准库) INI 文件解析器。<a href="https://docs.python.org/2/library/configparser.html" target="_blank" rel="external">官网</a></li>
<li>profig：通过多种格式进行配置，具有数值转换功能。<a href="http://profig.readthedocs.org/en/default/" target="_blank" rel="external">官网</a></li>
<li>python-decouple：将设置和代码完全隔离。<a href="https://github.com/henriquebastos/python-decouple" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>用于创建命令行程序的库。</p>
<ul>
<li>命令行程序开发<ul>
<li>asciimatics：跨平台，全屏终端包（即鼠标/键盘输入和彩色，定位文本输出），完整的复杂动画和特殊效果的高级API。<a href="https://github.com/peterbrittain/asciimatics" target="_blank" rel="external">官网</a></li>
<li>cement：Python 的命令行程序框架。<a href="http://builtoncement.com/" target="_blank" rel="external">官网</a></li>
<li>click：一个通过组合的方式来创建精美命令行界面的包。<a href="http://click.pocoo.org/dev/" target="_blank" rel="external">官网</a></li>
<li>cliff：一个用于创建命令行程序的框架，可以创建具有多层命令的命令行程序。<a href="http://docs.openstack.org/developer/cliff/" target="_blank" rel="external">官网</a></li>
<li>clint：Python 命令行程序工具。<a href="https://github.com/kennethreitz/clint" target="_blank" rel="external">官网</a></li>
<li>colorama：跨平台彩色终端文本。<a href="https://pypi.python.org/pypi/colorama" target="_blank" rel="external">官网</a></li>
<li>docopt：Python 风格的命令行参数解析器。<a href="http://docopt.org/" target="_blank" rel="external">官网</a></li>
<li>Gooey：一条命令，将命令行程序变成一个 GUI 程序。<a href="https://github.com/chriskiehl/Gooey" target="_blank" rel="external">官网</a></li>
<li>python-prompt-toolkit：一个用于构建强大的交互式命令行程序的库。<a href="https://github.com/jonathanslenders/python-prompt-toolkit" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pythonpy/" target="_blank" rel="external">Pythonpy</a>：在命令行中直接执行任何Python指令。<a href="https://github.com/Russell91/pythonpy/wiki" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>生产力工具<ul>
<li>aws-cli：Amazon Web Services 的通用命令行界面。<a href="https://github.com/aws/aws-cli" target="_blank" rel="external">官网</a></li>
<li>bashplotlib：在终端中进行基本绘图。<a href="https://github.com/glamp/bashplotlib" target="_blank" rel="external">官网</a></li>
<li>caniusepython3：判断是哪个项目妨碍你你移植到 Python 3。<a href="https://github.com/brettcannon/caniusepython3" target="_blank" rel="external">官网</a></li>
<li>cookiecutter：从 cookiecutters（项目模板）创建项目的一个命令行工具。<a href="https://github.com/audreyr/cookiecutter" target="_blank" rel="external">官网</a></li>
<li>doitlive：一个用来在终端中进行现场演示的工具。<a href="https://github.com/sloria/doitlive" target="_blank" rel="external">官网</a></li>
<li>howdoi：通过命令行获取即时的编程问题解答。<a href="https://github.com/gleitz/howdoi" target="_blank" rel="external">官网</a></li>
<li>httpie：一个命令行HTTP 客户端，cURL 的替代品，易用性更好。<a href="https://github.com/jkbrzt/httpie" target="_blank" rel="external">官网</a></li>
<li>PathPicker：从bash输出中选出文件。<a href="https://github.com/facebook/PathPicker" target="_blank" rel="external">官网</a></li>
<li>percol：向UNIX shell 传统管道概念中加入交互式选择功能。<a href="https://github.com/mooz/percol" target="_blank" rel="external">官网</a></li>
<li>SAWS：一个加强版的 AWS 命令行。<a href="https://github.com/donnemartin/saws" target="_blank" rel="external">官网</a></li>
<li>thefuck：修正你之前的命令行指令。<a href="https://github.com/nvbn/thefuck" target="_blank" rel="external">官网</a></li>
<li>mycli：一个 MySQL 命令行客户端，具有自动补全和语法高亮功能。<a href="https://github.com/dbcli/mycli" target="_blank" rel="external">官网</a></li>
<li>pgcli：Postgres 命令行工具，具有自动补全和语法高亮功能。<a href="https://github.com/dbcli/pgcli" target="_blank" rel="external">官网</a></li>
<li>try：一个从来没有更简单的命令行工具，用来试用python库。<a href="https://github.com/timofurrer/try" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h3><p>用来进行下载的库.</p>
<ul>
<li>s3cmd：一个用来管理Amazon S3 和 CloudFront 的命令行工具。<a href="https://github.com/s3tools/s3cmd" target="_blank" rel="external">官网</a></li>
<li>s4cmd：超级 S3 命令行工具，性能更加强劲。<a href="https://github.com/bloomreach/s4cmd" target="_blank" rel="external">官网</a></li>
<li>you-get：一个 YouTube/Youku/Niconico 视频下载器，使用 Python3 编写。<a href="https://www.soimort.org/you-get/" target="_blank" rel="external">官网</a></li>
<li>youtube-dl：一个小巧的命令行程序，用来下载 YouTube 视频。<a href="http://rg3.github.io/youtube-dl/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>用来操作图像的库.</p>
<ul>
<li><a href="http://hao.jobbole.com/pillow/" target="_blank" rel="external">pillow</a>：Pillow 是一个更加易用版的 <a href="http://www.pythonware.com/products/pil/" target="_blank" rel="external">PIL</a>。<a href="http://pillow.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>hmap：图像直方图映射。<a href="https://github.com/rossgoodwin/hmap" target="_blank" rel="external">官网</a></li>
<li>imgSeek：一个使用视觉相似性搜索一组图片集合的项目。<a href="https://sourceforge.net/projects/imgseek/" target="_blank" rel="external">官网</a></li>
<li>nude.py：裸体检测。<a href="https://github.com/hhatto/nude.py" target="_blank" rel="external">官网</a></li>
<li>pyBarcode：不借助 PIL 库在 Python 程序中生成条形码。<a href="https://pythonhosted.org/pyBarcode/" target="_blank" rel="external">官网</a></li>
<li>pygram：类似 Instagram 的图像滤镜。<a href="https://github.com/ajkumar25/pygram" target="_blank" rel="external">官网</a></li>
<li>python-qrcode：一个纯 Python 实现的二维码生成器。<a href="https://github.com/lincolnloop/python-qrcode" target="_blank" rel="external">官网</a></li>
<li>Quads：基于四叉树的计算机艺术。<a href="https://github.com/fogleman/Quads" target="_blank" rel="external">官网</a></li>
<li>scikit-image：一个用于（科学）图像处理的 Python 库。<a href="http://scikit-image.org/" target="_blank" rel="external">官网</a></li>
<li>thumbor：一个小型图像服务，具有剪裁，尺寸重设和翻转功能。<a href="https://github.com/thumbor/thumbor" target="_blank" rel="external">官网</a></li>
<li>wand：<a href="http://www.imagemagick.org/script/magick-wand.php" target="_blank" rel="external">MagickWand</a>的Python 绑定。MagickWand 是 ImageMagick的 C API 。<a href="https://github.com/dahlia/wand" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h3><p>光学字符识别库。</p>
<ul>
<li>pyocr：Tesseract 和 Cuneiform 的一个封装(wrapper)。<a href="https://github.com/jflesch/pyocr" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pytesseract/" target="_blank" rel="external">pytesseract</a>：<a href="https://github.com/tesseract-ocr" target="_blank" rel="external">Google Tesseract OCR</a> 的另一个封装(wrapper)。<a href="https://github.com/madmaze/pytesseract" target="_blank" rel="external">官网</a></li>
<li>python-tesseract - <a href="https://github.com/tesseract-ocr" target="_blank" rel="external">Google Tesseract OCR</a> 的一个包装类。</li>
</ul>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><p>用来操作音频的库</p>
<ul>
<li>audiolazy：Python 的数字信号处理包。<a href="https://github.com/danilobellini/audiolazy" target="_blank" rel="external">官网</a> </li>
<li>audioread：交叉库 (GStreamer + Core Audio + MAD + FFmpeg) 音频解码。<a href="https://github.com/beetbox/audioread" target="_blank" rel="external">官网</a></li>
<li>beets：一个音乐库管理工具及 <a href="https://musicbrainz.org/" target="_blank" rel="external">MusicBrainz</a> 标签添加工具<a href="http://beets.io/" target="_blank" rel="external">官网</a></li>
<li>dejavu：音频指纹提取和识别<a href="https://github.com/worldveil/dejavu" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/django-elastic-transcoder/" target="_blank" rel="external">django-elastic-transcoder</a>：Django + <a href="http://aws.amazon.com/elastictranscoder/" target="_blank" rel="external">Amazon Elastic Transcoder</a>。<a href="https://github.com/StreetVoice/django-elastic-transcoder" target="_blank" rel="external">官网</a></li>
<li>eyeD3：一个用来操作音频文件的工具，具体来讲就是包含 ID3 元信息的 MP3 文件。<a href="http://eyed3.nicfit.net/" target="_blank" rel="external">官网</a></li>
<li>id3reader：一个用来读取 MP3 元数据的 Python 模块。<a href="http://nedbatchelder.com/code/modules/id3reader.py" target="_blank" rel="external">官网</a></li>
<li>m3u8：一个用来解析 m3u8 文件的模块。<a href="https://github.com/globocom/m3u8" target="_blank" rel="external">官网</a></li>
<li>mutagen：一个用来处理音频元数据的 Python 模块。<a href="https://bitbucket.org/lazka/mutagen" target="_blank" rel="external">官网</a></li>
<li>pydub：通过简单、简洁的高层接口来操作音频文件。<a href="https://github.com/jiaaro/pydub" target="_blank" rel="external">官网</a></li>
<li>pyechonest：<a href="http://developer.echonest.com/" target="_blank" rel="external">Echo Nest</a> API 的 Python 客户端<a href="https://github.com/echonest/pyechonest" target="_blank" rel="external">官网</a></li>
<li>talkbox：一个用来处理演讲/信号的 Python 库<a href="http://scikits.appspot.com/talkbox" target="_blank" rel="external">官网</a></li>
<li>TimeSide：开源 web 音频处理框架。<a href="https://github.com/Parisson/TimeSide" target="_blank" rel="external">官网</a></li>
<li>tinytag：一个用来读取MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库。<a href="https://github.com/devsnd/tinytag" target="_blank" rel="external">官网</a></li>
<li>mingus：一个高级音乐理论和曲谱包，支持 MIDI 文件和回放功能。<a href="http://bspaans.github.io/python-mingus/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h3><p>用来操作视频和GIF的库。</p>
<ul>
<li>moviepy：一个用来进行基于脚本的视频编辑模块，适用于多种格式，包括动图 GIFs。<a href="http://zulko.github.io/moviepy/" target="_blank" rel="external">官网</a></li>
<li>scikit-video：SciPy 视频处理常用程序。<a href="https://github.com/aizvorski/scikit-video" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h3><p>地理编码地址以及用来处理经纬度的库。</p>
<ul>
<li>GeoDjango：世界级地理图形 web 框架。<a href="https://docs.djangoproject.com/en/dev/ref/contrib/gis/" target="_blank" rel="external">官网</a></li>
<li>GeoIP：MaxMind GeoIP Legacy 数据库的 Python API。<a href="https://github.com/maxmind/geoip-api-python" target="_blank" rel="external">官网</a></li>
<li>geojson：GeoJSON 的 Python 绑定及工具。<a href="https://github.com/frewsxcv/python-geojson" target="_blank" rel="external">官网</a></li>
<li>geopy：Python 地址编码工具箱。<a href="https://github.com/geopy/geopy" target="_blank" rel="external">官网</a></li>
<li>pygeoip：纯 Python GeoIP API。<a href="https://github.com/appliedsec/pygeoip" target="_blank" rel="external">官网</a></li>
<li>django-countries：一个 Django 应用程序，提供用于表格的国家选择功能，国旗图标静态文件以及模型中的国家字段。<a href="https://github.com/SmileyChris/django-countries" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>使用HTTP的库。</p>
<ul>
<li>requests：人性化的HTTP请求库。<a href="http://docs.python-requests.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>grequests：requests 库 + gevent ，用于异步 HTTP 请求.<a href="https://github.com/kennethreitz/grequests" target="_blank" rel="external">官网</a></li>
<li>httplib2：全面的 HTTP 客户端库。<a href="https://github.com/jcgregorio/httplib2" target="_blank" rel="external">官网</a></li>
<li>treq：类似 requests 的Python API 构建于 Twisted HTTP 客户端之上。<a href="https://github.com/twisted/treq" target="_blank" rel="external">官网</a></li>
<li>urllib3：一个具有线程安全连接池，支持文件 post，清晰友好的 HTTP 库。<a href="https://github.com/shazow/urllib3" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>Python实现的数据库。</p>
<ul>
<li>pickleDB：一个简单，轻量级键值储存数据库。<a href="https://pythonhosted.org/pickleDB/" target="_blank" rel="external">官网</a></li>
<li>PipelineDB：流式 SQL 数据库。<a href="https://www.pipelinedb.com/" target="_blank" rel="external">官网</a></li>
<li>TinyDB：一个微型的，面向文档型数据库。<a href="https://github.com/msiemens/tinydb" target="_blank" rel="external">官网</a></li>
<li>ZODB：一个 Python 原生对象数据库。一个键值和对象图数据库。<a href="http://www.zodb.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据库驱动"><a href="#数据库驱动" class="headerlink" title="数据库驱动"></a>数据库驱动</h3><p>用来连接和操作数据库的库。</p>
<ul>
<li>MySQL：<a href="http://shlomi-noach.github.io/awesome-mysql/" target="_blank" rel="external">awesome-mysql</a>系列<ul>
<li>mysql-python：Python 的 MySQL 数据库连接器。<a href="https://sourceforge.net/projects/mysql-python/" target="_blank" rel="external">官网</a></li>
<li>ysqlclient：<a href="https://github.com/PyMySQL/mysqlclient-python" target="_blank" rel="external">mysql-python</a> 分支，支持 Python 3。</li>
<li>oursql：一个更好的 MySQL 连接器，支持原生预编译指令和 BLOBs.<a href="https://pythonhosted.org/oursql/" target="_blank" rel="external">官网</a></li>
<li>PyMySQL：纯 Python MySQL 驱动，兼容 mysql-python。<a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>PostgreSQL<ul>
<li>psycopg2：Python 中最流行的 PostgreSQL 适配器。<a href="http://initd.org/psycopg/" target="_blank" rel="external">官网</a></li>
<li>queries：psycopg2 库的封装，用来和 PostgreSQL 进行交互。<a href="https://github.com/gmr/queries" target="_blank" rel="external">官网</a></li>
<li>txpostgres：基于 Twisted 的异步 PostgreSQL 驱动。<a href="http://txpostgres.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>其他关系型数据库<ul>
<li>apsw：另一个 Python SQLite封装。<a href="http://rogerbinns.github.io/apsw/" target="_blank" rel="external">官网</a></li>
<li>dataset：在数据库中存储Python字典</li>
<li>pymssql：一个简单的Microsoft SQL Server数据库接口。<a href="http://www.pymssql.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>NoSQL 数据库<ul>
<li>cassandra-python-driver：Cassandra 的 Python 驱动。<a href="https://github.com/datastax/python-driver" target="_blank" rel="external">官网</a></li>
<li>HappyBase：一个为 Apache HBase 设计的，对开发者友好的库。<a href="http://happybase.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Plyvel：一个快速且功能丰富的 LevelDB 的 Python 接口。<a href="https://plyvel.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>py2neo：Neo4j restful 接口的Python 封装客户端。<a href="http://py2neo.org/2.0/" target="_blank" rel="external">官网</a></li>
<li>pycassa：Cassandra 的 Python Thrift 驱动。<a href="https://github.com/pycassa/pycassa" target="_blank" rel="external">官网</a></li>
<li>PyMongo：MongoDB 的官方 Python 客户端。<a href="https://docs.mongodb.org/ecosystem/drivers/python/" target="_blank" rel="external">官网</a></li>
<li>redis-py：Redis 的 Python 客户端。<a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="external">官网</a></li>
<li>telephus：基于 Twisted 的 Cassandra 客户端。<a href="https://github.com/driftx/Telephus" target="_blank" rel="external">官网</a></li>
<li>txRedis：基于 Twisted 的 Redis 客户端。<a href="https://github.com/deldotdr/txRedis" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>实现对象关系映射或数据映射技术的库。</p>
<ul>
<li>关系型数据库<ul>
<li>Django Models：Django 的一部分。<a href="https://docs.djangoproject.com/en/dev/topics/db/models/" target="_blank" rel="external">官网</a></li>
<li>SQLAlchemy：Python SQL 工具以及对象关系映射工具。<a href="http://www.sqlalchemy.org/" target="_blank" rel="external">官网</a><ul>
<li><a href="https://github.com/dahlia/awesome-sqlalchemy" target="_blank" rel="external">awesome-sqlalchemy</a>系列</li>
</ul>
</li>
<li><a href="http://hao.jobbole.com/peewee/" target="_blank" rel="external">Peewee</a>：一个小巧，富有表达力的 ORM。<a href="https://github.com/coleifer/peewee" target="_blank" rel="external">官网</a></li>
<li>PonyORM：提供面向生成器的 SQL 接口的 ORM。<a href="https://ponyorm.com/" target="_blank" rel="external">官网</a></li>
<li>python-sql：编写 Python 风格的 SQL 查询。<a href="https://pypi.python.org/pypi/python-sql" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>NoSQL 数据库<ul>
<li>django-mongodb-engine：Django MongoDB 后端。<a href="https://github.com/django-nonrel/mongodb-engine" target="_blank" rel="external">官网</a></li>
<li>PynamoDB：<a href="https://aws.amazon.com/dynamodb/" target="_blank" rel="external">Amazon DynamoDB</a> 的一个 Python 风格接口。<a href="https://github.com/jlafon/PynamoDB" target="_blank" rel="external">官网</a></li>
<li>flywheel：Amazon DynamoDB 的对象映射工具。<a href="https://github.com/mathcamp/flywheel" target="_blank" rel="external">官网</a></li>
<li>MongoEngine：一个Python 对象文档映射工具，用于 MongoDB。<a href="http://mongoengine.org/" target="_blank" rel="external">官网</a></li>
<li>hot-redis：为 Redis 提供 Python 丰富的数据类型。<a href="https://github.com/stephenmcd/hot-redis" target="_blank" rel="external">官网</a></li>
<li>redisco：一个 Python 库，提供可以持续存在在 Redis 中的简单模型和容器。<a href="https://github.com/kiddouk/redisco" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>其他<ul>
<li>butterdb：Google Drive 电子表格的 Python ORM。<a href="https://github.com/Widdershin/butterdb" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h3><p>全栈 Web 框架。</p>
<ul>
<li><a href="http://hao.jobbole.com/django/" target="_blank" rel="external">Django</a>：Python 界最流行的 web 框架。<a href="https://www.djangoproject.com/" target="_blank" rel="external">官网</a><ul>
<li><a href="https://github.com/rosarior/awesome-django" target="_blank" rel="external">awesome-django</a>系列</li>
</ul>
</li>
<li><a href="http://hao.jobbole.com/flask/" target="_blank" rel="external">Flask</a>：一个 Python 微型框架。<a href="http://flask.pocoo.org/" target="_blank" rel="external">官网</a><ul>
<li><a href="https://github.com/humiaozuzu/awesome-flask" target="_blank" rel="external">awesome-flask</a>系列</li>
</ul>
</li>
<li>pyramid：一个小巧，快速，接地气的开源Python web 框架。<ul>
<li><a href="https://github.com/uralbash/awesome-pyramid" target="_blank" rel="external">awesome-pyramid</a>系列</li>
</ul>
</li>
<li><a href="http://hao.jobbole.com/bottle/" target="_blank" rel="external">Bottle</a>：一个快速小巧，轻量级的 WSGI 微型 web 框架。<a href="http://bottlepy.org/docs/dev/index.html" target="_blank" rel="external">官网</a></li>
<li>CherryPy：一个极简的 Python web 框架，服从 HTTP/1.1 协议且具有WSGI 线程池。<a href="http://www.cherrypy.org/" target="_blank" rel="external">官网</a></li>
<li>TurboGears：一个可以扩展为全栈解决方案的微型框架。<a href="http://www.turbogears.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-webpy/" target="_blank" rel="external">web.py</a>：一个 Python 的 web 框架，既简单，又强大。<a href="http://webpy.org/" target="_blank" rel="external">官网</a></li>
<li>web2py：一个全栈 web 框架和平台，专注于简单易用。<a href="http://www.web2py.com/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/tornado/" target="_blank" rel="external">Tornado</a>：一个web 框架和异步网络库。<a href="http://www.tornadoweb.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>允许或拒绝用户访问数据或功能的库。</p>
<ul>
<li>Carteblanche：Module to align code with thoughts of users and designers. Also magically handles navigation and permissions.<a href="https://github.com/neuman/python-carteblanche/" target="_blank" rel="external">官网</a></li>
<li>django-guardian：Django 1.2+ 实现了单个对象权限。<a href="https://github.com/django-guardian/django-guardian" target="_blank" rel="external">官网</a></li>
<li>django-rules：一个小巧但是强大的应用，提供对象级别的权限管理，且不需要使用数据库。<a href="https://github.com/dfunckt/django-rules" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>内容管理系统</p>
<ul>
<li>odoo-cms: 一个开源的，企业级 CMS，基于odoo。<a href="http://www.odoo.com" target="_blank" rel="external">官网</a></li>
<li>django-cms：一个开源的，企业级 CMS，基于 Django。<a href="http://www.django-cms.org/en/" target="_blank" rel="external">官网</a></li>
<li>djedi-cms：一个轻量级但却非常强大的 Django CMS ，考虑到了插件，内联编辑以及性能。<a href="http://djedi-cms.org/" target="_blank" rel="external">官网</a></li>
<li>FeinCMS：基于 Django 构建的最先进的内容管理系统之一。<a href="http://www.feincms.org/" target="_blank" rel="external">官网</a></li>
<li>Kotti：一个高级的，Python 范的 web 应用框架，基于 Pyramid 构建。<a href="http://kotti.pylonsproject.org/" target="_blank" rel="external">官网</a></li>
<li>Mezzanine：一个强大的，持续的，灵活的内容管理平台。<a href="http://mezzanine.jupo.org/" target="_blank" rel="external">官网</a></li>
<li>Opps：一个为杂志，报纸网站以及大流量门户网站设计的 CMS 平台，基于 Django。<a href="http://opps.github.io/opps/" target="_blank" rel="external">官网</a></li>
<li>Plone：一个构建于开源应用服务器 Zope 之上的 CMS。<a href="https://plone.org/" target="_blank" rel="external">官网</a></li>
<li>Quokka：灵活，可扩展的小型 CMS，基于 Flask 和 MongoDB。<a href="http://quokkaproject.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/wagtail/" target="_blank" rel="external">Wagtail</a>：一个 Django 内容管理系统。<a href="https://wagtail.io/" target="_blank" rel="external">官网</a></li>
<li>Widgy：最新的 CMS 框架，基于 Django。<a href="https://wid.gy/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="电子商务"><a href="#电子商务" class="headerlink" title="电子商务"></a>电子商务</h3><p>用于电子商务以及支付的框架和库。</p>
<ul>
<li>django-oscar：一个用于 Django 的开源的电子商务框架。<a href="http://oscarcommerce.com/" target="_blank" rel="external">官网</a></li>
<li>django-shop：一个基于 Django 的店铺系统。<a href="https://github.com/awesto/django-shop" target="_blank" rel="external">官网</a></li>
<li>Cartridge：一个基于 Mezzanine 构建的购物车应用。<a href="https://github.com/stephenmcd/cartridge" target="_blank" rel="external">官网</a></li>
<li>shoop：一个基于 Django 的开源电子商务平台。<a href="https://www.shoop.io/en/" target="_blank" rel="external">官网</a></li>
<li>alipay：非官方的 Python 支付宝 API。<a href="https://github.com/lxneng/alipay" target="_blank" rel="external">官网</a></li>
<li>merchant：一个可以接收来自多种支付平台支付的 Django 应用。<a href="https://github.com/agiliq/merchant" target="_blank" rel="external">官网</a></li>
<li>money：货币类库with optional CLDR-backed locale-aware formatting and an extensible currency exchange solution.<a href="https://github.com/carlospalol/money" target="_blank" rel="external">官网</a></li>
<li>python-currencies：显示货币格式以及它的数值。<a href="https://github.com/Alir3z4/python-currencies" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>用来开发RESTful APIs的库</p>
<ul>
<li>Django<ul>
<li><a href="http://hao.jobbole.com/django-rest-framework/" target="_blank" rel="external">django-rest-framework</a>：一个强大灵活的工具，用来构建 web API。<a href="http://www.django-rest-framework.org/" target="_blank" rel="external">官网</a></li>
<li>django-tastypie：为Django 应用开发API。<a href="http://tastypieapi.org/" target="_blank" rel="external">官网</a></li>
<li>django-formapi：为 Django 的表单验证，创建 JSON APIs 。<a href="https://github.com/5monkeys/django-formapi" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Flask<ul>
<li>flask-api：为 flask 开发的，可浏览 Web APIs 。<a href="http://www.flaskapi.org/" target="_blank" rel="external">官网</a></li>
<li>flask-restful：为 flask 快速创建REST APIs 。<a href="http://flask-restful.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>flask-restless：为 SQLAlchemy 定义的数据库模型创建 RESTful APIs 。<a href="https://flask-restless.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>flask-api-utils：为 Flask 处理 API 表示和验证。<a href="https://github.com/marselester/flask-api-utils" target="_blank" rel="external">官网</a></li>
<li>eve：REST API 框架，由 Flask, MongoDB 等驱动。<a href="https://github.com/nicolaiarocci/eve" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Pyramid<ul>
<li>cornice：一个Pyramid 的 REST 框架 。<a href="https://cornice.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>与框架无关的<ul>
<li>falcon：一个用来建立云 API 和 web app 后端的高性能框架。<a href="http://falconframework.org/" target="_blank" rel="external">官网</a></li>
<li>sandman：为现存的数据库驱动系统自动创建 REST APIs 。<a href="https://github.com/jeffknupp/sandman" target="_blank" rel="external">官网</a></li>
<li>restless：框架无关的 REST 框架 ，基于从 Tastypie 学到的知识。<a href="http://restless.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>ripozo：快速创建 REST/HATEOAS/Hypermedia APIs。<a href="https://github.com/vertical-knowledge/ripozo" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>实现验证方案的库。</p>
<ul>
<li>OAuth<ul>
<li>Authomatic：简单但是强大的框架，身份验证/授权客户端。<a href="http://peterhudec.github.io/authomatic/" target="_blank" rel="external">官网</a></li>
<li>django-allauth：Django 的验证应用。<a href="https://github.com/pennersr/django-allauth" target="_blank" rel="external">官网</a></li>
<li>django-oauth-toolkit：为 Django 用户准备的 OAuth2。<a href="https://github.com/evonove/django-oauth-toolkit" target="_blank" rel="external">官网</a></li>
<li>django-oauth2-provider：为 Django 应用提供 OAuth2 接入。<a href="https://github.com/caffeinehit/django-oauth2-provider" target="_blank" rel="external">官网</a></li>
<li>Flask-OAuthlib：OAuth 1.0/a, 2.0 客户端实现，供 Flask 使用。<a href="https://github.com/lepture/flask-oauthlib" target="_blank" rel="external">官网</a></li>
<li>OAuthLib：一个 OAuth 请求-签名逻辑通用、 完整的实现。<a href="https://github.com/idan/oauthlib" target="_blank" rel="external">官网</a></li>
<li>python-oauth2：一个完全测试的抽象接口。用来创建 OAuth 客户端和服务端。<a href="https://github.com/joestump/python-oauth2" target="_blank" rel="external">官网</a></li>
<li>python-social-auth：一个设置简单的社会化验证方式。<a href="https://github.com/omab/python-social-auth" target="_blank" rel="external">官网</a></li>
<li>rauth：OAuth 1.0/a, 2.0, 和 Ofly 的 Python 库。<a href="https://github.com/litl/rauth" target="_blank" rel="external">官网</a></li>
<li>sanction：一个超级简单的OAuth2 客户端实现。<a href="https://github.com/demianbrecht/sanction" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>其他<ul>
<li>jose：JavaScript 对象签名和加密草案的实现。<a href="https://github.com/demonware/jose" target="_blank" rel="external">官网</a></li>
<li>PyJWT：JSON Web 令牌草案 01。<a href="https://github.com/jpadilla/pyjwt" target="_blank" rel="external">官网</a></li>
<li>python-jws：JSON Web 签名草案 02 的实现。<a href="https://github.com/brianloveswords/python-jws" target="_blank" rel="external">官网</a></li>
<li>python-jwt：一个用来生成和验证 JSON Web 令牌的模块。<a href="https://github.com/davedoesdev/python-jwt" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>模板生成和词法解析的库和工具。</p>
<ul>
<li><a href="http://hao.jobbole.com/jinja2/" target="_blank" rel="external">Jinja2</a>：一个现代的，对设计师友好的模板引擎。<a href="https://github.com/pallets/jinja" target="_blank" rel="external">官网</a></li>
<li>Chameleon：一个 HTML/XML 模板引擎。 模仿了 ZPT（Zope Page Templates）, 进行了速度上的优化。<a href="https://chameleon.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Genshi：Python 模板工具，用以生成 web 感知的结果。<a href="https://genshi.edgewall.org/" target="_blank" rel="external">官网</a></li>
<li>Mako：Python 平台的超高速轻量级模板。<a href="http://www.makotemplates.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>处理事件以及任务队列的库。</p>
<ul>
<li>celery：一个异步任务队列/作业队列，基于分布式消息传递。<a href="http://www.celeryproject.org/" target="_blank" rel="external">官网</a></li>
<li>huey：小型多线程任务队列。<a href="https://github.com/coleifer/huey" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/mrq/" target="_blank" rel="external">mrq</a>：Mr. Queue -一个 Python 的分布式 worker 任务队列， 使用 Redis 和 gevent。<a href="https://github.com/pricingassistant/mrq" target="_blank" rel="external">官网</a></li>
<li>rq：简单的 Python 作业队列。<a href="http://python-rq.org/" target="_blank" rel="external">官网</a></li>
<li>simpleq：一个简单的，可无限扩张的，基于亚马逊 SQS 的队列。<a href="https://github.com/rdegges/simpleq" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>对数据进行索引和执行搜索查询的库和软件。</p>
<ul>
<li>django-haystack：Django 模块化搜索。<a href="https://github.com/django-haystack/django-haystack" target="_blank" rel="external">官网</a></li>
<li>elasticsearch-py：Elasticsearch 的官方底层 Python 客户端。<a href="https://www.elastic.co/guide/en/elasticsearch/client/python-api/current/index.html" target="_blank" rel="external">官网</a></li>
<li>elasticsearch-dsl-py：Elasticsearch 的官方高级 Python 客户端。<a href="https://github.com/elastic/elasticsearch-dsl-py" target="_blank" rel="external">官网</a> </li>
<li>solrpy：<a href="http://lucene.apache.org/solr/" target="_blank" rel="external">solr</a>的 Python 客户端。<a href="https://github.com/edsu/solrpy" target="_blank" rel="external">官网</a></li>
<li>Whoosh：一个快速的纯 Python 搜索引擎库。<a href="http://whoosh.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="动态消息"><a href="#动态消息" class="headerlink" title="动态消息"></a>动态消息</h3><p>用来创建用户活动的库。</p>
<ul>
<li>django-activity-stream：从你的站点行为中生成通用活动信息流。<a href="https://github.com/justquick/django-activity-stream" target="_blank" rel="external">官网</a></li>
<li>Stream-Framework：使用 Cassandra 和 Redis 创建动态消息和通知系统。<a href="https://github.com/tschellenbach/Stream-Framework" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>管理、压缩、缩小网站资源的工具。</p>
<ul>
<li>django-compressor：将链接和内联的 JavaScript 或 CSS 压缩到一个单独的缓存文件中。<a href="https://github.com/django-compressor/django-compressor" target="_blank" rel="external">官网</a></li>
<li>django-storages：一个针对 Django 的自定义存储后端的工具集合。<a href="http://django-storages.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>fanstatic：打包、优化，并且把静态文件依赖作为 Python 的包来提供。<a href="http://www.fanstatic.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>File Conveyor：一个后台驻留的程序，用来发现和同步文件到 CDNs, S3 和 FTP。<a href="http://fileconveyor.org/" target="_blank" rel="external">官网</a></li>
<li>Flask-Assets：帮你将 web 资源整合到你的 Flask app 中。<a href="http://flask-assets.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>jinja-assets-compressor：一个 Jinja 扩展，用来编译和压缩你的资源。<a href="https://github.com/jaysonsantos/jinja-assets-compressor" target="_blank" rel="external">官网</a></li>
<li>webassets：为你的静态资源打包、优化和管理生成独一无二的缓存 URL。<a href="http://webassets.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存数据的库。</p>
<ul>
<li>Beaker：一个缓存和会话库，可以用在 web 应用和独立 Python脚本和应用上。<a href="http://beaker.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>django-cache-machine：Django 模型的自动缓存和失效。<a href="https://github.com/django-cache-machine/django-cache-machine" target="_blank" rel="external">官网</a></li>
<li>django-cacheops：具有自动颗粒化事件驱动失效功能的 ORM。<a href="https://github.com/Suor/django-cacheops" target="_blank" rel="external">官网</a></li>
<li>django-viewlet：渲染模板，同时具有额外的缓存控制功能。<a href="https://github.com/5monkeys/django-viewlet" target="_blank" rel="external">官网</a></li>
<li>dogpile.cache：dogpile.cache 是 Beaker 的下一代替代品，由同一作者开发。<a href="http://dogpilecache.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>HermesCache：Python 缓存库，具有基于标签的失效和 dogpile effect 保护功能。<a href="https://pypi.python.org/pypi/HermesCache" target="_blank" rel="external">官网</a></li>
<li>johnny-cache：django应用缓存框架。<a href="https://github.com/jmoiron/johnny-cache" target="_blank" rel="external">官网</a></li>
<li>pylibmc：<a href="http://libmemcached.org/libMemcached.html" target="_blank" rel="external">libmemcached</a> 接口的 Python 封装。<a href="https://github.com/lericson/pylibmc" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>用来发送和解析电子邮件的库。</p>
<ul>
<li>django-celery-ses：带有 AWS SES 和 Celery 的 Django email 后端。<a href="https://github.com/StreetVoice/django-celery-ses" target="_blank" rel="external">官网</a></li>
<li>envelopes：供人类使用的电子邮件库。<a href="http://tomekwojcik.github.io/envelopes/" target="_blank" rel="external">官网</a></li>
<li>flanker：一个 email 地址和 Mime 解析库。<a href="https://github.com/mailgun/flanker" target="_blank" rel="external">官网</a></li>
<li>imbox：Python IMAP 库<a href="https://github.com/martinrusev/imbox" target="_blank" rel="external">官网</a></li>
<li>inbox.py：Python SMTP 服务器。<a href="https://github.com/kennethreitz/inbox.py" target="_blank" rel="external">官网</a></li>
<li>inbox：一个开源电子邮件工具箱。<a href="https://github.com/nylas/sync-engine" target="_blank" rel="external">官网</a></li>
<li>lamson：Python 风格的 SMTP 应用服务器。<a href="https://github.com/zedshaw/lamson" target="_blank" rel="external">官网</a></li>
<li>mailjet：Mailjet API 实现，用来提供批量发送邮件，统计等功能。<a href="https://github.com/WoLpH/mailjet" target="_blank" rel="external">官网</a></li>
<li>marrow.mailer：高性能可扩展邮件分发框架。<a href="https://github.com/marrow/mailer" target="_blank" rel="external">官网</a></li>
<li>modoboa：一个邮件托管和管理平台，具有现代的、简约的 Web UI。<a href="https://github.com/tonioo/modoboa" target="_blank" rel="external">官网</a></li>
<li>pyzmail：创建，发送和解析电子邮件。<a href="http://www.magiksys.net/pyzmail/" target="_blank" rel="external">官网</a></li>
<li>Talon：Mailgun 库，用来抽取信息和签名。<a href="https://github.com/mailgun/talon" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>用来进行国际化的库。</p>
<ul>
<li>Babel：一个Python 的国际化库。<a href="http://babel.pocoo.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Korean：一个韩语词态库。<a href="https://korean.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="URL处理"><a href="#URL处理" class="headerlink" title="URL处理"></a>URL处理</h3><p>解析URLs的库</p>
<ul>
<li>furl：一个让处理 URL 更简单小型 Python 库。<a href="https://github.com/gruns/furl" target="_blank" rel="external">官网</a></li>
<li>purl：一个简单的，不可变的URL类，具有简洁的 API 来进行询问和处理。<a href="https://github.com/codeinthehole/purl" target="_blank" rel="external">官网</a></li>
<li>pyshorteners：一个纯 Python URL 缩短库。<a href="https://github.com/ellisonleao/pyshorteners" target="_blank" rel="external">官网</a></li>
<li>shorturl：生成短小 URL 和类似 bit.ly 短链的Python 实现。<a href="https://github.com/Alir3z4/python-shorturl" target="_blank" rel="external">官网</a></li>
<li>webargs：一个解析 HTTP 请求参数的库，内置对流行 web 框架的支持，包括 Flask, Django, Bottle, Tornado和 Pyramid。<a href="https://github.com/sloria/webargs" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="HTML处理"><a href="#HTML处理" class="headerlink" title="HTML处理"></a>HTML处理</h3><p>处理 HTML和XML的库。</p>
<ul>
<li>BeautifulSoup：以 Python 风格的方式来对 HTML 或 XML 进行迭代，搜索和修改。<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="external">官网</a></li>
<li>bleach：一个基于白名单的 HTML 清理和文本链接库。<a href="http://bleach.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>cssutils：一个 Python 的 CSS 库。<a href="https://pypi.python.org/pypi/cssutils/" target="_blank" rel="external">官网</a></li>
<li>html5lib：一个兼容标准的 HTML 文档和片段解析及序列化库。<a href="https://github.com/html5lib/html5lib-python" target="_blank" rel="external">官网</a></li>
<li>lxml：一个非常快速，简单易用，功能齐全的库，用来处理 HTML 和 XML。<a href="http://lxml.de/" target="_blank" rel="external">官网</a></li>
<li>MarkupSafe：为Python 实现 XML/HTML/XHTML 标记安全字符串。<a href="https://github.com/pallets/markupsafe" target="_blank" rel="external">官网</a></li>
<li>pyquery：一个解析 HTML 的库，类似 jQuery。<a href="https://github.com/gawel/pyquery" target="_blank" rel="external">官网</a></li>
<li>untangle：将XML文档转换为Python对象，使其可以方便的访问。<a href="https://github.com/stchris/untangle" target="_blank" rel="external">官网</a></li>
<li>xhtml2pdf：HTML/CSS 转 PDF 工具。<a href="https://github.com/xhtml2pdf/xhtml2pdf" target="_blank" rel="external">官网</a></li>
<li>xmltodict：像处理 JSON 一样处理 XML。<a href="https://github.com/martinblech/xmltodict" target="_blank" rel="external">官网</a></li>
</ul>
<p>爬取网络站点的库</p>
<ul>
<li>Scrapy：一个快速高级的屏幕爬取及网页采集框架。<a href="http://scrapy.org/" target="_blank" rel="external">官网</a></li>
<li>cola：一个分布式爬虫框架。<a href="https://github.com/chineking/cola" target="_blank" rel="external">官网</a></li>
<li>Demiurge：基于PyQuery 的爬虫微型框架。<a href="https://github.com/matiasb/demiurge" target="_blank" rel="external">官网</a></li>
<li>feedparser：通用 feed 解析器。<a href="http://pythonhosted.org/feedparser/" target="_blank" rel="external">官网</a></li>
<li>Grab：站点爬取框架。<a href="http://grablib.org/" target="_blank" rel="external">官网</a></li>
<li>MechanicalSoup：用于自动和网络站点交互的 Python 库。<a href="https://github.com/hickford/MechanicalSoup" target="_blank" rel="external">官网</a></li>
<li>portia：Scrapy 可视化爬取。<a href="https://github.com/scrapinghub/portia" target="_blank" rel="external">官网</a></li>
<li>pyspider：一个强大的爬虫系统。<a href="https://github.com/binux/pyspider" target="_blank" rel="external">官网</a></li>
<li>RoboBrowser：一个简单的，Python 风格的库，用来浏览网站，而不需要一个独立安装的浏览器。<a href="https://github.com/jmcarp/robobrowser" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="网页内容提取"><a href="#网页内容提取" class="headerlink" title="网页内容提取"></a>网页内容提取</h3><p>用于进行网页内容提取的库。</p>
<ul>
<li>Haul：一个可以扩展的图像爬取工具。<a href="https://github.com/vinta/Haul" target="_blank" rel="external">官网</a></li>
<li>html2text：将 HTML 转换为 Markdown 格式文本<a href="https://github.com/Alir3z4/html2text" target="_blank" rel="external">官网</a></li>
<li>lassie：人性化的网页内容检索库。<a href="https://github.com/michaelhelmick/lassie" target="_blank" rel="external">官网</a></li>
<li>micawber：一个小型网页内容提取库，用来从 URLs 提取富内容。<a href="https://github.com/coleifer/micawber" target="_blank" rel="external">官网</a> </li>
<li><a href="http://hao.jobbole.com/python-newspaper/" target="_blank" rel="external">newspaper</a>：使用 Python 进行新闻提取，文章提取以及内容策展。<a href="https://github.com/codelucas/newspaper" target="_blank" rel="external">官网</a></li>
<li>opengraph：一个用来解析开放内容协议(Open Graph Protocol)的 Python模块。<a href="https://github.com/erikriver/opengraph" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-goose/" target="_blank" rel="external">python-goose</a>：HTML内容/文章提取器。<a href="https://github.com/grangier/python-goose" target="_blank" rel="external">官网</a></li>
<li>python-readability：arc90 公司 readability 工具的 Python 高速端口。<a href="https://github.com/buriy/python-readability" target="_blank" rel="external">官网</a></li>
<li>sanitize：为杂乱的数据世界带来调理性。<a href="https://github.com/Alir3z4/python-sanitize" target="_blank" rel="external">官网</a></li>
<li>sumy：一个为文本文件和 HTML 页面进行自动摘要的模块。<a href="https://github.com/miso-belica/sumy" target="_blank" rel="external">官网</a></li>
<li>textract：从任何格式的文档中提取文本，Word，PowerPoint，PDFs 等等。<a href="https://github.com/deanmalmgren/textract" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>进行表单操作的库。</p>
<ul>
<li>Deform：Python HTML 表单生成库，受到了 formish 表单生成库的启发。<a href="http://deform.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>django-bootstrap3：集成了 Bootstrap 3 的 Django。<a href="https://github.com/dyve/django-bootstrap3" target="_blank" rel="external">官网</a></li>
<li>django-crispy-forms：一个 Django 应用，他可以让你以一种非常优雅且 DRY（Don’t repeat yourself） 的方式来创建美观的表单。<a href="http://django-crispy-forms.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>django-remote-forms：一个平台独立的 Django 表单序列化工具。<a href="https://github.com/WiserTogether/django-remote-forms" target="_blank" rel="external">官网</a></li>
<li>WTForms：一个灵活的表单验证和呈现库。<a href="http://wtforms.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>WTForms-JSON：一个 WTForms 扩展，用来处理 JSON 数据。<a href="http://wtforms-json.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>数据验证库。多用于表单验证。</p>
<ul>
<li>Cerberus：A mappings-validator with a variety of rules, normalization-features and simple customization that uses a pythonic schema-definition.<a href="http://docs.python-cerberus.org/en/stable/" target="_blank" rel="external">官网</a></li>
<li>colander：一个用于对从 XML, JSON，HTML 表单获取的数据或其他同样简单的序列化数据进行验证和反序列化的系统。<a href="http://docs.pylonsproject.org/projects/colander/en/latest/" target="_blank" rel="external">官网</a></li>
<li>kmatch：一种用于匹配/验证/筛选 Python 字典的语言。<a href="https://github.com/ambitioninc/kmatch" target="_blank" rel="external">官网</a></li>
<li>schema：一个用于对 Python 数据结构进行验证的库。<a href="https://github.com/keleshev/schema" target="_blank" rel="external">官网</a> </li>
<li>Schematics：数据结构验证。<a href="https://github.com/schematics/schematics" target="_blank" rel="external">官网</a></li>
<li>valideer：轻量级可扩展的数据验证和适配库。<a href="https://github.com/podio/valideer" target="_blank" rel="external">官网</a></li>
<li>voluptuous：一个 Python 数据验证库。主要是为了验证传入 Python的 JSON，YAML 等数据。<a href="https://github.com/alecthomas/voluptuous" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="反垃圾技术"><a href="#反垃圾技术" class="headerlink" title="反垃圾技术"></a>反垃圾技术</h3><p>帮助你和电子垃圾进行战斗的库。</p>
<ul>
<li>django-simple-captcha：一个简单、高度可定制的Django 应用，可以为任何Django表单添加验证码。<a href="https://github.com/mbi/django-simple-captcha" target="_blank" rel="external">官网</a></li>
<li>django-simple-spam-blocker：一个用于Django的简单的电子垃圾屏蔽工具。<a href="https://github.com/moqada/django-simple-spam-blocker" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>用来进行标记的库。</p>
<ul>
<li>django-taggit：简单的 Django 标记工具。<a href="https://github.com/alex/django-taggit" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="管理面板"><a href="#管理面板" class="headerlink" title="管理面板"></a>管理面板</h3><p>管理界面库。</p>
<ul>
<li>Ajenti：一个你的服务器值得拥有的管理面板。<a href="https://github.com/Eugeny/ajenti" target="_blank" rel="external">官网</a></li>
<li>django-suit：Django 管理界面的一个替代品 (仅对于非商业用途是免费的)。<a href="http://djangosuit.com/" target="_blank" rel="external">官网</a></li>
<li>django-xadmin：Django admin 的一个替代品，具有很多不错的功能。<a href="https://github.com/sshwsfc/django-xadmin" target="_blank" rel="external">官网</a></li>
<li>flask-admin：一个用于 Flask 的简单可扩展的管理界面框架。<a href="https://github.com/flask-admin/flask-admin" target="_blank" rel="external">官网</a></li>
<li>flower：一个对 Celery 集群进行实时监控和提供 web 管理界面的工具。<a href="https://github.com/mher/flower" target="_blank" rel="external">官网</a></li>
<li>Grappelli：Django 管理界面的一个漂亮的皮肤。<a href="http://grappelliproject.com/" target="_blank" rel="external">官网</a> </li>
<li>Wooey：一个 Django 应用，可以为 Python 脚本创建 web 用户界面。<a href="https://github.com/wooey/wooey" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="静态站点生成器"><a href="#静态站点生成器" class="headerlink" title="静态站点生成器"></a>静态站点生成器</h3><p>静态站点生成器是一个软件，它把文本和模板作为输入，然后输出HTML文件。</p>
<ul>
<li>Pelican：使用 Markdown 或 ReST 来处理内容， Jinja 2 来制作主题。支持 DVCS, Disqus.。AGPL 许可。<a href="http://blog.getpelican.com/" target="_blank" rel="external">官网</a></li>
<li>Cactus：为设计师设计的静态站点生成器。<a href="https://github.com/koenbok/Cactus/" target="_blank" rel="external">官网</a> </li>
<li>Hyde：基于 Jinja2 的静态站点生成器。<a href="http://hyde.github.io/" target="_blank" rel="external">官网</a></li>
<li>Nikola：一个静态网站和博客生成器。<a href="https://www.getnikola.com/" target="_blank" rel="external">官网</a></li>
<li>Tinkerer：Tinkerer 是一个博客引擎/静态站点生成器，由Sphinx驱动。<a href="http://tinkerer.me/" target="_blank" rel="external">官网</a></li>
<li>Lektor：一个简单易用的静态 CMS 和博客引擎。<a href="https://www.getlektor.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统进程启动及通信库。</p>
<ul>
<li>envoy：比 Python <a href="https://docs.python.org/2/library/subprocess.html" target="_blank" rel="external">subprocess</a> 模块更人性化。<a href="https://github.com/kennethreitz/envoy" target="_blank" rel="external">官网</a></li>
<li>sarge：另一 种 subprocess 模块的封装。<a href="http://sarge.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>sh：一个完备的 subprocess 替代库。<a href="https://github.com/amoffat/sh" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>用以进行并发和并行操作的库。</p>
<ul>
<li>multiprocessing：(Python 标准库) 基于进程的“线程”接口。<a href="https://docs.python.org/2/library/multiprocessing.html" target="_blank" rel="external">官网</a></li>
<li>threading：(Python 标准库)更高层的线程接口。<a href="https://docs.python.org/2/library/threading.html" target="_blank" rel="external">官网</a></li>
<li>eventlet：支持 WSGI 的异步框架。<a href="http://eventlet.net/" target="_blank" rel="external">官网</a></li>
<li>gevent：一个基于协程的 Python 网络库，使用<a href="https://github.com/python-greenlet/greenlet" target="_blank" rel="external">greenlet</a>。<a href="http://www.gevent.org/" target="_blank" rel="external">官网</a></li>
<li>Tomorrow：用于产生异步代码的神奇的装饰器语法实现。<a href="https://github.com/madisonmay/Tomorrow" target="_blank" rel="external">官网</a></li>
<li>uvloop：在libuv之上超快速实现asyncio事件循环。<a href="https://github.com/MagicStack/uvloop" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>用于网络编程的库。</p>
<ul>
<li>asyncio：(Python 标准库) 异步 I/O, 事件循环, 协程以及任务。<a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/twisted/" target="_blank" rel="external">Twisted</a>：一个事件驱动的网络引擎。<a href="https://twistedmatrix.com/trac/" target="_blank" rel="external">官网</a></li>
<li>pulsar：事件驱动的并发框架。<a href="https://github.com/quantmind/pulsar" target="_blank" rel="external">官网</a></li>
<li>diesel：基于Greenlet 的事件 I/O 框架。<a href="https://github.com/dieseldev/diesel" target="_blank" rel="external">官网</a></li>
<li>pyzmq：一个 ZeroMQ 消息库的 Python 封装。<a href="http://zeromq.github.io/pyzmq/" target="_blank" rel="external">官网</a></li>
<li>txZMQ：基于 Twisted 的 ZeroMQ 消息库的 Python 封装。<a href="https://github.com/smira/txZMQ" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>帮助使用WebSocket的库。</p>
<ul>
<li>AutobahnPython：给 Python 、使用的 WebSocket &amp; WAMP 基于 Twisted 和 <a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="external">asyncio</a>。<a href="https://github.com/crossbario/autobahn-python" target="_blank" rel="external">官网</a></li>
<li>Crossbar：开源统一应用路由(Websocket &amp; WAMP for Python on Autobahn).<a href="https://github.com/crossbario/crossbar/" target="_blank" rel="external">官网</a></li>
<li>django-socketio：给 Django 用的 WebSockets。<a href="https://github.com/stephenmcd/django-socketio" target="_blank" rel="external">官网</a></li>
<li>WebSocket-for-Python：为Python2/3 以及 PyPy 编写的 WebSocket 客户端和服务器库。<a href="https://github.com/Lawouach/WebSocket-for-Python" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="WSGI-服务器"><a href="#WSGI-服务器" class="headerlink" title="WSGI 服务器"></a>WSGI 服务器</h3><p>兼容 WSGI 的 web 服务器</p>
<ul>
<li>gunicorn：Pre-forked, 部分是由 C 语言编写的。<a href="https://pypi.python.org/pypi/gunicorn" target="_blank" rel="external">官网</a></li>
<li>uwsgi：uwsgi 项目的目的是开发一组全栈工具，用来建立托管服务， 由 C 语言编写。<a href="https://uwsgi-docs.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/bjoern/" target="_blank" rel="external">bjoern</a>：异步，非常快速，由 C 语言编写。<a href="https://pypi.python.org/pypi/bjoern" target="_blank" rel="external">官网</a></li>
<li>fapws3：异步 (仅对于网络端)，由 C 语言编写。<a href="http://www.fapws.org/" target="_blank" rel="external">官网</a></li>
<li>meinheld：异步，部分是由 C 语言编写的。<a href="https://pypi.python.org/pypi/meinheld" target="_blank" rel="external">官网</a></li>
<li>netius：异步，非常快速。<a href="https://github.com/hivesolutions/netius" target="_blank" rel="external">官网</a></li>
<li>paste：多线程，稳定，久经考验。<a href="http://pythonpaste.org/" target="_blank" rel="external">官网</a></li>
<li>rocket：多线程。<a href="https://pypi.python.org/pypi/rocket" target="_blank" rel="external">官网</a></li>
<li>waitress：多线程, 是它驱动着 Pyramid 框架。<a href="https://waitress.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Werkzeug：一个 WSGI 工具库，驱动着 Flask ，而且可以很方便大嵌入到你的项目中去。<a href="http://werkzeug.pocoo.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="RPC-服务器"><a href="#RPC-服务器" class="headerlink" title="RPC 服务器"></a>RPC 服务器</h3><p>兼容 RPC 的服务器。</p>
<ul>
<li>SimpleJSONRPCServer：这个库是 JSON-RPC 规范的一个实现。<a href="https://github.com/joshmarshall/jsonrpclib/" target="_blank" rel="external">官网</a></li>
<li>SimpleXMLRPCServer：(Python 标准库) 简单的 XML-RPC 服务器实现，单线程。<a href="https://docs.python.org/2/library/simplexmlrpcserver.html" target="_blank" rel="external">官网</a></li>
<li>zeroRPC：zerorpc 是一个灵活的 RPC 实现，基于 ZeroMQ 和 MessagePack。<a href="https://github.com/0rpc/zerorpc-python" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><ul>
<li>cryptography：这个软件包意在提供密码学基本内容和方法提供给 Python 开发者。<a href="https://cryptography.io/en/latest/" target="_blank" rel="external">官网</a></li>
<li>hashids：在 Python 中实现 <a href="http://hashids.org/" target="_blank" rel="external">hashids</a> 。<a href="https://github.com/davidaurelio/hashids-python" target="_blank" rel="external">官网</a></li>
<li>Paramiko：SSHv2 协议的 Python (2.6+, 3.3+) ，提供客户端和服务端的功能。<a href="http://www.paramiko.org/" target="_blank" rel="external">官网</a></li>
<li>Passlib：安全密码存储／哈希库，<a href="https://pythonhosted.org/passlib/" target="_blank" rel="external">官网</a></li>
<li>PyCrypto：Python 密码学工具箱。<a href="https://www.dlitz.net/software/pycrypto/" target="_blank" rel="external">官网</a></li>
<li>PyNacl：网络和密码学(NaCl) 库的 Python 绑定。<a href="https://github.com/pyca/pynacl" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h3><p>用来创建图形用户界面程序的库。</p>
<ul>
<li>curses：内建的 <a href="http://www.gnu.org/software/ncurses/" target="_blank" rel="external">ncurses</a> 封装，用来创建终端图形用户界面。<a href="https://docs.python.org/2/library/curses.html#module-curses" target="_blank" rel="external">官网</a></li>
<li>enaml：使用类似 QML 的Declaratic语法来创建美观的用户界面。<a href="https://github.com/nucleic/enaml" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/kivy/" target="_blank" rel="external">kivy</a>：一个用来创建自然用户交互（NUI）应用程序的库，可以运行在 Windows, Linux, Mac OS X, Android 以及 iOS平台上。<a href="https://kivy.org/" target="_blank" rel="external">官网</a></li>
<li>pyglet：一个Python 的跨平台窗口及多媒体库。<a href="https://bitbucket.org/pyglet/pyglet/wiki/Home" target="_blank" rel="external">官网</a></li>
<li>PyQt：跨平台用户界面框架 <a href="http://www.qt.io/" target="_blank" rel="external">Qt</a> 的 Python 绑定 ，支持Qt v4 和 Qt v5。<a href="https://riverbankcomputing.com/software/pyqt/intro" target="_blank" rel="external">官网</a></li>
<li>PySide：P跨平台用户界面框架 <a href="http://www.qt.io/" target="_blank" rel="external">Qt</a> 的 Python 绑定 ，支持Qt v4。<a href="https://wiki.qt.io/PySide" target="_blank" rel="external">官网</a></li>
<li>Tkinter：Tkinter 是 Python GUI 的一个事实标准库。<a href="https://wiki.python.org/moin/TkInter" target="_blank" rel="external">官网</a></li>
<li>Toga：一个 Python 原生的, 操作系统原生的 GUI 工具包。<a href="https://github.com/pybee/toga" target="_blank" rel="external">官网</a></li>
<li>urwid：一个用来创建终端 GUI 应用的库，支持组件，事件和丰富的色彩等。<a href="http://urwid.org/" target="_blank" rel="external">官网</a></li>
<li>wxPython：wxPython 是 wxWidgets C++ 类库和 Python 语言混合的产物。<a href="http://wxpython.org/" target="_blank" rel="external">官网</a></li>
<li>PyGObject：GLib/GObject/GIO/GTK+ (GTK+3) 的 Python 绑定<a href="https://wiki.gnome.org/Projects/PyGObject" target="_blank" rel="external">官网</a></li>
<li>Flexx：Flexx 是一个纯 Python 语言编写的用来创建 GUI 程序的工具集，它使用 web 技术进行界面的展示。<a href="https://github.com/zoofIO/flexx" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="游戏开发"><a href="#游戏开发" class="headerlink" title="游戏开发"></a>游戏开发</h3><p>超赞的游戏开发库。</p>
<ul>
<li>Cocos2d：cocos2d 是一个用来开发 2D 游戏， 示例和其他图形/交互应用的框架。基于 pyglet。<a href="http://cocos2d.org/" target="_blank" rel="external">官网</a></li>
<li>Panda3D：由迪士尼开发的 3D 游戏引擎，并由卡内基梅陇娱乐技术中心负责维护。使用C++编写, 针对 Python 进行了完全的封装。<a href="https://www.panda3d.org/" target="_blank" rel="external">官网</a></li>
<li>Pygame：Pygame 是一组 Python 模块，用来编写游戏。<a href="http://www.pygame.org/news.html" target="_blank" rel="external">官网</a></li>
<li>PyOgre：Ogre 3D 渲染引擎的 Python 绑定，可以用来开发游戏和仿真程序等任何 3D 应用。<a href="http://www.ogre3d.org/tikiwiki/PyOgre" target="_blank" rel="external">官网</a></li>
<li>PyOpenGL：OpenGL 的 Python 绑定及其相关 APIs。<a href="http://pyopengl.sourceforge.net/" target="_blank" rel="external">官网</a></li>
<li>PySDL2：SDL2 库的封装，基于 ctypes。<a href="http://pysdl2.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>RenPy：一个视觉小说（visual novel）引擎。<a href="https://www.renpy.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>用来生成和操作日志的库。</p>
<ul>
<li>logging：(Python 标准库) 为 Python 提供日志功能。<a href="https://docs.python.org/2/library/logging.html" target="_blank" rel="external">官网</a></li>
<li>logbook：Logging 库的替代品。<a href="http://pythonhosted.org/Logbook/" target="_blank" rel="external">官网</a></li>
<li>Eliot：为复杂的和分布式系统创建日志。<a href="https://eliot.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Raven：Sentry的 Python 客户端。<a href="http://raven.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Sentry：实时记录和收集日志的服务器。<a href="https://pypi.python.org/pypi/sentry" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h3><p>进行代码库测试和生成测试数据的库。</p>
<ul>
<li>测试框架<ul>
<li>unittest：(Python 标准库) 单元测试框架。<a href="https://docs.python.org/2/library/unittest.html" target="_blank" rel="external">官网</a></li>
<li>nose：nose 扩展了 unittest 的功能。<a href="https://nose.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>contexts：一个 Python 3.3+ 的 BDD 框架。受到C# – Machine.Specifications的启发。<a href="https://github.com/benjamin-hodgson/Contexts" target="_blank" rel="external">官网</a></li>
<li>hypothesis：Hypothesis 是一个基于先进的 Quickcheck 风格特性的测试库。<a href="https://github.com/DRMacIver/hypothesis" target="_blank" rel="external">官网</a></li>
<li>mamba：Python 的终极测试工具， 拥护BDD。<a href="http://nestorsalceda.github.io/mamba/" target="_blank" rel="external">官网</a></li>
<li>PyAutoGUI：PyAutoGUI 是一个人性化的跨平台 GUI 自动测试模块。<a href="https://github.com/asweigart/pyautogui" target="_blank" rel="external">官网</a></li>
<li>pyshould：Should 风格的断言，基于 <a href="https://github.com/hamcrest/PyHamcrest" target="_blank" rel="external">PyHamcrest</a>。<a href="https://github.com/drslump/pyshould" target="_blank" rel="external">官网</a></li>
<li>pytest：一个成熟的全功能 Python 测试工具。<a href="http://pytest.org/latest/" target="_blank" rel="external">官网</a></li>
<li>green：干净，多彩的测试工具。<a href="https://github.com/CleanCut/green" target="_blank" rel="external">官网</a></li>
<li>pyvows：BDD 风格的测试工具，受Vows.js的启发。<a href="http://heynemann.github.io/pyvows/" target="_blank" rel="external">官网</a>-</li>
<li>Robot Framework：一个通用的自动化测试框架。<a href="https://github.com/robotframework/robotframework" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Web 测试<ul>
<li>Selenium：<a href="http://www.seleniumhq.org/" target="_blank" rel="external">Selenium</a> WebDriver 的 Python 绑定。<a href="https://pypi.python.org/pypi/selenium" target="_blank" rel="external">官网</a></li>
<li>locust：使用 Python 编写的，可扩展的用户加载测试工具。<a href="https://github.com/locustio/locust" target="_blank" rel="external">官网</a></li>
<li>sixpack：一个和语言无关的 A/B 测试框架。<a href="https://github.com/seatgeek/sixpack" target="_blank" rel="external">官网</a></li>
<li>splinter：开源的 web 应用测试工具。<a href="https://splinter.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Mock测试<ul>
<li>mock：(Python 标准库) 一个用于伪造测试的库。<a href="https://docs.python.org/3/library/unittest.mock.html" target="_blank" rel="external">官网</a></li>
<li>doublex：Python 的一个功能强大的 doubles  测试框架。<a href="https://pypi.python.org/pypi/doublex" target="_blank" rel="external">官网</a></li>
<li>freezegun：通过伪造日期模块来生成不同的时间。<a href="https://github.com/spulec/freezegun" target="_blank" rel="external">官网</a></li>
<li>httmock：针对 Python 2.6+ 和 3.2+ 生成 伪造请求的库。<a href="https://github.com/patrys/httmock" target="_blank" rel="external">官网</a></li>
<li>httpretty：Python 的 HTTP 请求 mock 工具。<a href="http://falcao.it/HTTPretty/" target="_blank" rel="external">官网</a></li>
<li>responses：伪造 Python 中的 requests 库的一个通用库。<a href="https://github.com/getsentry/responses" target="_blank" rel="external">官网</a></li>
<li>VCR.py：在你的测试中记录和重放 HTTP 交互。<a href="https://github.com/kevin1024/vcrpy" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>对象工厂<ul>
<li>factoryboy：一个 Python 用的测试固件 (test fixtures) 替代库。<a href="https://github.com/rbarrois/factoryboy" target="_blank" rel="external">官网</a></li>
<li>mixer：另外一个测试固件 (test fixtures) 替代库，支持 Django, Flask, SQLAlchemy, Peewee 等。<a href="https://github.com/klen/mixer" target="_blank" rel="external">官网</a></li>
<li>modelmommy：为 Django 测试创建随机固件<a href="https://github.com/vandersonmota/modelmommy" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>代码覆盖率<ul>
<li>coverage：代码覆盖率测量。<a href="https://pypi.python.org/pypi/coverage" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>伪数据<ul>
<li>faker：一个 Python 库，用来生成伪数据。<a href="http://www.joke2k.net/faker/" target="_blank" rel="external">官网</a></li>
<li>fake2db：伪数据库生成器。<a href="https://github.com/emirozer/fake2db" target="_blank" rel="external">官网</a></li>
<li>radar：生成随机的日期/时间。<a href="https://pypi.python.org/pypi/radar" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>错误处理<ul>
<li>FuckIt.py：FuckIt.py 使用最先进的技术来保证你的 Python 代码无论对错都能继续运行。<a href="https://github.com/ajalt/fuckitpy" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="代码分析和Lint工具"><a href="#代码分析和Lint工具" class="headerlink" title="代码分析和Lint工具"></a>代码分析和Lint工具</h3><p>进行代码分析，解析和操作代码库的库和工具。</p>
<ul>
<li>代码分析<ul>
<li>coala：语言独立和易于扩展的代码分析应用程序。<a href="http://coala-analyzer.org/" target="_blank" rel="external">官网</a></li>
<li>code2flow：把你的 Python 和 JavaScript 代码转换为流程图。<a href="https://github.com/scottrogowski/code2flow" target="_blank" rel="external">官网</a></li>
<li>pycallgraph：这个库可以把你的Python 应用的流程(调用图)进行可视化。<a href="https://github.com/gak/pycallgraph" target="_blank" rel="external">官网</a></li>
<li>pysonar2：Python 类型推断和检索工具。<a href="https://github.com/yinwang0/pysonar2" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Lint工具<ul>
<li>Flake8：模块化源码检查工具: pep8, pyflakes 以及 co。<a href="https://pypi.python.org/pypi/flake8" target="_blank" rel="external">官网</a></li>
<li>Pylint：一个完全可定制的源码分析器。<a href="https://www.pylint.org/" target="_blank" rel="external">官网</a></li>
<li>pylama：Python 和 JavaScript 的代码审查工具。<a href="https://pylama.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>代码格式化<ul>
<li>autopep8：自动格式化 Python 代码，以使其符合 PEP8 规范。<a href="https://github.com/hhatto/autopep8" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="Debugging-Tools"><a href="#Debugging-Tools" class="headerlink" title="Debugging Tools"></a>Debugging Tools</h3><p>用来进行代码调试的库。</p>
<ul>
<li>调试器<ul>
<li>ipdb：IPython 启用的 <a href="https://docs.python.org/2/library/pdb.html" target="_blank" rel="external">pdb</a>。<a href="https://pypi.python.org/pypi/ipdb" target="_blank" rel="external">官网</a></li>
<li>pudb：全屏，基于控制台的 Python 调试器。<a href="https://pypi.python.org/pypi/pudb" target="_blank" rel="external">官网</a></li>
<li>pyringe：可以在 Python 进程中附加和注入代码的调试器。<a href="https://github.com/google/pyringe" target="_blank" rel="external">官网</a></li>
<li>wdb：一个奇异的 web 调试器，通过 WebSockets 工作。<a href="https://github.com/Kozea/wdb" target="_blank" rel="external">官网</a></li>
<li>winpdb：一个具有图形用户界面的 Python 调试器，可以进行远程调试，基于 rpdb2。<a href="http://winpdb.org/" target="_blank" rel="external">官网</a></li>
<li>django-debug-toolbar：为 Django 显示各种调试信息。<a href="https://github.com/django-debug-toolbar/django-debug-toolbar" target="_blank" rel="external">官网</a></li>
<li>django-devserver：一个 Django 运行服务器的替代品。<a href="https://github.com/dcramer/django-devserver" target="_blank" rel="external">官网</a></li>
<li>flask-debugtoolbar：django-debug-toolbar 的 flask 版。<a href="https://github.com/mgood/flask-debugtoolbar" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>性能分析器<ul>
<li>lineprofiler：逐行性能分析。<a href="https://github.com/rkern/lineprofiler" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/memory_profiler/" target="_blank" rel="external">Memory Profiler</a>：监控 Python 代码的内存使用。<a href="http://pypi.python.org/pypi/memory_profiler" target="_blank" rel="external">官网</a>、<a href="https://github.com/fabianp/memoryprofiler" target="_blank" rel="external">内存</a></li>
<li>profiling：一个交互式 Python 性能分析工具。<a href="https://github.com/what-studio/profiling" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>其他<ul>
<li>pyelftools：解析和分析 ELF 文件以及 DWARF 调试信息。<a href="https://github.com/eliben/pyelftools" target="_blank" rel="external">官网</a></li>
<li>python-statsd：<a href="https://github.com/etsy/statsd/" target="_blank" rel="external">statsd</a> 服务器的 Python 客户端。<a href="https://github.com/WoLpH/python-statsd" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="Science-and-Data-Analysis"><a href="#Science-and-Data-Analysis" class="headerlink" title="Science and Data Analysis"></a>Science and Data Analysis</h3><p>用来进行科学计算和数据分析的库。</p>
<ul>
<li>astropy：一个天文学 Python 库。<a href="http://www.astropy.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/bcbio-nextgen/" target="_blank" rel="external">bcbio-nextgen</a>：这个工具箱为全自动高通量测序分析提供符合最佳实践的处理流程。<a href="https://github.com/chapmanb/bcbio-nextgen" target="_blank" rel="external">官网</a></li>
<li>bccb：生物分析相关代码集合<a href="https://github.com/chapmanb/bcbb" target="_blank" rel="external">官网</a></li>
<li>Biopython：Biopython 是一组可以免费使用的用来进行生物计算的工具。<a href="http://biopython.org/wiki/MainPage" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/blaze/" target="_blank" rel="external">blaze</a>：NumPy 和 Pandas 的大数据接口。<a href="http://blaze.readthedocs.org/en/latest/index.html" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/cclib/" target="_blank" rel="external">cclib</a>：一个用来解析和解释计算化学软件包输出结果的库。<a href="http://cclib.github.io/" target="_blank" rel="external">官网</a></li>
<li>NetworkX：一个为复杂网络设计的高性能软件。<a href="https://networkx.github.io/" target="_blank" rel="external">官网</a></li>
<li>Neupy：执行和测试各种不同的人工神经网络算法。<a href="http://neupy.com/pages/home.html" target="_blank" rel="external">官网</a></li>
<li>Numba：Python JIT (just in time) 编译器，针对科学用的 Python ，由Cython 和 NumPy 的开发者开发。<a href="http://numba.pydata.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/numpy/" target="_blank" rel="external">NumPy</a>：使用 Python 进行科学计算的基础包。<a href="http://www.numpy.org/" target="_blank" rel="external">官网</a></li>
<li>Open Babel：一个化学工具箱，用来描述多种化学数据。<a href="http://openbabel.org/wiki/MainPage" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/open-mining/" target="_blank" rel="external">Open Mining</a>：使用 Python 挖掘商业情报 (BI) (Pandas web 接口)。<a href="https://github.com/mining/mining" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/orange/" target="_blank" rel="external">orange</a>：通过可视化编程或 Python 脚本进行数据挖掘，数据可视化，分析和机器学习。<a href="http://orange.biolab.si/" target="_blank" rel="external">官网</a></li>
<li>Pandas：提供高性能，易用的数据结构和数据分析工具。<a href="http://pandas.pydata.org/" target="_blank" rel="external">官网</a></li>
<li>PyDy：PyDy 是 Python Dynamics 的缩写，用来为动力学运动建模工作流程提供帮助， 基于 NumPy, SciPy, IPython 和 matplotlib。<a href="http://www.pydy.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pymc/" target="_blank" rel="external">PyMC</a>：马尔科夫链蒙特卡洛采样工具。<a href="https://github.com/pymc-devs/pymc3" target="_blank" rel="external">官网</a></li>
<li>RDKit：化学信息学和机器学习软件。<a href="http://www.rdkit.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/scipy/" target="_blank" rel="external">SciPy</a>：由一些基于 Python ，用于数学，科学和工程的开源软件构成的生态系统。<a href="http://www.scipy.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/statsmodels/" target="_blank" rel="external">statsmodels</a>：统计建模和计量经济学。<a href="https://github.com/statsmodels/statsmodels" target="_blank" rel="external">官网</a></li>
<li>SymPy：一个用于符号数学的 Python 库。<a href="https://github.com/sympy/sympy" target="_blank" rel="external">官网</a></li>
<li>zipline：一个 Python 算法交易库。<a href="https://github.com/quantopian/zipline" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/bayesian-belief-networks/" target="_blank" rel="external">Bayesian-belief-networks</a>：优雅的贝叶斯信念网络框架。<a href="https://github.com/eBay/bayesian-belief-networks" target="_blank" rel="external">官网</a></li>
<li>keras: 以tensorflow或者theano为后端的深度学习封装库，快速上手神经网络<a href="https://keras.io/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>进行数据可视化的库。 参见: <a href="https://github.com/sorrycc/awesome-javascript#data-visualization" target="_blank" rel="external">awesome-javascript</a>。</p>
<ul>
<li>matplotlib：一个 Python 2D 绘图库。<a href="http://matplotlib.org/" target="_blank" rel="external">官网</a></li>
<li>bokeh：用 Python 进行交互式 web 绘图。<a href="https://github.com/bokeh/bokeh" target="_blank" rel="external">官网</a></li>
<li>ggplot：ggplot2 给 R 提供的 API 的 Python 版本。<a href="https://github.com/yhat/ggplot" target="_blank" rel="external">官网</a></li>
<li>plotly：协同 Python 和 matplotlib 工作的 web 绘图库。<a href="https://plot.ly/python/" target="_blank" rel="external">官网</a></li>
<li>pygal：一个 Python SVG 图表创建工具。<a href="http://www.pygal.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>pygraphviz：Graphviz 的 Python 接口。<a href="https://pypi.python.org/pypi/pygraphviz" target="_blank" rel="external">官网</a></li>
<li>PyQtGraph：交互式实时2D/3D/图像绘制及科学/工程学组件。<a href="http://www.pyqtgraph.org/" target="_blank" rel="external">官网</a></li>
<li>SnakeViz：一个基于浏览器的 Python’s cProfile 模块输出结果查看工具。<a href="http://jiffyclub.github.io/snakeviz/" target="_blank" rel="external">官网</a></li>
<li>vincent：把 Python 转换为 Vega 语法的转换工具。<a href="https://github.com/wrobstory/vincent" target="_blank" rel="external">官网</a></li>
<li>VisPy：基于 OpenGL 的高性能科学可视化工具。<a href="http://vispy.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><p>计算机视觉库。</p>
<ul>
<li>OpenCV：开源计算机视觉库。<a href="http://opencv.org/" target="_blank" rel="external">官网</a></li>
<li>pyocr：Tesseract和Cuneiform的包装库。<a href="https://github.com/jflesch/pyocr" target="_blank" rel="external">官网</a></li>
<li>pytesseract：<a href="https://github.com/tesseract-ocr" target="_blank" rel="external">Google Tesseract OCR</a>的另一包装库。<a href="https://github.com/madmaze/pytesseract" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/simplecv/" target="_blank" rel="external">SimpleCV</a>：一个用来创建计算机视觉应用的开源框架。<a href="http://simplecv.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习库。 参见: <a href="https://github.com/josephmisiti/awesome-machine-learning#python" target="_blank" rel="external">awesome-machine-learning</a>.</p>
<ul>
<li>Crab：灵活、快速的推荐引擎。<a href="https://github.com/muricoca/crab" target="_blank" rel="external">官网</a></li>
<li>gensim：人性化的话题建模库。<a href="https://github.com/piskvorky/gensim" target="_blank" rel="external">官网</a></li>
<li>hebel：GPU 加速的深度学习库。<a href="https://github.com/hannes-brt/hebel" target="_blank" rel="external">官网</a></li>
<li>NuPIC：智能计算 Numenta 平台。<a href="https://github.com/numenta/nupic" target="_blank" rel="external">官网</a></li>
<li>pattern：Python 网络挖掘模块。<a href="https://github.com/clips/pattern" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pybrain/" target="_blank" rel="external">PyBrain</a>：另一个 Python 机器学习库。<a href="https://github.com/pybrain/pybrain" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pylearn2/" target="_blank" rel="external">Pylearn2</a>：一个基于 <a href="https://github.com/Theano/Theano" target="_blank" rel="external">Theano</a> 的机器学习库。<a href="https://github.com/lisa-lab/pylearn2" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-recsys/" target="_blank" rel="external">python-recsys</a>：一个用来实现推荐系统的 Python 库。<a href="https://github.com/ocelma/python-recsys" target="_blank" rel="external">官网</a></li>
<li>scikit-learn：基于 SciPy 构建的机器学习 Python 模块。<a href="http://scikit-learn.org/" target="_blank" rel="external">官网</a></li>
<li>pydeep：Python 深度学习库。<a href="https://github.com/andersbll/deeppy" target="_blank" rel="external">官网</a></li>
<li>vowpalporpoise：轻量级 <a href="https://github.com/JohnLangford/vowpalwabbit/" target="_blank" rel="external">Vowpal Wabbit</a> 的 Python 封装。<a href="https://github.com/josephreisinger/vowpalporpoise" target="_blank" rel="external">官网</a></li>
<li>skflow：一个 <a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow</a> 的简化接口(模仿 scikit-learn)。<a href="https://github.com/tensorflow/skflow" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>MapReduce 框架和库。</p>
<ul>
<li><a href="http://hao.jobbole.com/dpark/" target="_blank" rel="external">dpark</a>：Spark 的 Python 克隆版，一个类似 MapReduce 的框架。<a href="https://github.com/douban/dpark" target="_blank" rel="external">官网</a></li>
<li>dumbo：这个 Python 模块可以让人轻松的编写和运行 Hadoop 程序。<a href="https://github.com/klbostee/dumbo" target="_blank" rel="external">官网</a></li>
<li>luigi：这个模块帮你构建批处理作业的复杂流水线。<a href="https://github.com/spotify/luigi" target="_blank" rel="external">官网</a></li>
<li>mrjob：在 Hadoop 或 Amazon Web Services 上运行 MapReduce 任务。<a href="https://github.com/Yelp/mrjob" target="_blank" rel="external">官网</a></li>
<li>PySpark：Spark 的 Python API 。<a href="http://spark.apache.org/docs/latest/programming-guide.html" target="_blank" rel="external">官网</a></li>
<li>streamparse：运行针对事实数据流的 Python 代码。集成了<a href="http://storm.apache.org/" target="_blank" rel="external">Apache Storm</a>。<a href="https://github.com/Parsely/streamparse" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>使用 Python 进行函数式编程。</p>
<ul>
<li>CyToolz：Toolz 的 Cython 实现 : 高性能函数式工具。<a href="https://github.com/pytoolz/cytoolz/" target="_blank" rel="external">官网</a></li>
<li>fn.py：在 Python 中进行函数式编程 : 实现了一些享受函数式编程缺失的功能。<a href="https://github.com/kachayev/fn.py" target="_blank" rel="external">官网</a></li>
<li>funcy：炫酷又实用的函数式工具。<a href="https://github.com/Suor/funcy" target="_blank" rel="external">官网</a></li>
<li>Toolz：一组用于迭代器，函数和字典的函数式编程工具。<a href="https://github.com/pytoolz/toolz" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="第三方-API"><a href="#第三方-API" class="headerlink" title="第三方 API"></a>第三方 API</h3><p>用来访问第三方 API的库。 参见： <a href="https://github.com/realpython/list-of-python-api-wrappers" target="_blank" rel="external">List of Python API Wrappers and Libraries</a>。</p>
<ul>
<li>apache-libcloud：一个为各种云设计的 Python 库。<a href="https://libcloud.apache.org/" target="_blank" rel="external">官网</a></li>
<li>boto：Amazon Web Services 的 Python 接口。<a href="https://github.com/boto/boto" target="_blank" rel="external">官网</a></li>
<li>django-wordpress：WordPress models and views for Django.<a href="https://github.com/sunlightlabs/django-wordpress/" target="_blank" rel="external">官网</a></li>
<li>facebook-sdk：Facebook 平台的 Python SDK.<a href="https://github.com/mobolic/facebook-sdk" target="_blank" rel="external">官网</a></li>
<li>facepy：Facepy 让和 Facebook’s Graph API 的交互变得更容易。<a href="https://github.com/jgorset/facepy" target="_blank" rel="external">官网</a></li>
<li>gmail：Gmail 的 Python 接口。<a href="https://github.com/charlierguo/gmail" target="_blank" rel="external">官网</a></li>
<li>google-api-python-client：Python 用的 Google APIs 客户端库。<a href="https://github.com/google/google-api-python-client" target="_blank" rel="external">官网</a></li>
<li>gspread：Google 电子表格的 Python API.<a href="https://github.com/burnash/gspread" target="_blank" rel="external">官网</a></li>
<li>twython：Twitter API 的封装。<a href="https://github.com/ryanmcgrath/twython" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="DevOps-工具"><a href="#DevOps-工具" class="headerlink" title="DevOps 工具"></a>DevOps 工具</h3><p>用于 DevOps 的软件和库。</p>
<ul>
<li>Ansible：一个非常简单的 IT 自动化平台。<a href="https://github.com/ansible/ansible" target="_blank" rel="external">官网</a></li>
<li>SaltStack：基础设施自动化和管理系统。<a href="https://github.com/saltstack/salt" target="_blank" rel="external">官网</a></li>
<li>OpenStack：用于构建私有和公有云的开源软件。<a href="http://www.openstack.org/" target="_blank" rel="external">官网</a></li>
<li>Docker Compose：快速，分离的开发环境，使用 Docker。<a href="https://docs.docker.com/compose/" target="_blank" rel="external">官网</a></li>
<li>Fabric：一个简单的，Python 风格的工具，用来进行远程执行和部署。<a href="http://www.fabfile.org/" target="_blank" rel="external">官网</a></li>
<li>cuisine：为 Fabric 提供一系列高级函数。<a href="https://github.com/sebastien/cuisine" target="_blank" rel="external">官网</a></li>
<li>Fabtools：一个用来编写超赞的 Fabric 文件的工具。<a href="https://github.com/ronnix/fabtools" target="_blank" rel="external">官网</a></li>
<li>gitapi：Git 的纯 Python API。<a href="https://bitbucket.org/haard/gitapi" target="_blank" rel="external">官网</a></li>
<li>hgapi：Mercurial 的纯 Python API。<a href="https://bitbucket.org/haard/hgapi" target="_blank" rel="external">官网</a></li>
<li>honcho：<a href="https://github.com/ddollar/foreman" target="_blank" rel="external">Foreman</a>的 Python 克隆版，用来管理基于<a href="https://devcenter.heroku.com/articles/procfile" target="_blank" rel="external">Procfile</a>的应用。<a href="https://github.com/nickstenning/honcho" target="_blank" rel="external">官网</a></li>
<li>pexpect：Controlling interactive programs in a pseudo-terminal like 在一个伪终端中控制交互程序，就像 GNU expect 一样。<a href="https://github.com/pexpect/pexpect" target="_blank" rel="external">官网</a></li>
<li>psutil：一个跨平台进程和系统工具模块。<a href="https://github.com/giampaolo/psutil" target="_blank" rel="external">官网</a></li>
<li>supervisor：UNIX 的进程控制系统。<a href="https://github.com/Supervisor/supervisor" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>任务调度库。</p>
<ul>
<li>APScheduler：轻巧但强大的进程内任务调度，使你可以调度函数。<a href="http://apscheduler.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>django-schedule：一个 Django 排程应用。<a href="https://github.com/thauber/django-schedule" target="_blank" rel="external">官网</a></li>
<li>doit：一个任务执行和构建工具。<a href="http://pydoit.org/" target="_blank" rel="external">官网</a></li>
<li>gunnery：分布式系统使用的多用途任务执行工具 ，具有 web 交互界面。<a href="https://github.com/gunnery/gunnery" target="_blank" rel="external">官网</a></li>
<li>Joblib：一组为 Python 提供轻量级作业流水线的工具。<a href="http://pythonhosted.org/joblib/index.html" target="_blank" rel="external">官网</a></li>
<li>Plan：如有神助地编写 crontab 文件。<a href="https://github.com/fengsp/plan" target="_blank" rel="external">官网</a></li>
<li>schedule：人性化的 Python 任务调度库。<a href="https://github.com/dbader/schedule" target="_blank" rel="external">官网</a></li>
<li>Spiff：使用纯 Python 实现的强大的工作流引擎。<a href="https://github.com/knipknap/SpiffWorkflow" target="_blank" rel="external">官网</a></li>
<li>TaskFlow：一个可以让你方便执行任务的 Python 库，一致并且可靠。<a href="http://docs.openstack.org/developer/taskflow/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="外来函数接口"><a href="#外来函数接口" class="headerlink" title="外来函数接口"></a>外来函数接口</h3><p>使用外来函数接口的库。</p>
<ul>
<li>cffi：用来调用 C 代码的外来函数接口。<a href="https://pypi.python.org/pypi/cffi" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/ctypes/" target="_blank" rel="external">ctypes</a>：(Python 标准库) 用来调用 C 代码的外来函数接口。<a href="https://docs.python.org/2/library/ctypes.html" target="_blank" rel="external">官网</a></li>
<li>PyCUDA：Nvidia CUDA API 的封装。<a href="https://mathema.tician.de/software/pycuda/" target="_blank" rel="external">官网</a></li>
<li>SWIG：简化的封装和接口生成器。<a href="http://www.swig.org/Doc1.3/Python.html" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>让 Python 更快的库。</p>
<ul>
<li>Cython：优化的 Python 静态编译器。使用类型混合使 Python 编译成 C 或 C++ 模块来获得性能的极大提升。<a href="http://cython.org/" target="_blank" rel="external">官网</a></li>
<li>PeachPy：嵌入 Python 的 x86-64 汇编器。可以被用作 Python 内联的汇编器或者是独立的汇编器，用于 Windows, Linux, OS X, Native Client 或者 Go 。<a href="https://github.com/Maratyszcza/PeachPy" target="_blank" rel="external">官网</a></li>
<li>PyPy：使用 Python 实现的 Python。解释器使用黑魔法加快 Python 运行速度且不需要加入额外的类型信息。<a href="http://pypy.org/" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/pyston-llvm-jit/" target="_blank" rel="external">Pyston</a>：使用 LLVM 和现代 JIT 技术构建的 Python 实现，目标是为了获得很好的性能。<a href="https://github.com/dropbox/pyston" target="_blank" rel="external">官网</a></li>
<li>Stackless Python：一个强化版的 Python。<a href="https://bitbucket.org/stackless-dev/stackless/overview" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="微软的-Windows平台"><a href="#微软的-Windows平台" class="headerlink" title="微软的 Windows平台"></a>微软的 Windows平台</h3><p>在 Windows 平台上进行 Python 编程。</p>
<ul>
<li>Python(x,y)：面向科学应用的 Python 发行版，基于 Qt 和 Spyder。<a href="http://python-xy.github.io/" target="_blank" rel="external">官网</a></li>
<li>pythonlibs：非官方的 Windows 平台 Python 扩展二进制包。<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">官网</a></li>
<li>PythonNet：Python 与 .NET 公共语言运行库 (CLR)的集成。<a href="https://github.com/pythonnet/pythonnet" target="_blank" rel="external">官网</a></li>
<li>PyWin32：针对 Windows 的Python 扩展。<a href="https://sourceforge.net/projects/pywin32/" target="_blank" rel="external">官网</a></li>
<li>WinPython：Windows 7/8 系统下便携式开发环境。<a href="https://winpython.github.io/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="网络可视化和SDN"><a href="#网络可视化和SDN" class="headerlink" title="网络可视化和SDN"></a>网络可视化和SDN</h3><p>用来进行网络可视化和SDN(软件定义网络)的工具和库。</p>
<ul>
<li>Mininet：一款流行的网络模拟器以及用 Python 编写的 API。<a href="http://mininet.org/" target="_blank" rel="external">官网</a></li>
<li>POX：一个针对基于 Python 的软件定义网络应用（例如 OpenFlow SDN 控制器）的开源开发平台。<a href="https://github.com/noxrepo/pox" target="_blank" rel="external">官网</a></li>
<li>Pyretic：火热的 SDN 编程语言中的一员，为网络交换机和模拟器提供强大的抽象能力。<a href="http://frenetic-lang.org/pyretic/" target="_blank" rel="external">官网</a></li>
<li>SDX Platform：基于 SDN 的 IXP 实现，影响了 Mininet, POX 和 Pyretic。<a href="https://github.com/sdn-ixp/internet2award" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>用来对硬件进行编程的库。</p>
<ul>
<li>ino：操作<a href="https://www.arduino.cc/" target="_blank" rel="external">Arduino</a>的命令行工具。<a href="http://inotool.org/" target="_blank" rel="external">官网</a> </li>
<li>Pyro：Python 机器人编程库。<a href="http://pyrorobotics.com/" target="_blank" rel="external">官网</a></li>
<li>PyUserInput：跨平台的，控制鼠标和键盘的模块。<a href="https://github.com/SavinaRoja/PyUserInput" target="_blank" rel="external">官网</a></li>
<li>scapy：一个非常棒的操作数据包的库。<a href="https://github.com/secdev/scapy" target="_blank" rel="external">官网</a></li>
<li>wifi：一个 Python 库和命令行工具用来在 Linux 平台上操作WiFi。<a href="https://wifi.readthedocs.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li>Pingo：Pingo 为类似Raspberry Pi，pcDuino， Intel Galileo等设备提供统一的API用以编程。<a href="http://www.pingo.io/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>帮助从 Python 2 向 Python 3迁移的库。</p>
<ul>
<li>Python-Future：这就是 Python 2 和 Python 3 之间丢失的那个兼容性层。<a href="http://python-future.org/index.html" target="_blank" rel="external">官网</a></li>
<li>Python-Modernize：使 Python 代码更加现代化以便最终迁移到 Python 3。<a href="https://github.com/mitsuhiko/python-modernize" target="_blank" rel="external">官网</a></li>
<li>Six：Python 2 和 3 的兼容性工具。<a href="https://pypi.python.org/pypi/six" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>不属于上面任何一个类别，但是非常有用的库。</p>
<ul>
<li>blinker：一个快速的 Python 进程内信号/事件分发系统。<a href="https://github.com/jek/blinker" target="_blank" rel="external">官网</a></li>
<li>itsdangerous：一系列辅助工具用来将可信的数据传入不可信的环境。<a href="https://github.com/pallets/itsdangerous" target="_blank" rel="external">官网</a></li>
<li>pluginbase：一个简单但是非常灵活的 Python 插件系统。<a href="https://github.com/mitsuhiko/pluginbase" target="_blank" rel="external">官网</a></li>
<li>Pychievements：一个用来创建和追踪成就的 Python 框架。<a href="https://github.com/PacketPerception/pychievements" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/tryton/" target="_blank" rel="external">Tryton</a>：一个通用商务框架。<a href="http://www.tryton.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="算法和设计模式"><a href="#算法和设计模式" class="headerlink" title="算法和设计模式"></a>算法和设计模式</h3><p>Python 实现的算法和设计模式。</p>
<ul>
<li><a href="http://hao.jobbole.com/algorithms/" target="_blank" rel="external">algorithms</a>：一个 Python 算法模块。<a href="https://github.com/nryoung/algorithms" target="_blank" rel="external">官网</a> </li>
<li>python-patterns：Python 设计模式的集合。<a href="https://github.com/faif/python-patterns" target="_blank" rel="external">官网</a></li>
<li>sortedcontainers：快速，纯 Python 实现的SortedList，SortedDict 和 SortedSet 类型。<a href="http://www.grantjenks.com/docs/sortedcontainers/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="编辑器插件"><a href="#编辑器插件" class="headerlink" title="编辑器插件"></a>编辑器插件</h3><p>编辑器和 IDE 的插件</p>
<ul>
<li>Emacs<ul>
<li>Elpy：Emacs Python 开发环境。<a href="https://github.com/jorgenschaefer/elpy" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Sublime Text<ul>
<li>SublimeJEDI：一个 Sublime Text 插件，用来使用超赞的自动补全库 Jedi。<a href="https://github.com/srusskih/SublimeJEDI" target="_blank" rel="external">官网</a></li>
<li>Anaconda：Anaconda 把你的 Sublime Text 3 变成一个功能齐全的 Python IDE。<a href="https://github.com/DamnWidget/anaconda" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Vim<ul>
<li><a href="http://hao.jobbole.com/youcompleteme/" target="_blank" rel="external">YouCompleteMe</a>：引入基于 <a href="https://github.com/davidhalter/jedi" target="_blank" rel="external">Jedi</a> 的 Python 自动补全引擎。<a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">官网</a></li>
<li>Jedi-vim：绑定 Vim 和 Jedi 自动补全库对 Python 进行自动补全。<a href="https://github.com/davidhalter/jedi-vim" target="_blank" rel="external">官网</a></li>
<li>Python-mode：将 Vim 变成 Python IDE 的一款多合一插件。<a href="https://github.com/klen/python-mode" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li>Visual Studio<ul>
<li>PTVS：Visual Studio 的 Python 工具<a href="https://github.com/Microsoft/PTVS" target="_blank" rel="external">官网</a></li>
</ul>
</li>
</ul>
<h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><p>流行的 Python 集成开发环境。</p>
<ul>
<li>PyCharm：商业化的 Python IDE ，由 JetBrains 开发。也有免费的社区版提供。<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">官网</a></li>
<li>LiClipse：基于 Eclipse 的免费多语言 IDE 。使用 PyDev 来支持 Python 。<a href="http://www.liclipse.com/" target="_blank" rel="external">官网</a></li>
<li>Spyder：开源 Python IDE。<a href="https://github.com/spyder-ide/spyder" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="自动聊天工具"><a href="#自动聊天工具" class="headerlink" title="自动聊天工具"></a>自动聊天工具</h3><p>用于开发聊天机器人的库</p>
<ul>
<li>Errbot：最简单和最流行的聊天机器人用来实现自动聊天工具。<a href="http://errbot.io/en/latest/" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>在线工具和简化开发的 API 。</p>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>参见: <a href="https://github.com/ciandcd/awesome-ciandcd#online-build-system" target="_blank" rel="external">awesome-CIandCD</a>.</p>
<ul>
<li>Travis CI：一个流行的工具，为你的开源和<a href="https://travis-ci.com/" target="_blank" rel="external">私人</a>项目提供持续集成服务。(仅支持 GitHub)<a href="https://travis-ci.org/" target="_blank" rel="external">官网</a></li>
<li>CircleCI：一个持续集成工具，可以非常快速的进行并行测试。 (仅支持 GitHub)<a href="https://circleci.com/" target="_blank" rel="external">官网</a></li>
<li>Vexor CI：一个为私人 app 提供持续集成的工具，支持按分钟付费。<a href="https://vexor.io/" target="_blank" rel="external">官网</a></li>
<li>Wercker：基于 Docker 平台，用来构建和部署微服务。<a href="http://wercker.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><ul>
<li>Codacy：自动化代码审查，更加快速的发布高质量代码。对于开源项目是免费的。<a href="https://www.codacy.com/" target="_blank" rel="external">官网</a></li>
<li>QuantifiedCode：一个数据驱动、自动、持续的代码审查工具。<a href="https://www.quantifiedcode.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>在这里可以找到新的 Python 库。</p>
<h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul>
<li><a href="https://www.reddit.com/r/python" target="_blank" rel="external">r/Python</a></li>
<li><a href="https://www.coolgithubprojects.com/" target="_blank" rel="external">CoolGithubProjects</a></li>
<li><a href="https://www.djangopackages.com/" target="_blank" rel="external">Django Packages</a></li>
<li><a href="http://www.fullstackpython.com/" target="_blank" rel="external">Full Stack Python</a></li>
<li><a href="http://python3wos.appspot.com/" target="_blank" rel="external">Python 3 Wall of Superpowers</a></li>
<li><a href="http://pythonhackers.com/open-source/" target="_blank" rel="external">Python Hackers</a></li>
<li><a href="https://python.zeef.com/alan.richmond" target="_blank" rel="external">Python ZEEF</a></li>
<li><a href="https://github.com/trending?l=python" target="_blank" rel="external">Trending Python repositories on GitHub today</a></li>
<li><a href="http://pypi-ranking.info/alltime" target="_blank" rel="external">PyPI Ranking</a></li>
</ul>
<h3 id="周刊"><a href="#周刊" class="headerlink" title="周刊"></a>周刊</h3><ul>
<li><a href="http://importpython.com/newsletter/" target="_blank" rel="external">Import Python Newsletter</a></li>
<li><a href="http://pycoders.com/" target="_blank" rel="external">Pycoder’s Weekly</a></li>
<li><a href="http://www.pythonweekly.com/" target="_blank" rel="external">Python Weekly</a></li>
</ul>
<h3 id="Twitter"><a href="#Twitter" class="headerlink" title="Twitter"></a>Twitter</h3><ul>
<li><a href="https://twitter.com/codetengu" target="_blank" rel="external">@codetengu</a></li>
<li><a href="https://twitter.com/getpy" target="_blank" rel="external">@getpy</a></li>
<li><a href="https://twitter.com/planetpython" target="_blank" rel="external">@planetpython</a></li>
<li><a href="https://twitter.com/pycoders" target="_blank" rel="external">@pycoders</a></li>
<li><a href="https://twitter.com/pypi" target="_blank" rel="external">@pypi</a></li>
<li><a href="https://twitter.com/pythontrending" target="_blank" rel="external">@pythontrending</a></li>
<li><a href="https://twitter.com/PythonWeekly" target="_blank" rel="external">@PythonWeekly</a></li>
</ul>
<h3 id="学习指南"><a href="#学习指南" class="headerlink" title="学习指南"></a>学习指南</h3><ul>
<li><a href="http://hao.jobbole.com/scipy-lecture-notes/" target="_blank" rel="external">Scipy-lecture-notes</a>：如何用Python来做学术？<a href="https://github.com/scipy-lectures/scipy-lecture-notes" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/scientific-python-lectures/" target="_blank" rel="external">SScientific-python-lectures</a>：Python科学计算的资料。<a href="https://github.com/jrjohansson/scientific-python-lectures" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/mario-level-1/" target="_blank" rel="external">Mario-Level-1</a>：用Python和Pygame写的超级马里奥第一关。<a href="https://github.com/justinmeister/Mario-Level-1" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-koans/" target="_blank" rel="external">Python Koans</a>：Python的交互式学习工具。<a href="https://github.com/gregmalcolm/python_koans" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/minecraft-python/" target="_blank" rel="external">Minecraft</a>：用python写的Minecraft游戏。<a href="https://github.com/fogleman/Minecraft" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-pycrumbs/" target="_blank" rel="external">pycrumbs</a>：Python资源大全。<a href="https://github.com/kirang89/pycrumbs/blob/master/pycrumbs.md" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-patterns/" target="_blank" rel="external">python-patterns</a>：使用python实现设计模式。<a href="https://github.com/faif/python-patterns" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/python-projects/" target="_blank" rel="external">Projects</a>：Python项目大集合。<a href="https://github.com/karan/Projects" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/the-hitchhikers-guide-to-python/" target="_blank" rel="external">The Hitchhiker’s Guide to Python</a>：旅行者的Python学习指南。<a href="http://docs.python-guide.org/en/latest/" target="_blank" rel="external">官网</a></li>
<li><a href="http://top.jobbole.com/18767/" target="_blank" rel="external">Code Like a Pythonista: Idiomatic Python</a>：如何像Python高手(Pythonista)一样编程。<a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" target="_blank" rel="external">官网</a></li>
</ul>
<p></p><h3 id="websites">知名网站</h3><br><em>值得关注的 Python 技术站点。</em><p></p>
<h4>中文站点</h4>

<ul>
<li>伯乐在线 Python 频道：分享 Python 开发技术、相关的行业动态。<a href="http://python.jobbole.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h4>英文站点</h4>

<ul>
<li>《<a href="http://python.jobbole.com/81730/" target="_blank" rel="external">值得关注的 10 个 Python 英文博客</a>》</li>
</ul>
<p></p><h3 id="weibo-weixin">微博、微信公众号</h3><p></p>
<ul>
<li>Python开发者 微博：<a href="http://weibo.com/u/5305630013" target="_blank" rel="external">@Python开发者</a></li>
<li>Python开发者：人生苦短，我用 Python。Python 越来越受广大程序员的喜爱。「Python开发者」是最受欢迎的、专注分享Python技术的微信公众号，主要分享 Python 相关的技术文章、工具资源和资讯等。<br><br><img src="http://ww3.sinaimg.cn/small/63918611gw1epb2cbm6cmj2046046wek.jpg" width="150" height="150"></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;http://hao.jobbole.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;伯乐在线&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GitHub 上有一个 Awesome - XXX 系列的资源整理。&lt;a href=&quot;https://github.com/vinta/awesome-python&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;awesome-python&lt;/a&gt; 是 vinta 发起维护的 Python 资源列表，内容包括：Web框架、网络爬虫、网络内容提取、模板引擎、数据库、数据可视化、图片处理、文本处理、自然语言处理、机器学习、日志、代码分析等。&lt;/p&gt;
&lt;p&gt;Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是&lt;a href=&quot;http://hao.jobbole.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;伯乐在线&lt;/a&gt;发起这个开源项目的初衷。&lt;/p&gt;
    
    </summary>
    
    
      <category term="COLLECTION" scheme="http://mingotang.github.io/tags/COLLECTION/"/>
    
  </entry>
  
  <entry>
    <title>DBMSSAS Assignment2</title>
    <link href="http://mingotang.github.io/2017/09/26/DBMSSAS-Assignment2/"/>
    <id>http://mingotang.github.io/2017/09/26/DBMSSAS-Assignment2/</id>
    <published>2017-09-26T14:18:09.000Z</published>
    <updated>2017-10-06T11:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Design a Student – Course Database<br>Draw E/R Diagram</p>
<hr>
<h2 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h2><p>实体：学生 Student</p>
<ul>
<li>学号 Sno（关键字，需要加下划线）</li>
<li>姓名 Sname</li>
<li>性别 Ssex</li>
<li>年龄 Sage</li>
<li>学院 Sdept</li>
</ul>
<blockquote>
<p>注意：每个实体（表）都需要一个关键字来进行索引</p>
</blockquote>
<p>实体：课程 Course</p>
<ul>
<li>课程编号 Cno（关键字，需要加下划线）</li>
<li>课程名称 Cname</li>
<li>先修课程 Cpno</li>
<li>学分 Ccredit</li>
</ul>
<p>关系：选课 SC</p>
<ul>
<li>分数 Grade</li>
</ul>
<p>实体对应关系：</p>
<ul>
<li>实体学生与实体课程形成关系选课</li>
</ul>
<p><img src="http://ox3grgjnx.bkt.clouddn.com/DBMSSAS%20Assignment3%20001.png" alt="图见 DBMSSAS Assignment 3 中的题目"></p>
<hr>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>实体的属性当中没有键<ul>
<li>键用下划线标出</li>
</ul>
</li>
<li>关系和实体没有属性<ul>
<li>关系和实体必须要有属性，如果不存在属性那么这个关系或者实体也就不需要储存在数据库当中了</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;p&gt;Design a Student – Course Databa
    
    </summary>
    
    
      <category term="TA" scheme="http://mingotang.github.io/tags/TA/"/>
    
  </entry>
  
  <entry>
    <title>DBMSSAS Assignment1</title>
    <link href="http://mingotang.github.io/2017/09/26/DBMSSAS-Assignment1/"/>
    <id>http://mingotang.github.io/2017/09/26/DBMSSAS-Assignment1/</id>
    <published>2017-09-26T05:57:09.000Z</published>
    <updated>2017-10-01T02:56:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>软件安装部分提示和注意事项</p>
<a id="more"></a>
<p>请前往 链接:<a href="https://yun.baidu.com/s/1jHEyYTS" target="_blank" rel="external">https://yun.baidu.com/s/1jHEyYTS</a> 密码:u9m4 下载 SQL和SAS软件</p>
<hr>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a><em>软件安装</em></h2><p><code>SQL</code></p>
<p>Windows系统请安装百度云当中的SQL2008版，安装之时注意：</p>
<ul>
<li>遇到无法重启问题请参考：<a href="http://jingyan.baidu.com/article/a24b33cd52a0b919fe002bae.html" target="_blank" rel="external">http://jingyan.baidu.com/article/a24b33cd52a0b919fe002bae.html</a></li>
<li>连接权限妥善设置，偷懒一点的可以设置为windows用户直接登录（添加当前用户按钮）</li>
<li>安装完成之后连接本地服务器 <code>(local)</code></li>
</ul>
<p>Mac系统可以使用DBeaver+MySQL的方式代替，请参考：<a href="http://www.jianshu.com/p/a4e7915023c2" target="_blank" rel="external">Mac OS MySql 连接和使用示例</a></p>
<p><code>SAS</code></p>
<p>Windows系统请安装百度云当中的SAS 9.21版</p>
<ul>
<li>windows 版SAS无法修改安装路径，因此没有D盘的用户请查看注意事项</li>
</ul>
<p>Mac系统可以使用 <a href="https://www.sas.com/en_us/software/university-edition/download-software.html#os-x" target="_blank" rel="external">SAS University Edition</a> 代替</p>
<blockquote>
<p>注意：如果windows电脑分区没有D盘的请安装<a href="https://www.sas.com/en_us/software/university-edition/download-software.html#windows" target="_blank" rel="external">SAS University Edition</a>，mac虚拟机最好不要分区，同时最好安装mac版的<a href="https://www.sas.com/en_us/software/university-edition/download-software.html#os-x" target="_blank" rel="external">SAS University Edition</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件安装部分提示和注意事项&lt;/p&gt;
    
    </summary>
    
    
      <category term="TA" scheme="http://mingotang.github.io/tags/TA/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础及SAS应用</title>
    <link href="http://mingotang.github.io/2017/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E5%8F%8ASAS%E5%BA%94%E7%94%A8/"/>
    <id>http://mingotang.github.io/2017/09/25/数据库基础及SAS应用/</id>
    <published>2017-09-25T03:09:18.000Z</published>
    <updated>2017-10-13T05:26:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库基础及SAS应用课程信息</p>
<a id="more"></a>
<h2 id="课程相关"><a href="#课程相关" class="headerlink" title="课程相关"></a><em>课程相关</em></h2><p>教学班 001：</p>
<ul>
<li>行课安排：1-16 周</li>
<li>时间：周五 1-3 节</li>
<li>地点：上院 210</li>
</ul>
<p>教学班 002：</p>
<ul>
<li>行课安排：1-16 周</li>
<li>时间：周五 6-8 节</li>
<li>地点：上院 210</li>
</ul>
<p>授课教授<code>胡代平</code><br>联系方式：</p>
<ul>
<li>E-mail: <a href="mailto:dphu@sjtu.edu.cn" target="_blank" rel="external">dphu@sjtu.edu.cn</a></li>
<li>办公室：徐汇校区 安泰经济与管理学院 1711</li>
</ul>
<p>助教<code>唐铭</code><br>联系方式：</p>
<ul>
<li>E-mail: <a href="mailto:mtang024@126.com" target="_blank" rel="external">mtang024@126.com</a>  （除作业之外的邮件可以确保24小时内回复）</li>
<li>Skype: mingotang</li>
</ul>
<blockquote>
<p>课程资料链接：<a href="https://yun.baidu.com/s/1jHEyYTS" target="_blank" rel="external">百度云：https://yun.baidu.com/s/1jHEyYTS</a>  密码: u9m4</p>
</blockquote>
<h2 id="作业相关"><a href="#作业相关" class="headerlink" title="作业相关"></a><em>作业相关</em></h2><p>作业提交：</p>
<ul>
<li>请在作业截止时间之前把作业发送到 <a href="mailto:mtang024@126.com" target="_blank" rel="external">mtang024@126.com</a>，迟交作业将会按照迟交时间多少扣除一部分作业分数，抄袭作业将会失去大部分作业分数</li>
<li>作业邮件<code>标题</code>和<code>附件</code>请使用 <code>DBMSSAS+C1/C2+学号+姓名+作业编号（编号之前不需要补0）</code> 格式来命名（加号其实是一个空格），例如：<code>DBMSSAS C1 51616161616 姓名 1</code>；非作业提交邮件邮件标题请勿使用这个规则</li>
<li>一般情况下，请把作业涉及到的文字、图片和代码写在<code>word</code>文件里面；如果把文字和代码写在文本文件里面，请在邮件正文<code>注明文本编码</code>（例如 utf-8 或者 gb18030），若除了文本文件之外还有其他文件（依然建议把sas等文件内容写在word里面），请把所有文件放在一个zip压缩包里面</li>
<li>很多时候 sjtu邮箱 是收不到非 sjtu邮箱 发送的文件的，所以使用sjtu邮箱的同学如果没收到我的回信请不要惊讶</li>
</ul>
<div class="note warning"><br>    <h5>请严格按照 <code>DBMSSAS+C1/C2+学号+姓名+作业编号</code> 命名邮件标题和附件</h5><br>    <p>我会在作业提交时间截止时间之后查阅作业并作出回复，所有按照上述规则命名的邮件将自动进入我邮箱的单独文件夹，所以作业提交不按照上述规则命名的话邮件会进入我的收件箱因此可能会被漏掉，同时在学期结束之前检查作业提交情况时我会依照关键字 DBMSSAS 和 姓名 来检索邮件</p><br></div>


<p>作业提交记录：<strong><a href="https://www.icloud.com/numbers/02hSemhFLGugCaOxiZ7KZI-fQ" target="_blank" rel="external">点此查看作业提交记录</a></strong></p>
<h2 id="作业参考答案"><a href="#作业参考答案" class="headerlink" title="作业参考答案"></a><em>作业参考答案</em></h2><p>有时候这个页面没有变化请删除cookies或者刷新，作业参考答案会在作业截止时间之后不久放出。</p>
<ul>
<li><a href="http://mingotang.website/2017/09/26/DBMSSAS-Assignment1/" target="_blank" rel="external">DBMSSAS Assignment1(2017年09月26日8点前提交)</a></li>
<li><a href="http://mingotang.website/2017/09/26/DBMSSAS-Assignment2/" target="_blank" rel="external">DBMSSAS Assignment2(2017年10月10日8点前提交)</a></li>
<li><a href="http://mingotang.website/2017/09/29/DBMSSAS-Assignment3/" target="_blank" rel="external">DBMSSAS Assignment3(2017年10月10日8点前提交)</a></li>
</ul>
<h2 id="关于本页面"><a href="#关于本页面" class="headerlink" title="关于本页面"></a><em>关于本页面</em></h2><p>本页面使用 GitHub Page 项目实现，网页承载力比较差（毕竟是免费的），所以载入时间较长请谅解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库基础及SAS应用课程信息&lt;/p&gt;
    
    </summary>
    
    
      <category term="TA" scheme="http://mingotang.github.io/tags/TA/"/>
    
  </entry>
  
  <entry>
    <title>python相关技巧</title>
    <link href="http://mingotang.github.io/2017/09/15/python%E7%9B%B8%E5%85%B3%E6%8A%80%E5%B7%A7/"/>
    <id>http://mingotang.github.io/2017/09/15/python相关技巧/</id>
    <published>2017-09-15T07:38:39.000Z</published>
    <updated>2017-09-29T06:08:07.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="pip-and-packages"><a href="#pip-and-packages" class="headerlink" title="pip and packages"></a>pip and packages</h2><p>获取python运行环境下的扩展包：<code>$ pip freeze &gt; requirements.txt</code></p>
<p>获取当前项目使用扩展包：<code>$ pipreqs /path/to/project</code></p>
<p>安装requirements：<code>$ pip install -r requirements.txt</code></p>
<h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><h3 id="更改-jupyter-notebook-主题"><a href="#更改-jupyter-notebook-主题" class="headerlink" title="更改 jupyter notebook 主题"></a>更改 jupyter notebook 主题</h3><p>使用的是jupyter-themes</p>
<p>首先在控制台下用pip 安装 <a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="external">jupyter-themes</a></p>
<pre><code>$ pip install --upgrade jupyterthemes
</code></pre><p>然后可以查看所有可用的主题：</p>
<pre><code>$ jt -l

Available Themes:
   chesterish
   grade3
   monokai
   oceans16
   onedork
   solarizedd
   solarizedl
</code></pre><p>可以用下面命令选择要用的主题。</p>
<pre><code>$ jt -t 主题名称
</code></pre><p>如果要恢复默认：</p>
<pre><code>$ jt -r
</code></pre><p><a href="https://github.com/dunovank/jupyter-themes" target="_blank" rel="external">查看各主题样式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;pip-and-packages&quot;&gt;&lt;a href=&quot;#pip-and-packages&quot; class=&quot;headerlink&quot; title=&quot;pip and packages&quot;&gt;&lt;/a&gt;pip and packages&lt;/h2
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Pandas Cheat List</title>
    <link href="http://mingotang.github.io/2017/09/14/Pandas-Cheat-List/"/>
    <id>http://mingotang.github.io/2017/09/14/Pandas-Cheat-List/</id>
    <published>2017-09-14T03:08:41.000Z</published>
    <updated>2017-09-25T03:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="class-DataFrame"><a href="#class-DataFrame" class="headerlink" title="class - DataFrame"></a>class - DataFrame</h2><p>A pandas DataFrame is a data structure, which is a labeled two-dimensional object and is similar in spirit to an Excel worksheet or a relational database table.</p>
<p>A DataFrame can be created in the following ways:</p>
<ul>
<li>From another DataFrame.</li>
<li>From a NumPy array or a composite of arrays that has a two-dimensional shape.</li>
<li>Likewise, we can create a DataFrame out of another pandas data structure<br>called Series. We will learn about Series in the following section.</li>
<li>A DataFrame can also be produced from a file, such as a CSV file.</li>
</ul>
<p>Eg.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas.io.parsers <span class="keyword">import</span> read_csv</div><div class="line">df = read_csv(<span class="string">"WHO_first9cols.csv"</span>)</div></pre></td></tr></table></figure></p>
<h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes:"></a>attributes:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df.shape	<span class="comment"># attribute that holds its shape as a tuple</span></div><div class="line">df.columns	<span class="comment"># Check the column's header</span></div><div class="line">df.dtypes		<span class="comment"># Check the column's data types</span></div><div class="line">df.index	 <span class="comment"># the primary key of relational database tables</span></div><div class="line">df.values	 <span class="comment"># iterate with NumPy arrays</span></div></pre></td></tr></table></figure>
<h2 id="class-Series"><a href="#class-Series" class="headerlink" title="class - Series"></a>class - Series</h2><p>The pandas Series data structure is a one-dimensional heterogeneous array with labels.</p>
<p>We can create a pandas Series data structure as follows:</p>
<ul>
<li>From a Python dict</li>
<li>From a NumPy array</li>
<li>From a single scalar value</li>
</ul>
<p>Eg.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">country_col = df[<span class="string">"Country"</span>]</div></pre></td></tr></table></figure></p>
<h3 id="attributes-1"><a href="#attributes-1" class="headerlink" title="attributes"></a>attributes</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">country_col.shape</div><div class="line">country_col.index</div><div class="line">country_col.values</div><div class="line">country_col.name</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;class-DataFrame&quot;&gt;&lt;a href=&quot;#class-DataFrame&quot; class=&quot;headerlink&quot; title=&quot;class - DataFrame&quot;&gt;&lt;/a&gt;class - DataFrame&lt;/h2
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>NumPy Arrays Cheat List</title>
    <link href="http://mingotang.github.io/2017/09/12/NumPy-Arrays-Cheat-List/"/>
    <id>http://mingotang.github.io/2017/09/12/NumPy-Arrays-Cheat-List/</id>
    <published>2017-09-12T08:38:56.000Z</published>
    <updated>2017-09-25T03:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="The-NumPy-array-object"><a href="#The-NumPy-array-object" class="headerlink" title="The NumPy array object"></a>The NumPy array object</h2><hr>
<h3 id="class-dtype"><a href="#class-dtype" class="headerlink" title="class - dtype"></a>class - dtype</h3><h4 id="attributes"><a href="#attributes" class="headerlink" title="attributes:"></a>attributes:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dtype.char</div><div class="line"></div><div class="line">dtype.type</div><div class="line"></div><div class="line">dtype.str</div></pre></td></tr></table></figure>
<h4 id="numerical-types"><a href="#numerical-types" class="headerlink" title="numerical types:"></a>numerical types:</h4><table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>Boolean (True or False) stored as a bit</td>
</tr>
<tr>
<td>inti</td>
<td>Platform integer (normally either int32 or int64)</td>
</tr>
<tr>
<td>int8</td>
<td>Byte (-128 to 127)</td>
</tr>
<tr>
<td>int16</td>
<td>Integer (-32768 to 32767)</td>
</tr>
<tr>
<td>int32</td>
<td>Integer (-2 ** 31 to 2 ** 31 -1)</td>
</tr>
<tr>
<td>int64</td>
<td>Integer (-2 ** 63 to 2 ** 63 -1)</td>
</tr>
<tr>
<td>uint8</td>
<td>Unsigned integer (0 to 255)</td>
</tr>
<tr>
<td>uint16</td>
<td>Unsigned integer (0 to 65535)</td>
</tr>
<tr>
<td>uint32</td>
<td>Unsigned integer (0 to 2 ** 32 - 1)</td>
</tr>
<tr>
<td>uint64</td>
<td>Unsigned integer (0 to 2 ** 64 - 1)</td>
</tr>
<tr>
<td>float16</td>
<td>Half precision float: sign bit, 5 bits exponent, and 10 bits mantissa</td>
</tr>
<tr>
<td>float32</td>
<td>Single precision float: sign bit, 8 bits exponent, and 23 bits mantissa</td>
</tr>
<tr>
<td>float64 or float</td>
<td>Double precision float: sign bit, 11 bits exponent, and 52 bits mantissa</td>
</tr>
<tr>
<td>complex64</td>
<td>Complex number, represented by two 32-bit floats (real and imaginary components)</td>
</tr>
<tr>
<td>complex128 or complex</td>
<td>Complex number, represented by two 64-bit floats (real and imaginary components)</td>
</tr>
</tbody>
</table>
<h3 id="class-array"><a href="#class-array" class="headerlink" title="class - array"></a>class - array</h3><h4 id="creation"><a href="#creation" class="headerlink" title="creation:"></a>creation:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array([x, x, x])</div><div class="line"></div><div class="line">zeros(int)</div><div class="line"></div><div class="line">ones(int)</div></pre></td></tr></table></figure>
<h4 id="attributes-1"><a href="#attributes-1" class="headerlink" title="attributes:"></a>attributes:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">array.ndim  <span class="comment"># n * ndim, gives the number of dimensions</span></div><div class="line"></div><div class="line">array.size  <span class="comment"># n * ndim = size, holds the count of elements</span></div><div class="line"></div><div class="line">array.itemsize  <span class="comment"># returns the count of bytes for each element in the array</span></div><div class="line"></div><div class="line">array.nbytes  <span class="comment"># size * itemsize</span></div><div class="line"></div><div class="line">array.resize(int, int)</div><div class="line"></div><div class="line">array.T</div><div class="line"></div><div class="line">array.dtype.str</div><div class="line"></div><div class="line">array.flat  <span class="comment"># flatten</span></div><div class="line"></div><div class="line">array.real</div><div class="line"></div><div class="line">array.imag</div></pre></td></tr></table></figure>
<h4 id="slicing-and-indexing"><a href="#slicing-and-indexing" class="headerlink" title="slicing and indexing:"></a>slicing and indexing:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arange(length: int)</div><div class="line"></div><div class="line">array[start:stop:step]</div></pre></td></tr></table></figure>
<h4 id="array-shapes"><a href="#array-shapes" class="headerlink" title="array shapes:"></a>array shapes:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">array.reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">array.ravel()	 <span class="comment"># view</span></div><div class="line"></div><div class="line">array.flatten()  <span class="comment"># allocate memory</span></div><div class="line"></div><div class="line">array.shape = (<span class="number">6</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">array.transpose()</div><div class="line"></div><div class="line">array.resize((<span class="number">2</span>, <span class="number">12</span>))</div></pre></td></tr></table></figure>
<h4 id="stacking-arrays"><a href="#stacking-arrays" class="headerlink" title="stacking arrays:"></a>stacking arrays:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">hstack((a, b))  <span class="comment"># a left, b right</span></div><div class="line"></div><div class="line">concatenate((a, b), axis=<span class="number">1</span>)</div><div class="line"></div><div class="line">vstack((a, b))  <span class="comment"># a over, b down</span></div><div class="line"></div><div class="line">concatenate((a, b), axis=<span class="number">0</span>)</div><div class="line"></div><div class="line">dstack((a, b))	<span class="comment"># stacking a list of arrays along the third axis (depth)</span></div></pre></td></tr></table></figure>
<h4 id="splitting-arrays"><a href="#splitting-arrays" class="headerlink" title="splitting arrays:"></a>splitting arrays:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hsplit(array, parts: int)</div><div class="line"></div><div class="line">vsplit(array, parts: int)</div><div class="line"></div><div class="line">dsplit(array, sqrt(parts: int))</div></pre></td></tr></table></figure>
<h4 id="views-and-copies"><a href="#views-and-copies" class="headerlink" title="views and copies:"></a>views and copies:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array.copy()</div><div class="line"></div><div class="line">array.view()</div></pre></td></tr></table></figure>
<h4 id="Basic-descriptive-statistics-with-NumPy"><a href="#Basic-descriptive-statistics-with-NumPy" class="headerlink" title="Basic descriptive statistics with NumPy:"></a>Basic descriptive statistics with NumPy:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">array.max(), np.max(data)</div><div class="line"></div><div class="line">array.min()</div><div class="line"></div><div class="line">array.mean()</div><div class="line"></div><div class="line">array.std()</div><div class="line"></div><div class="line">array.median()</div></pre></td></tr></table></figure>
<h4 id="ignoring-values"><a href="#ignoring-values" class="headerlink" title="ignoring values"></a>ignoring values</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">np.ma.log(array)</div><div class="line"></div><div class="line">np.ma.masked_outside(array, bottem, top)</div></pre></td></tr></table></figure>
<h3 id="class-matrice"><a href="#class-matrice" class="headerlink" title="class - matrice"></a>class - matrice</h3><h4 id="creation-1"><a href="#creation-1" class="headerlink" title="creation:"></a>creation:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mat(<span class="string">'x x; x x; x x'</span>)</div><div class="line"></div><div class="line">eye(int)  <span class="comment"># I with scale int</span></div></pre></td></tr></table></figure>
<h4 id="linear-algebra"><a href="#linear-algebra" class="headerlink" title="linear algebra:"></a>linear algebra:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">np.linalg.inv(matrice)  <span class="comment"># inverse of matrice</span></div><div class="line"></div><div class="line">np.linalg.solve(A, b)  <span class="comment"># solve A * x = b</span></div><div class="line"></div><div class="line">np.linalg.dot(A, x)  <span class="comment"># calcuate A * x</span></div><div class="line"></div><div class="line">np.linalg.eigvals(A)  <span class="comment"># eigenvalues of A</span></div><div class="line"></div><div class="line">np.linalg.eig(A)  <span class="comment"># eigenvalues and eigenvectors of A</span></div></pre></td></tr></table></figure>
<h3 id="class-random"><a href="#class-random" class="headerlink" title="class - random"></a>class - random</h3><h4 id="random-functions"><a href="#random-functions" class="headerlink" title="random functions:"></a>random functions:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">normal(size=<span class="number">1000</span>)</div><div class="line"></div><div class="line">binomial(<span class="number">9</span>, <span class="number">0.5</span>, size=<span class="number">1000</span>)</div></pre></td></tr></table></figure>
<h4 id="Test"><a href="#Test" class="headerlink" title="Test:"></a>Test:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">from</span> scipy.stats <span class="keyword">import</span> shapiro</div><div class="line"></div><div class="line"><span class="comment"># The Shapiro-Wilk test can check for normality.</span></div><div class="line"><span class="comment"># The corresponding SciPy function returns a tuple of which the  rst number is a test statistic and the second number is a p-value.</span></div><div class="line"></div><div class="line">	<span class="keyword">from</span> scipy.stats <span class="keyword">import</span> anderson</div><div class="line"></div><div class="line"><span class="comment"># The Anderson-Darling test can check for normality and also for other distributions such as Exponential, Logistic, and Gumbel.</span></div><div class="line"><span class="comment"># The related SciPy function related a test statistic and an array containing critical values for the 15, 10, 5, 2.5, and 1 percentage signi cance levels.</span></div><div class="line"></div><div class="line">	<span class="keyword">from</span> scipy.stats <span class="keyword">import</span> normaltest</div><div class="line"></div><div class="line"><span class="comment"># The D'Agostino and Pearson's test is also implemented in SciPy as the normaltest() function.</span></div><div class="line"><span class="comment"># This function returns a tuple with a statistic and p-value just like the shapiro() function. The p-value is a two-sided Chi-squared probability.</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;The-NumPy-array-object&quot;&gt;&lt;a href=&quot;#The-NumPy-array-object&quot; class=&quot;headerlink&quot; title=&quot;The NumPy array object&quot;&gt;&lt;/a&gt;Th
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Aprior算法</title>
    <link href="http://mingotang.github.io/2017/09/11/Aprior%E7%AE%97%E6%B3%95/"/>
    <id>http://mingotang.github.io/2017/09/11/Aprior算法/</id>
    <published>2017-09-11T11:28:12.000Z</published>
    <updated>2017-09-29T05:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>关联规则挖掘在电商、零售、大气物理、生物医学已经有了广泛的应用。</p>
<p>啤酒与尿布的故事已经成为了关联规则挖掘的经典案例，还有人专门出了一本书《啤酒与尿布》，虽然说这个故事是哈弗商学院杜撰出来的，但确实能很好的解释关联规则挖掘的原理。</p>
<a id="more"></a>
<h2 id="一、关联规则、自信度、自持度的定义"><a href="#一、关联规则、自信度、自持度的定义" class="headerlink" title="一、关联规则、自信度、自持度的定义"></a>一、关联规则、自信度、自持度的定义</h2><p>关联规则就是有关联的规则，形式是这样定义的：两个不相交的非空集合X、Y，如果有X–&gt;Y，就说X–&gt;Y是一条关联规则。关联规则的强度用支持度(support)和自信度(confidence)来描述，</p>
<p>支持度的定义：support(X–&gt;Y) = |X交Y|/N = 集合X与集合Y中的项在一条记录中同时出现的次数/数据记录的个数。</p>
<p>自信度的定义：confidence(X–&gt;Y) = |X交Y|/|X| = 集合X与集合Y中的项在一条记录中同时出现的次数/集合X出现的个数 。</p>
<p>这里定义的支持度和自信度都是相对的支持度和自信度，不是绝对支持度，绝对支持度abs_support = 数据记录数N * support。</p>
<p>支持度和自信度越高，说明规则越强，关联规则挖掘就是挖掘出满足一定强度的规则。</p>
<h2 id="二、关联规则挖掘的定义与步骤"><a href="#二、关联规则挖掘的定义与步骤" class="headerlink" title="二、关联规则挖掘的定义与步骤"></a>二、关联规则挖掘的定义与步骤</h2><p>关联规则挖掘的定义：给定一个交易数据集T，找出其中所有支持度support &gt;= min_support、自信度confidence &gt;= min_confidence的关联规则。</p>
<p>有一个简单而粗鲁的方法可以找出所需要的规则，那就是穷举项集的所有组合，并测试每个组合是否满足条件，一个元素个数为n的项集的组合个数为2^n-1(除去空集)，所需要的时间复杂度明显为O(2^N)，对于普通的超市，其商品的项集数也在1万以上，用指数时间复杂度的算法不能在可接受的时间内解决问题。怎样快速挖出满足条件的关联规则是关联挖掘的需要解决的主要问题。</p>
<p>仔细想一下，我们会发现对于{啤酒–&gt;尿布}，{尿布–&gt;啤酒}这两个规则的支持度实际上只需要计算{尿布，啤酒}的支持度，即它们交集的支持度。于是我们把关联规则挖掘分两步进行：</p>
<ul>
<li><p>1）生成频繁项集: 这一阶段找出所有满足最小支持度的项集，找出的这些项集称为频繁项集。</p>
</li>
<li><p>2）生成规则: 在上一步产生的频繁项集的基础上生成满足最小自信度的规则，产生的规则称为强规则。</p>
</li>
</ul>
<p>关联规则挖掘所花费的时间主要是在生成频繁项集上，因为找出的频繁项集往往不会很多，利用频繁项集生成规则也就不会花太多的时间，而生成频繁项集需要测试很多的备选项集，如果不加优化，所需的时间是O(2^N)。</p>
<h2 id="三、Apriori定律"><a href="#三、Apriori定律" class="headerlink" title="三、Apriori定律"></a>三、Apriori定律</h2><p>为了减少频繁项集的生成时间，应该尽早的消除一些完全不可能是频繁项集的集合。</p>
<ul>
<li><p>1)：如果一个集合是频繁项集，则它的所有子集都是频繁项集。举例：假设一个集合{A,B}是频繁项集，即A、B同时出现在一条记录的次数大于等于最小支持度min_support，则它的子集{A},{B}出现次数必定大于等于min_support，即它的子集都是频繁项集。</p>
</li>
<li><p>2)：如果一个集合不是频繁项集，则它的所有超集都不是频繁项集。举例：假设集合{A}不是频繁项集，即A出现的次数小于min_support，则它的任何超集如{A,B}出现的次数必定小于min_support，因此其超集必定也不是频繁项集。</p>
</li>
</ul>
<p>利用这两条定律，我们抛掉很多的候选项集，Apriori算法就是利用这两个定理来实现快速挖掘频繁项集的。</p>
<h2 id="四、Apriori算法"><a href="#四、Apriori算法" class="headerlink" title="四、Apriori算法"></a>四、Apriori算法</h2><p>Apriori是由a priori合并而来的，它的意思是后面的是在前面的基础上推出来的，即先验推导，怎么个先验法，其实就是二级频繁项集是在一级频繁项集的基础上产生的，三级频繁项集是在二级频繁项集的基础上产生的，以此类推。</p>
<p>Apriori算法属于候选消除算法，是一个生成候选集、消除不满足条件的候选集、并不断循环直到不再产生候选集的过程。</p>
<p>关键代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">TODO:</span> Auto-generated method stub</span></div><div class="line">record = getRecord(); <span class="comment">// 获取原始数据记录</span></div><div class="line">List&lt;List&lt;String&gt;&gt; cItemset = findFirstCandidate();  <span class="comment">// 获取第一次的备选集</span></div><div class="line">List&lt;List&lt;String&gt;&gt; lItemset = getSupportedItemset(cItemset);  <span class="comment">// 获取备选集cItemset满足支持的集合</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> (endTag != <span class="literal">true</span>) &#123;  <span class="comment">// 只要能继续挖掘</span></div><div class="line">  List&lt;List&lt;String&gt;&gt; ckItemset = getNextCandidate(lItemset);  <span class="comment">// 获取第下一次的备选集</span></div><div class="line">  List&lt;List&lt;String&gt;&gt; lkItemset = getSupportedItemset(ckItemset);  <span class="comment">// 获取备选集cItemset满足支持的集合</span></div><div class="line">  getConfidencedItemset(lkItemset, lItemset, dkCountMap, dCountMap);  <span class="comment">// 获取备选集cItemset满足置信度的集合</span></div><div class="line">  <span class="keyword">if</span> (confItemset.size() != <span class="number">0</span>)  <span class="comment">// 满足置信度的集合不为空</span></div><div class="line">    printConfItemset(confItemset);  <span class="comment">// 打印满足置信度的集合</span></div><div class="line">    confItemset.clear();  <span class="comment">// 清空置信度的集合</span></div><div class="line">    cItemset = ckItemset;  <span class="comment">// 保存数据，为下次循环迭代准备</span></div><div class="line">    lItemset = lkItemset;</div><div class="line">    dCountMap.clear();</div><div class="line">    dCountMap.putAll(dkCountMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关联规则挖掘在电商、零售、大气物理、生物医学已经有了广泛的应用。&lt;/p&gt;
&lt;p&gt;啤酒与尿布的故事已经成为了关联规则挖掘的经典案例，还有人专门出了一本书《啤酒与尿布》，虽然说这个故事是哈弗商学院杜撰出来的，但确实能很好的解释关联规则挖掘的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>python操作符重载</title>
    <link href="http://mingotang.github.io/2017/09/11/python%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://mingotang.github.io/2017/09/11/python操作符重载/</id>
    <published>2017-09-11T00:50:21.000Z</published>
    <updated>2017-09-25T03:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="http://blog.csdn.net/Rozol/article/details/70769628" target="_blank" rel="external">http://blog.csdn.net/Rozol/article/details/70769628</a></p>
<a id="more"></a>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>:</span></div><div class="line"></div><div class="line">    <span class="comment"># 构造方法, 对象实例化时调用</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"构造方法"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 析构方法, 对象被回收时调用</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"析构方法"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># __init__之前调用, 一般用于重写父类的__new__方法</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></div><div class="line">        print(<span class="string">"new"</span>)</div><div class="line">        <span class="keyword">return</span> object.__new__(cls)</div></pre></td></tr></table></figure>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></div><div class="line">        self.data = num</div><div class="line">    <span class="comment"># +</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data + other.data</div><div class="line">    <span class="comment"># -</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data - other.data</div><div class="line">    <span class="comment"># *</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data * other.data</div><div class="line">    <span class="comment"># /</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__truediv__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data / other.data</div><div class="line">    <span class="comment"># //</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__floordiv__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data // other.data</div><div class="line">    <span class="comment"># %</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mod__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data % other.data</div><div class="line">    <span class="comment"># divmod()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__divmod__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="comment"># 商(10/5),余数(10%5)</span></div><div class="line">        <span class="keyword">return</span> self.data / other.data, self.data % other.data</div><div class="line">    <span class="comment"># **</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__pow__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data ** other.data</div><div class="line">    <span class="comment"># &lt;&lt;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lshift__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &lt;&lt; other.data</div><div class="line">    <span class="comment"># &gt;&gt;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rshift__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &gt;&gt; other.data</div><div class="line">    <span class="comment"># &amp;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__and__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &amp; other.data</div><div class="line">    <span class="comment"># ^</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__xor__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data ^ other.data</div><div class="line">    <span class="comment"># |</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data | other.data</div></pre></td></tr></table></figure>
<h2 id="反算术运算符-a-b-若a不支持算术运算符-则寻找b的算术运算符"><a href="#反算术运算符-a-b-若a不支持算术运算符-则寻找b的算术运算符" class="headerlink" title="反算术运算符(a+b, 若a不支持算术运算符,则寻找b的算术运算符)"></a>反算术运算符(a+b, 若a不支持算术运算符,则寻找b的算术运算符)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></div><div class="line">        self.data = num</div><div class="line">    <span class="comment"># +</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data + self.data</div><div class="line">    <span class="comment"># -</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rsub__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data - self.data</div><div class="line">    <span class="comment"># *</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rmul__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data * self.data</div><div class="line">    <span class="comment"># /</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rtruediv__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data / self.data</div><div class="line">    <span class="comment"># //</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rfloordiv__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data // self.data</div><div class="line">    <span class="comment"># %</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rmod__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data % self.data</div><div class="line">    <span class="comment"># divmod()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rdivmod__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data / self.data, other.data % self.data</div><div class="line">    <span class="comment"># **</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rpow__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data ** self.data</div><div class="line">    <span class="comment"># &lt;&lt;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rlshift__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data &lt;&lt; self.data</div><div class="line">    <span class="comment"># &gt;&gt;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rrshift__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data &gt;&gt; self.data</div><div class="line">    <span class="comment"># &amp;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rand__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data &amp; self.data</div><div class="line">    <span class="comment"># ^</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__rxor__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data ^ self.data</div><div class="line">    <span class="comment"># |</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> other.data | self.data</div></pre></td></tr></table></figure>
<h2 id="增量赋值运算-注-位置同原始函数-在原始函数名前-i"><a href="#增量赋值运算-注-位置同原始函数-在原始函数名前-i" class="headerlink" title="增量赋值运算 (注:位置同原始函数,在原始函数名前+i)"></a>增量赋值运算 (注:位置同原始函数,在原始函数名前+i)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></div><div class="line">        self.data = num</div><div class="line">    <span class="comment"># +=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data + other</div><div class="line">    <span class="comment"># -=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__isub__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data - other</div><div class="line">    <span class="comment"># *=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__imul__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data * other</div><div class="line">    <span class="comment"># /=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__itruediv__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data / other</div><div class="line">    <span class="comment"># //=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ifloordiv__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data // other</div><div class="line">    <span class="comment"># %=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__imod__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data % other</div><div class="line">    <span class="comment"># **=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ipow__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data ** other</div><div class="line">    <span class="comment"># &lt;&lt;=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ilshift__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &lt;&lt; other</div><div class="line">    <span class="comment"># &gt;&gt;=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__irshift__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &gt;&gt; other</div><div class="line">    <span class="comment"># &amp;=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iand__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &amp; other</div><div class="line">    <span class="comment"># ^=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ixor__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data ^ other</div><div class="line">    <span class="comment"># |=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ior__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data | other</div></pre></td></tr></table></figure>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></div><div class="line">        self.data = num</div><div class="line">    <span class="comment"># &lt;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &lt; other.data</div><div class="line">    <span class="comment"># &lt;=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__le__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &lt;= other.data</div><div class="line">    <span class="comment"># ==</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data == other.data</div><div class="line">    <span class="comment"># !=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ne__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data != other.data</div><div class="line">    <span class="comment"># &gt;</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__gt__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &gt; other.data</div><div class="line">    <span class="comment"># &gt;=</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__ge__</span><span class="params">(self, other)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.data &gt;= other.data</div></pre></td></tr></table></figure>
<h2 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></div><div class="line">        self.data = num</div><div class="line">    <span class="comment"># + 正号</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__pos__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> +abs(self.data)</div><div class="line">    <span class="comment"># - 负号</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__neg__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> -abs(self.data)</div><div class="line">    <span class="comment"># abs() 绝对值</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> abs(self.data)</div><div class="line">    <span class="comment"># ~ 按位取反</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__invert__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> ~self.data</div><div class="line">    <span class="comment"># complex() 字符转数字</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__complex__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="number">2j</span></div><div class="line">    <span class="comment"># int() 转为整数</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="number">123</span></div><div class="line">    <span class="comment"># float() 转为浮点数</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__float__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1.23</span></div><div class="line">    <span class="comment"># round()  近似值</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__round__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1.123</span></div></pre></td></tr></table></figure>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>:</span></div><div class="line">    <span class="comment"># print() 打印</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"This is the demo."</span></div><div class="line">    <span class="comment"># repr() 对象字符串表示</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"This is a demo."</span></div><div class="line">    <span class="comment"># bytes() 对象字节字符串表现形式</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">b"This is one demo."</span></div><div class="line">    <span class="comment"># format() 格式化</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__format__</span><span class="params">(self, format_spec)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__str__()</div></pre></td></tr></table></figure>
<h2 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>:</span></div><div class="line">    <span class="comment"># 获取(不存在)属性</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> (<span class="string">"访问的属性不存在"</span>)</div><div class="line">    <span class="comment"># getattr() hasattr() 获取属性</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, attr)</span>:</span></div><div class="line">        <span class="keyword">print</span> (<span class="string">"访问的属性是%s"</span>%attr)</div><div class="line">        <span class="keyword">return</span> attr</div><div class="line">    <span class="comment"># setattr() 设置属性</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, attr, value)</span>:</span></div><div class="line">        <span class="keyword">print</span> (<span class="string">"设置 %s 属性值为 %s"</span>%(attr, value))</div><div class="line">    <span class="comment"># delattr() 删除属性</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, attr)</span>:</span></div><div class="line">        <span class="keyword">print</span> (<span class="string">"删除 %s 属性"</span>%attr)</div></pre></td></tr></table></figure>
<h2 id="描述器-类-test1-的实例出现在属主类-runtest-中-这些方法才会调用-注-函数调用-这些方法不会被调用"><a href="#描述器-类-test1-的实例出现在属主类-runtest-中-这些方法才会调用-注-函数调用-这些方法不会被调用" class="headerlink" title="描述器(类(test1)的实例出现在属主类(runtest)中,这些方法才会调用)(注:函数调用,这些方法不会被调用)"></a>描述器(类(test1)的实例出现在属主类(runtest)中,这些方法才会调用)(注:函数调用,这些方法不会被调用)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">test1</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value = <span class="number">1</span>)</span>:</span></div><div class="line">        self.value = value * <span class="number">2</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">        print(<span class="string">"set %s %s %s"</span>%(self, instance, value))</div><div class="line">        self.value = value * <span class="number">2</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></div><div class="line">        print(<span class="string">"get %s %s %s"</span>%(self, instance, owner))</div><div class="line">        <span class="keyword">return</span> self.value</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></div><div class="line">        print(<span class="string">"delete %s %s"</span>%(self, instance))</div><div class="line">        <span class="keyword">del</span> self.value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">test2</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value = <span class="number">1</span>)</span>:</span></div><div class="line">        self.value = value + <span class="number">0.3</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">        print(<span class="string">"set %s %s %s"</span>%(self, instance, value))</div><div class="line">        instance.t1 = value + <span class="number">0.3</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></div><div class="line">        print(<span class="string">"get %s %s %s"</span>%(self, instance, owner))</div><div class="line">        <span class="keyword">return</span> instance.t1</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></div><div class="line">        print(<span class="string">"delete %s %s"</span>%(self, instance))</div><div class="line">        <span class="keyword">del</span> self.value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">runtest</span>:</span></div><div class="line">    t1 = test1()</div><div class="line">    t2 = test2()</div><div class="line"></div><div class="line"><span class="comment"># ---</span></div><div class="line"></div><div class="line"><span class="comment"># 自定义property</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">property_my</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget=None, fset=None, fdel=None)</span>:</span></div><div class="line">        self.fget = fget</div><div class="line">        self.fset = fset</div><div class="line">        self.fdel = fdel</div><div class="line">    <span class="comment"># 对象被获取(self自身, instance调用该对象的对象(demo9), owner调用该对象的对象类对象(demo9))</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></div><div class="line">        print(<span class="string">"get %s %s %s"</span>%(self, instance, owner))</div><div class="line">        <span class="keyword">return</span> self.fget(instance)</div><div class="line">    <span class="comment"># 对象被设置属性时</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></div><div class="line">        print(<span class="string">"set %s %s %s"</span>%(self, instance, value))</div><div class="line">        self.fset(instance, value)</div><div class="line">    <span class="comment"># 对象被删除时</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></div><div class="line">        print(<span class="string">"delete %s %s"</span>%(self, instance))</div><div class="line">        self.fdel(instance)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo10</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.num = <span class="keyword">None</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setvalue</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.num = value</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getvalue</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.num</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">del</span> self.num</div><div class="line">    x = property_my(getvalue, setvalue, delete)</div></pre></td></tr></table></figure>
<h2 id="自定义容器"><a href="#自定义容器" class="headerlink" title="自定义容器"></a>自定义容器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">lis</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        self.lists = args</div><div class="line">        self.size = len(args)</div><div class="line">        self.startindex = <span class="number">0</span></div><div class="line">        self.endindex = self.size</div><div class="line">    <span class="comment"># len() 容器元素数量</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.size;</div><div class="line">    <span class="comment"># lis[1] 获取元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key = <span class="number">0</span>)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.lists[key]</div><div class="line">    <span class="comment"># lis[1] = value 设置元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="comment"># del lis[1] 删除元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="comment"># 返回迭代器</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line">    <span class="comment"># rversed() 反向迭代器</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> self.endindex &gt; <span class="number">0</span>:</div><div class="line">            self.endindex -= <span class="number">1</span></div><div class="line">            <span class="keyword">yield</span> self[self.endindex]</div><div class="line">    <span class="comment"># next() 迭代器下个元素</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.startindex &gt;= self.size:</div><div class="line">            <span class="keyword">raise</span> StopIteration <span class="comment"># 控制迭代器结束</span></div><div class="line"></div><div class="line">        elem = self.lists[self.startindex]</div><div class="line">        self.startindex += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> elem</div><div class="line"></div><div class="line">    <span class="comment"># in / not in</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, item)</span>:</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.lists:</div><div class="line">            <span class="keyword">if</span> i == item:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yield 生成器(执行一次返回,下次继续执行后续代码返回)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">yielddemo</span><span class="params">()</span>:</span></div><div class="line">    num = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>: <span class="comment"># 1 == True; 0 == False</span></div><div class="line">        <span class="keyword">if</span> num &gt;= <span class="number">10</span>:</div><div class="line">            <span class="keyword">raise</span> StopIteration</div><div class="line">        num += <span class="number">1</span></div><div class="line">        <span class="keyword">yield</span> num</div><div class="line"></div><div class="line"><span class="comment"># 能接收数据的生成器</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">yielddemo_1</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">        num = <span class="keyword">yield</span></div><div class="line">        print(num)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># with 自动上下文管理</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">withdemo</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.value = value</div><div class="line">    <span class="comment"># 返回值为 as 之后的值</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.value</div><div class="line">    <span class="comment"># 执行完成,退出时的数据清理动作</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></div><div class="line">        <span class="keyword">del</span> self.value</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># yield 生成器(可迭代对象Iterable)</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> yielddemo():</div><div class="line">    print(i)</div><div class="line"><span class="comment"># ---</span></div><div class="line">iters = iter(yielddemo())</div><div class="line">print(next(iters))</div><div class="line">print(next(iters))</div><div class="line"></div><div class="line"><span class="comment"># --- 发送数据给生成器 ---</span></div><div class="line">iters = yielddemo_1()</div><div class="line">next(iters)</div><div class="line">iters.send(<span class="number">6</span>) <span class="comment"># 发送数据并执行</span></div><div class="line">iters.send(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># with 自动上下文管理</span></div><div class="line"><span class="keyword">with</span> withdemo(<span class="string">"Less is more!"</span>) <span class="keyword">as</span> s:</div><div class="line">    print(s)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;http://blog.csdn.net/Rozol/article/details/70769628&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/Rozol/article/details/70769628&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>不要让鱼去学爬树</title>
    <link href="http://mingotang.github.io/2017/09/09/%E4%B8%8D%E8%A6%81%E8%AE%A9%E9%B1%BC%E5%8E%BB%E5%AD%A6%E7%88%AC%E6%A0%91/"/>
    <id>http://mingotang.github.io/2017/09/09/不要让鱼去学爬树/</id>
    <published>2017-09-09T03:29:06.000Z</published>
    <updated>2017-09-09T03:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频：<a href="http://www.iqiyi.com/w_19rui7j75p.html" target="_blank" rel="external">为什么要让一条鱼学会爬树</a></p>
<a id="more"></a>
<p>Albert Einstein once said: “Everyone’s a genius，But if you judge a fish on its ability to climb a tree, it will live its whole life believing that it is stupid.”</p>
<p>Ladies and gentlemen of the jury, today on trial we have modern day schooling</p>
<p>Glad you could come. Not only does he make fish climb trees, he also makes them climb down and make them do a 10 mile run</p>
<p>Tell me, school, are you proud of the things you’ve done?Turning millions of people into robots</p>
<p>Do you find that fun?</p>
<p>Do you realize how many children relate to that fish swimming upstream in class believing they are useless?</p>
<p>Well the time has come; no more excuses. I call school the to the stand and accuse him of killing creativity, individuality and being inequality abusive he’s ancient institution has outlived his usage</p>
<p>So, your honor, this concludes my open statement and if I may present the opening of my case I will prove it</p>
<p>Proceed</p>
<p>Exhibit A: here’s a modern day phone; recognize it?<br>Now here’s a phone from 150 years ago<br>Big difference, right?<br>Stay with me, all right<br>Here’s a car today and here’s a car from 150 years ago<br>Big difference right?<br>Well get this: here’s a classroom of today and here’s a classroom we used 150 years ago<br>Now isn’t that a shame<br>In literary over a century, nothing has changed<br>Yet you claim to prepare students for the future<br>But with evidence like that I must ask: do you prepare students for the future, or the past?</p>
<p>I did a background check on you and the records show that you were made to trade people to work in factories, which explains why you put students in straight rows nice and neat. Raise your hand if you want to speak, give them a short break to eat, and for eight hours a day tell them what to think</p>
<p>Oh, and make the compete to get an A a letter that determines a product quality hint grade A of meat</p>
<p>I get it, back then times were different<br>We all have a past; I myself am no Ghandi<br>But today, we don’t need to make robot zombies<br>The world had progressed, and now we need people<br>Who think creatively, innovatively, critically, interdependently, with the ability to connect</p>
<p>You see, every scientist will tell you no two brains are the same<br>And every parents with two or more children will confirm that claim<br>So please explain why you treat students like cookie cutter frames<br>Or snap back caps, giving this one size fits all crap?</p>
<p>Watch your language!</p>
<p>Sorry, your honor</p>
<p>But if a doctor prescribed the exact same medicine to all of his patients</p>
<p>The results would be tragic; so many people would get sick<br>Yet when it comes to school this is exactly what happens. This educational malpractice where one teacher stands in front of 20 children each one having different strengths different needs different gifts different dreams and you teach the same thing the same way.that’s horrific lady gentlemen the defendant the gentlemen should not be acquitted</p>
<p>This may be one of the worst criminal offenses ever to be committed. And let’s mention the way you treat your employees<br>Objection!</p>
<p>Overruled I want to hear this!</p>
<p>It’s a shame I mean teachers have the most important job on the planet yet they are underpaid no wonder why so many students are shortchanged. Let’s be honest teachers should earn just as much as doctors because a doctor can do heart surgery and save the life of a child. But a great teacher can reach the heart of that child and allow him to truly live</p>
<p>You see teachers are heroes that often get blamed. But they aren’t the problem they work in a system with not many options or rights curriculum’s are created by policy makers where most of them haven’t taught a day in their life . Just obsessed with standardized tests they think bubbling in a multiple choice question will determine success</p>
<p>That’s how outlandish in fact these test are to cruel to be used and should be abandoned. But don’t take my word for it. take Fredrick J Keely and man who invented standardized testing who said and I quote “These tests are too crude to be used and should be abandoned” Ladies and gentlemen of the jury if we continue down this road the results will be literal</p>
<p>I don’t have much faith in in school but I do have faith in people. and if we can customize health care, cars and Facebook pages then it is our duty to do the same for education to upgrade change and do way with school spirit. Because that’s uses unless we are working to bring the spirit out of each and every student that should be our task. No more common core instead let’s reach the core of every heart in every class</p>
<p>Sure math is important but no more than art or dance let’s give every gift an equal chance I know this sounds like a dream but countries like Finland are doing impressive things they have shorter days, teachers make a decent wage homework is non existent they focus on collaboration instead of competition. But here’s the kicker boys and girls there educational outperforms every other country in the world. Other places like Singapore are succeeding rapidly schools like Montessori programs like Khan Academy there is no single solution</p>
<p>But let’s get moving because while students maybe 20% of our population</p>
<p>They are 100% of our future so let’s attend to their dreams and there’s no telling what we can achieve this is a world in which I believe a world where fish are no longer forced to climb trees ，I rest my case。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;视频：&lt;a href=&quot;http://www.iqiyi.com/w_19rui7j75p.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为什么要让一条鱼学会爬树&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="http://mingotang.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>数据科学和机器学习领域常用的 Python 库</title>
    <link href="http://mingotang.github.io/2017/09/08/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%92%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A2%86%E5%9F%9F%E5%B8%B8%E7%94%A8%E7%9A%84Python%E5%BA%93/"/>
    <id>http://mingotang.github.io/2017/09/08/数据科学和机器学习领域常用的Python库/</id>
    <published>2017-09-08T08:02:32.000Z</published>
    <updated>2017-09-25T03:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将会针对数据科学介绍几种常用的 Python 包。在与数据挖掘、机器学习以及数据分析相关的项目中，这些 Python 包通常会得到广泛应用。</p>
<a id="more"></a>
<ol>
<li>SciPy</li>
</ol>
<p>SciPy (发音为“Sigh Pie”) 是一个基于 Python 的开源软件生态系统，主要用于数学、科学和工程学等领域，给数据科学家提供了大量的算法和数学工具。</p>
<ol>
<li>NumPy</li>
</ol>
<p>Numpy是用 Pyhton 进行科学计算时的基础包，为 Python 提供了出色的数学功能。</p>
<ol>
<li>Scikit-learn</li>
</ol>
<p>Scikit-learn 是 Python 中最著名的机器学习包，包含了大量不同的分类方法、交叉检验及其他模型选择方法、降维技术、回归和聚类分析的模块以及非常实用的数据预处理的模块。</p>
<ol>
<li>Pandas</li>
</ol>
<p>Pandas 是一个用于处理具有类表格结构数据的库，通常与强大的数据框对象一起使用。DataFrame 是高效处理数据的多维数组对象，类似 Numpy 的 narray ，同时也有些附加的功能。</p>
<ol>
<li>IPython</li>
</ol>
<p>IPython 是一个命令行shell，相对于自带的 Python 解释器，具有很多有用的增强功能。</p>
<p>IPython Notebooks  对于科学计算来说是个不错的环境：不仅仅可以执行代码，同时也能通过 Markdown 、 HTML 、 LaTeX 、内置图片、内置数据图表（例如 matplotlib 等）增加信息化文件，还能为并行计算提供高性能的工具。</p>
<ol>
<li>Requests</li>
</ol>
<p>Requests 是 Python 中为人们搭建的优雅而简单的 HTTP 库。作为一名数据科学家，你或许需要从网上采集数据，而Requests 则为你提供了强大的工具。</p>
<ol>
<li>Scrapy</li>
</ol>
<p>Scrapy 是从互联网上采集数据的开源和协同框架，使用了快速、简单并且可扩展的方式。</p>
<ol>
<li>Statsmodels</li>
</ol>
<p>用户可以通过 Statsmodels 这个 Python 模块去挖掘数据、搭建预测统计模型和进行统计检验。它是个可扩展的列表，用来描述数据、统计检验、绘图以及为不同类型的数据和每一种预测提供统计结果。</p>
<ol>
<li>Theano</li>
</ol>
<p>如果从事深度学习项目，通常会需要 theano 。你可以用它这个 Python 库去定义、优化、高效评估包括多维数组在内的数学表达式。</p>
<ol>
<li>gensim</li>
</ol>
<p>genism 是最稳健、高效和省事的软件之一，通过纯文本实现无监督的语义建模，可以很容易地训练主题模型。如果想要在文本数据中应用主题模型，那你应该去试试 genism。</p>
<ol>
<li>SymPy</li>
</ol>
<p>SymPy 是进行符号数学计算的 Python 库，拥有大量的特征，包括微积分、代数、几何学、离散数学，甚至还有量子物理学。同时在 LaTeX 的支持下具备基础绘图和输出功能。</p>
<ol>
<li>PyMC</li>
</ol>
<p>PyMC 的核心是贝叶斯统计和模型拟合的大量算法（包括Markov Chain Monte Carlo, MCMC）。</p>
<ol>
<li>matplotlib</li>
</ol>
<p>matplotlib 是 python 的平面绘图库，能以硬拷贝格式和跨平台交互环境的多种形式输出高质量的图形，对于任何数据科学家或数据分析师来说都是必备的。</p>
<ol>
<li>BeautifulSoup</li>
</ol>
<p>如果想要提取些数据出来，那么 BeautifulSoup 正是你所需要的，可以用它在网页中提取内容。</p>
<ol>
<li>nltk</li>
</ol>
<p>Natural Language Toolkit (NLTK) 是使用人类语言数据搭建 Python 项目的领先平台。如果你在从事 NLP 相关的项目，那么 NLTK 是个必备工具。</p>
<ol>
<li>sqlite3</li>
</ol>
<p>这个工具能帮助你轻而易举地存储数据。它为 Python 连接 SQLite 数据库提供了接口。搭建开源的 SQL 数据库引擎对于小团队来说是个理想的选择，因为它是独立的本地存储数据库文件（最多140Tb），不像SQL那样，它不需要任何服务器基本结构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章将会针对数据科学介绍几种常用的 Python 包。在与数据挖掘、机器学习以及数据分析相关的项目中，这些 Python 包通常会得到广泛应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="COLLECTION" scheme="http://mingotang.github.io/tags/COLLECTION/"/>
    
  </entry>
  
  <entry>
    <title>Git Cheat Sheet</title>
    <link href="http://mingotang.github.io/2017/09/07/Git-Cheat-Sheet/"/>
    <id>http://mingotang.github.io/2017/09/07/Git-Cheat-Sheet/</id>
    <published>2017-09-07T15:00:21.000Z</published>
    <updated>2017-09-28T08:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="Git-本地更改操作"><a href="#Git-本地更改操作" class="headerlink" title="Git 本地更改操作"></a>Git 本地更改操作</h2><h3 id="GIT-HELP"><a href="#GIT-HELP" class="headerlink" title="GIT HELP"></a>GIT HELP</h3><pre><code>$ git help
usage: git [--version] [--help] [-C &lt;path&gt;] [-c name=value]
       [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]
       [-p | --paginate | --no-pager] [--no-replace-objects] [--bare]
       [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]
       &lt;command&gt; [&lt;args&gt;]


$ git help config
    git-config ** Get and set repository or global options
</code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li>初始化一个 Git 仓库：<code>git init</code></li>
</ul>
<h3 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h3><ul>
<li>添加文件到暂存区：<code>git add &lt;file&gt;</code><ul>
<li>添加所有修改到暂存区：<code>git add .</code></li>
</ul>
</li>
<li>将暂存区的修改提交到版本库：<code>git commit</code> -&gt; 编辑 commit message -&gt; 保存<ul>
<li>commit message 较简单时，可以：<code>git commit -m &quot;&lt;message&gt;&quot;</code></li>
</ul>
</li>
<li>为文件添加执行权限，并将修改添加到暂存区：<code>git update-index --chmod=+x &lt;file&gt;</code></li>
</ul>
<p>Commit changes  ** A snapshot of those on the stage</p>
<pre><code>$ git status    ** To check what&apos;s changed since last commit

$ git add README.txt

$ git add --all

$ git add &lt;list of files&gt;

$ git add docs/

$ git commit -m &quot;Create a README.&quot;  ** Commit message, what work was done?

$ git log   ** get timeline history
</code></pre><h3 id="回退修改"><a href="#回退修改" class="headerlink" title="回退修改"></a>回退修改</h3><ul>
<li>回退工作区的修改：<code>git checkout -- &lt;file&gt;</code></li>
<li>回退工作区的修改，但保存现场：<code>git stash</code><ul>
<li>恢复现场：<code>git stash pop</code></li>
<li>查看保存的现场：<code>git stash list</code></li>
</ul>
</li>
<li>回退暂存区的修改到工作区：<code>git reset HEAD &lt;file&gt;</code></li>
<li>回退版本库的修改到工作区：<code>git reset &lt;commit&gt;</code> 或 <code>git reset –-mixed &lt;commit&gt;</code></li>
<li>回退版本库的修改到暂存区：<code>git reset –-soft &lt;commit&gt;</code></li>
<li>回退版本库的修改（<strong>不保留</strong>）：<code>git reset --hard &lt;commit&gt;</code><ul>
<li>如果错误执行了该回退操作，可以通过 <code>git reflog</code> 查看命令历史，命令历史中记载了回退前的 commit id，可以执行 <code>git reset --hard &lt;commit&gt;</code> 回退该回退操作</li>
</ul>
</li>
<li>回退所有未被跟踪的文件：<code>git clean -df</code></li>
</ul>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul>
<li>从暂存区 + 工作区中删除：<code>git rm &lt;file&gt;</code></li>
<li>从暂存区中删除：<code>git rm --cached &lt;file&gt;</code></li>
</ul>
<h3 id="跟踪文件"><a href="#跟踪文件" class="headerlink" title="跟踪文件"></a>跟踪文件</h3><ul>
<li>强制跟踪指定文件：<code>git update-index --no-assume-unchanged &lt;file&gt;</code></li>
<li>强制不跟踪指定文件：<code>git update-index --assume-unchanged &lt;file&gt;</code></li>
</ul>
<h2 id="Git-比较操作"><a href="#Git-比较操作" class="headerlink" title="Git 比较操作"></a>Git 比较操作</h2><ul>
<li>比较工作区和暂存区的指定文件：<code>git diff &lt;path&gt;</code><ul>
<li>比较所有文件：<code>git diff</code></li>
</ul>
</li>
<li>比较工作区和指定 commit 的指定文件：<code>git diff &lt;commit&gt; &lt;path&gt;</code><ul>
<li>比较所有文件：<code>git diff &lt;commit&gt;</code></li>
</ul>
</li>
<li>比较暂存区和指定 commit 的指定文件：<code>git diff --cached &lt;commit&gt; &lt;path&gt;</code><ul>
<li>比较暂存区和 <code>HEAD</code> 的指定文件：<code>git diff --cached &lt;path&gt;</code></li>
<li>比较所有文件：<code>git diff --cached &lt;commit&gt;</code></li>
</ul>
</li>
<li>比较 commit <code>A</code> 和 commit <code>B</code> 的指定文件：<code>git diff &lt;A&gt; &lt;B&gt; &lt;path&gt;</code><ul>
<li>比较 <code>HEAD</code> 和 commit <code>B</code> 的指定文件：<code>git diff ..&lt;B&gt; &lt;path&gt;</code></li>
<li>比较 commit <code>A</code> 和 <code>HEAD</code> 的指定文件：<code>git diff &lt;A&gt;.. &lt;path&gt;</code></li>
</ul>
</li>
<li>比较 commit <code>A</code> 与 commit <code>B</code> 的 merge base 和 commit <code>B</code> 的指定文件：<code>git diff &lt;A&gt;...&lt;B&gt; &lt;path&gt;</code><ul>
<li>比较 <code>HEAD</code> 与 commit <code>B</code> 的 merge base 和 commit <code>B</code> 的指定文件：<code>git diff ...&lt;B&gt; &lt;path&gt;</code></li>
<li>比较 commit <code>A</code> 与 <code>HEAD</code> 的 merge base 和 <code>HEAD</code> 的指定文件：<code>git diff &lt;A&gt;... &lt;path&gt;</code></li>
</ul>
</li>
<li><p>使用 difftool 比较文件，命令参数与 <code>git diff</code> 一致，但使用 <code>git difftool</code> 子命令</p>
<ul>
<li><p>配置 difftool：</p>
<p>  编辑 <code>~/.gitconfig</code>：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[diff]</div><div class="line">	tool = meld</div><div class="line">[difftool &quot;meld&quot;]</div><div class="line">	path = C:\\path\\to\\meld\\Meld.exe</div></pre></td></tr></table></figure>
<p>$ git diff  ** No difference since all changes are staged</p>
<p>$ git diff –staged     ** View staged difference</p>
<p>$ git reset HEAD <file>    ** unstage</file></p>
<p>$ git checkout – <file>    ** Blow away all changes since last commit</file></p>
<p>$ git commit -a -m “message”    ** Add changes from all tracked files</p>
<p>$ git reset –soft HEAD^    ** Reset into staging, move to commit before ‘HEAD’</p>
<p>$ git commit –amend -m “new message”   ** amend last commit</p>
<p>$ git reset –hard HEAD^    ** Reset to last commit, undo all changes</p>
<p>$ git reset –hard HEAD^^    ** Reset to last 2 commit, undo all changes</p>
</li>
</ul>
</li>
</ul>
<h2 id="Git-历史操作"><a href="#Git-历史操作" class="headerlink" title="Git 历史操作"></a>Git 历史操作</h2><ul>
<li>查看分支合并图：<code>git log --graph</code></li>
<li><p>配置 <code>git lg</code> 作为查看格式良好的历史记录的命令：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[alias]</div><div class="line">	lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Git-分支操作"><a href="#Git-分支操作" class="headerlink" title="Git 分支操作"></a>Git 分支操作</h2><ul>
<li>查看当前分支：<code>git branch</code></li>
<li>基于当前分支创建新分支：<code>git branch &lt;name&gt;</code><ul>
<li>基于当前分支创建并切换到新分支：<code>git checkout -b &lt;name&gt;</code></li>
<li>基于指定分支创建并切换到新分支：<code>git checkout -b &lt;name&gt; &lt;origin-branch&gt;</code></li>
</ul>
</li>
<li>切换到指定分支：<code>git checkout &lt;name&gt;</code></li>
<li><p>合并指定分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<ul>
<li><p>合并时在指定分支基础上重新提交当前分支从 merge base 开始的 commit：<code>git rebase -i &lt;name&gt;</code></p>
<ul>
<li>rebase 时历史会从旧到新显示，编辑历史时有如下 command 可用：<ul>
<li><code>pick</code>：直接入库</li>
<li><code>edit</code>：在入库前允许重新编辑 commit</li>
<li><code>reword</code>：在入库前允许重新编辑 commit message</li>
<li><code>squash</code>：与前次提交进行 commit 合并</li>
<li><code>fixup</code>：同 <code>squash</code>，但丢弃 commit message</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li><p>原始 log 如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">debug: commit1</div><div class="line">debug: commit2</div><div class="line">debug: commit3</div><div class="line">fix: commit4</div></pre></td></tr></table></figure>
</li>
<li><p>使用以下 command：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pick debug: commit1</div><div class="line">fixup debug: commit2</div><div class="line">fixup debug: commit3</div><div class="line">squash fix: commit4</div></pre></td></tr></table></figure>
</li>
<li><p>结果：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fix: commit4</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>继续检查下个 commit：<code>git rebase --continue</code></p>
</li>
<li>取消本次 rebase：<code>git rebase --abort</code></li>
</ul>
</li>
<li><p>使用指定工具进行 merge 操作：<code>git mergetool</code></p>
<ul>
<li><p>配置 merge 工具：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[merge]</div><div class="line">	tool = meld</div><div class="line">[mergetool &quot;meld&quot;]</div><div class="line">	path = C:\\path\\to\\meld\\Meld.exe</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>删除指定分支：<code>git branch -d &lt;name&gt;</code></p>
<ul>
<li>删除未合并分支：<code>git branch -D &lt;name&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="Git-远程仓库操作"><a href="#Git-远程仓库操作" class="headerlink" title="Git 远程仓库操作"></a>Git 远程仓库操作</h2><ul>
<li>克隆远程仓库到当前目录：<code>git clone &lt;repo-url&gt;</code><ul>
<li>克隆远程仓库到指定目录：<code>git clone &lt;repo-url&gt; &lt;dir&gt;</code><ul>
<li><code>&lt;dir&gt;</code> 目录下会出现 <code>.git</code> 目录</li>
</ul>
</li>
</ul>
</li>
<li>关联远程仓库：<code>git remote add &lt;repo-name&gt; &lt;repo-url&gt;</code><ul>
<li><code>&lt;repo-name&gt;</code> 惯例命名为 <code>origin</code></li>
<li><code>&lt;repo-url&gt;</code> 一般格式为 <code>git@server-name:path/repo-name.git</code></li>
</ul>
</li>
<li>查看远程仓库信息：<code>git remote -v</code></li>
<li>拖取指定远程仓库：<code>git fetch &lt;repo-name&gt;</code></li>
<li>拖取指定远程仓库的指定分支然后合并到当前分支：<code>git pull &lt;repo-name&gt; &lt;branch-name&gt;</code></li>
<li>推送指定分支到指定远程仓库：<code>git push &lt;repo-name&gt; &lt;branch-name&gt;</code><ul>
<li>推送当前分支到指定远程仓库：<code>git push &lt;repo-name&gt;</code></li>
<li>推送当前分支到上游仓库：<code>git push</code><ul>
<li>要配置指定远程仓库为上游仓库，可以：<ul>
<li>在第一次推送时使用 <code>-u</code> 指定：<code>git push -u &lt;repo-name&gt; &lt;branch-name&gt;</code></li>
<li>直接配置：<code>git branch --set-upstream &lt;branch-name&gt; &lt;repo-name&gt;/&lt;branch-name&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>删除指定远程仓库的指定分支：<code>git push &lt;repo-name&gt; :&lt;branch-name&gt;</code><ul>
<li>如果由于远程仓库的 <code>HEAD</code> 指向待删除的分支而无法进行删除操作，可以先把 <code>HEAD</code> 指向其他分支，在远程仓库上进行以下操作：<code>git symbolic-ref HEAD refs/heads/&lt;other-branch-name&gt;</code>，在删除分支后再切换回来</li>
</ul>
</li>
</ul>
<pre><code>$ git remote add name_for_remote https://github.com/Gregg/git-real.git

$ git remote -v     ** show remote repo

$ git push -u name_for_remote local_branch_to_push

$ git pull

$ git remote add &lt;name&gt; &lt;address&gt;

$ git remote rm &lt;name&gt;

$ git push -u &lt;name&gt; &lt;branch&gt;
</code></pre><h2 id="Git-标签操作"><a href="#Git-标签操作" class="headerlink" title="Git 标签操作"></a>Git 标签操作</h2><ul>
<li>基于 <code>HEAD</code> 新建标签：<code>git tag &lt;name&gt;</code><ul>
<li>基于指定 commit 新建标签：<code>git tag &lt;name&gt; &lt;commit&gt;</code></li>
<li>指定标签信息：<code>git tag -m &lt;message&gt; &lt;name&gt;</code></li>
<li>使用PGP签名标签：<code>git tag -s &lt;name&gt;</code></li>
</ul>
</li>
<li>查看标签：<code>git tag</code></li>
<li>推送指定标签到指定远程仓库：<code>git push &lt;repo-name&gt; &lt;tag-name&gt;</code><ul>
<li>推送全部标签到指定远程仓库：<code>git push &lt;repo-name&gt; --tags</code></li>
</ul>
</li>
<li>在指定远程仓库删除指定标签：<code>git push &lt;repo-name&gt; :refs/tags/&lt;tag-name&gt;</code></li>
</ul>
<pre><code>$ git tag   ** list all tags

$ git checkout v0.0.1   ** check out code at commit

$ git tag -a v0.0.3 -m &quot;version 0.0.3&quot;    ** add a new tag

$ git push --tags
</code></pre><h2 id="Git-子模块操作"><a href="#Git-子模块操作" class="headerlink" title="Git 子模块操作"></a>Git 子模块操作</h2><ul>
<li>添加 submodule：<code>git submodule add -b &lt;branch&gt; --name &lt;name&gt; &lt;repo&gt; &lt;path&gt;</code></li>
<li>查看 submodule 状态：<code>git submodule status</code></li>
<li><p>clone 含 submodule 的项目</p>
<ul>
<li>方法一：<code>git clone &lt;repo&gt; --recursive</code></li>
<li><p>方法二：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> &lt;repo&gt;</div><div class="line">git submodule update --init --recursive</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>删除 submodule：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git deinit &lt;path&gt;</div><div class="line">git rm --cached &lt;path&gt;</div><div class="line">rm -rf &lt;path&gt;</div><div class="line">[edit .gitmodules to remove submodule item]</div></pre></td></tr></table></figure>
</li>
<li><p>在 submodule 中执行命令：<code>git submodule foreach &lt;command&gt;</code></p>
</li>
<li>更新 submodule：<code>git submodule update --recursive --remote</code></li>
</ul>
<h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><ul>
<li><p>配置 committer：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &lt;user-name&gt;</div><div class="line">git config --global user.email &lt;user-email&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>让命令行输出显示颜色：<code>git config --global color.ui true</code></p>
</li>
<li>让 non-bare repo 能被 push：<code>git config receive.denyCurrentBranch updateInstead</code></li>
<li>让 Git 不要自动转换 CRLF：<code>git config --global core.autocrlf false</code></li>
<li>让 Git 忽视文件的 mode 变化：<code>git config --global core.fileMode false</code></li>
<li><p>为复杂操作配置别名：</p>
<ul>
<li><p>示例：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[alias]</div><div class="line">	sy = &quot;!f() &#123; git status; git add .; git commit; git push origin-test $&#123;1&#125;; &#125;; f&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>配置 Git 的自动补全和命令行 prompt：</p>
<p>  在 <code>~/.bashrc</code> 中加入如下配置：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> <span class="variable">$&#123;GIT_SOURCE_DIR&#125;</span>/contrib/completion/git-completion.bash</div><div class="line"><span class="built_in">source</span> <span class="variable">$&#123;GIT_SOURCE_DIR&#125;</span>/contrib/completion/git-prompt.sh</div><div class="line"></div><div class="line"><span class="keyword">function</span> color_my_prompt &#123;</div><div class="line">    <span class="built_in">local</span> __user_and_host=<span class="string">"\[\033[01;32m\]\u@\h"</span></div><div class="line">    <span class="built_in">local</span> __cur_location=<span class="string">"\[\033[01;34m\]\w"</span></div><div class="line">    <span class="built_in">local</span> __git_branch_color=<span class="string">"\[\033[31m\]"</span></div><div class="line">    <span class="built_in">local</span> __git_branch=<span class="string">'`git branch 2&gt; /dev/null | grep -e ^* | sed -E  s/^\\\\\*\ \(.+\)$/\(\\\\\1\)\ /`'</span></div><div class="line">    <span class="built_in">local</span> __prompt_tail=<span class="string">"\[\033[35m\]$"</span></div><div class="line">    <span class="built_in">local</span> __last_color=<span class="string">"\[\033[00m\]"</span></div><div class="line">    <span class="built_in">export</span> PS1=<span class="string">"<span class="variable">$__user_and_host</span> <span class="variable">$__cur_location</span> <span class="variable">$__git_branch_color</span><span class="variable">$__git_branch</span><span class="variable">$__prompt_tail</span><span class="variable">$__last_color</span> "</span></div><div class="line">&#125;</div><div class="line">color_my_prompt</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="REBASE"><a href="#REBASE" class="headerlink" title="REBASE"></a>REBASE</h3><ul>
<li>Move all changes to master which are not in origin/master to a temporary area.</li>
<li>Run all origin/master commits.</li>
<li>Run all commits in the temporary area, one at a time.</li>
</ul>
<pre><code>$ git rebase --continue

$ git rebase --skip

$ git rebase --abort
$ git fetch     ** Syncs, but doesn&apos;t merge

$ git rebase &lt;branch&gt;
</code></pre><h3 id="HISTORY"><a href="#HISTORY" class="headerlink" title="HISTORY"></a>HISTORY</h3><p>LOG</p>
<pre><code>$ git config --global color.ui true       ** set log colorful to read

$ git log --pretty=oneline

$ git log --pretty=format:&quot;%h %ad- %s [%an]&quot;

$ git log --oneline -p     ** To see lines added and deleted

$ git log --oneline -stat       ** To see how many lines changed

$ git log --oneline -graph

$ git log --until=1.minute.ago

$ git log --since=1.day.ago

$ git log --since=1.hour.ago

$ git log --since=1.month.ago --until=2.weeks.ago

$ git log --since=2000-01-01 --until=2012-12-21

$ git diff

$ git diff HEAD/HEAD^/HEAD^^/HEAD~5

$ git diff HEAD^..HEAD

$ git diff &lt;branch&gt; &lt;branch&gt;

$ git blame index.html --date short
</code></pre><h3 id="Excluding"><a href="#Excluding" class="headerlink" title="Excluding"></a>Excluding</h3><p>.gitignore</p>
<pre><code>$ git rm README.txt           ** delete the file

$ git rm --cached development.log     ** stop tracking but do not delete
</code></pre><h3 id="CONFIG"><a href="#CONFIG" class="headerlink" title="CONFIG"></a>CONFIG</h3><pre><code>$ git config --global user.name &quot;Gregg Pollack&quot;

$ git config --global user.email &quot;gregg@codeschool.com&quot;

$ git config --global core.editor emacs     ** use emacs for interactive commands

$ git config --global merge.tool opendiff    ** use opendiff for merging conflicts

$ git config user.email &quot;spamme@example.com&quot;     ** sets email for current repo

$ git config --list
</code></pre><h2 id="豆知识"><a href="#豆知识" class="headerlink" title="豆知识"></a>豆知识</h2><h3 id="commit-别名"><a href="#commit-别名" class="headerlink" title="commit 别名"></a>commit 别名</h3><p>在 Git 中，<code>HEAD</code> 表示当前版本，也就是最新的提交，上一个版本就是 <code>HEAD^</code>，上上一个版本就是 <code>HEAD^^</code>，上100个版本写成 <code>HEAD~100</code>。</p>
<h3 id="dry-run"><a href="#dry-run" class="headerlink" title="dry run"></a>dry run</h3><p>很多命令都有 <code>-n</code> 或 <code>--dry-run</code> 选项，使用了该选项后，命令不会直接运行，而是输出它将执行的内容，供用户判断执行的内容是否和预期一致，从而决定是否实际执行该命令。这避免了一些手误的情况，在某些重要的操作上很有用。</p>
<h3 id=""><a href="#" class="headerlink" title="--"></a><code>--</code></h3><p>Git 的命令中常含有 <code>--</code>，它用来分割 Git 命令的选项和文件/文件列表，以防某些文件名被误认为是选项。</p>
<h3 id="在-Windows-下启动-Git-server"><a href="#在-Windows-下启动-Git-server" class="headerlink" title="在 Windows 下启动 Git server"></a>在 Windows 下启动 Git server</h3><p>将指定目录下所有的仓库都通过 Git server 暴露给其他人：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git daemon --base-path=/path/to/workplace --<span class="built_in">export</span>-all</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Git-本地更改操作&quot;&gt;&lt;a href=&quot;#Git-本地更改操作&quot; class=&quot;headerlink&quot; title=&quot;Git 本地更改操作&quot;&gt;&lt;/a&gt;Git 本地更改操作&lt;/h2&gt;&lt;h3 id=&quot;GIT-HELP&quot;&gt;&lt;a hr
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>33款开源爬虫软件工具</title>
    <link href="http://mingotang.github.io/2017/09/07/33%E6%AC%BE%E5%BC%80%E6%BA%90%E7%88%AC%E8%99%AB%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"/>
    <id>http://mingotang.github.io/2017/09/07/33款开源爬虫软件工具/</id>
    <published>2017-09-07T13:53:19.000Z</published>
    <updated>2017-09-25T03:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文对较为知名及常见的开源爬虫软件进行梳理，按开发语言进行汇总。虽然搜索引擎也有爬虫，但这里只是爬虫软件，而非大型、复杂的搜索引擎。</p>
<a id="more"></a>
<h2 id="Java爬虫"><a href="#Java爬虫" class="headerlink" title="Java爬虫"></a>Java爬虫</h2><hr>
<h3 id="1、Arachnid"><a href="#1、Arachnid" class="headerlink" title="1、Arachnid"></a>1、Arachnid</h3><p>Arachnid是一个基于Java的web spider框架.它包含一个简单的HTML剖析器能够分析包含HTML内容的输入流.通过实现Arachnid的子类就能够开发一个简单的Web spiders并能够在Web站上的每个页面被解析之后增加几行代码调用。 Arachnid的下载包中包含两个spider应用程序例子用于演示如何使用该框架。</p>
<ul>
<li><p>特点：微型爬虫框架，含有一个小型HTML解析器</p>
</li>
<li><p>许可证：GPL</p>
</li>
</ul>
<h3 id="2、crawlzilla"><a href="#2、crawlzilla" class="headerlink" title="2、crawlzilla"></a>2、crawlzilla</h3><p>crawlzilla 是一个帮你轻松建立搜索引擎的自由软件，有了它，你就不用依靠商业公司的搜索引擎，也不用再烦恼公司內部网站资料索引的问题。</p>
<p>由 nutch 专案为核心，并整合更多相关套件，并卡发设计安装与管理UI，让使用者更方便上手。</p>
<p>crawlzilla 除了爬取基本的 html 外，还能分析网页上的文件，如（ doc、pdf、ppt、ooo、rss ）等多种文件格式，让你的搜索引擎不只是网页搜索引擎，而是网站的完整资料索引库。</p>
<p>拥有中文分词能力，让你的搜索更精准。</p>
<p>crawlzilla的特色与目标，最主要就是提供使用者一个方便好用易安裝的搜索平台。</p>
<ul>
<li>授权协议： Apache License 2</li>
<li>开发语言： Java JavaScript SHELL</li>
<li>操作系统： Linux</li>
<li>项目主页： <a href="https://github.com/shunfa/crawlzilla" target="_blank" rel="external">https://github.com/shunfa/crawlzilla</a></li>
<li>下载地址： <a href="http://sourceforge.net/projects/crawlzilla/" target="_blank" rel="external">http://sourceforge.net/projects/crawlzilla/</a></li>
</ul>
<blockquote>
<p>特点：安装简易，拥有中文分词功能</p>
</blockquote>
<h3 id="3、Ex-Crawler"><a href="#3、Ex-Crawler" class="headerlink" title="3、Ex-Crawler"></a>3、Ex-Crawler</h3><p>Ex-Crawler 是一个网页爬虫，采用 Java 开发，该项目分成两部分，一个是守护进程，另外一个是灵活可配置的 Web 爬虫。使用数据库存储网页信息。</p>
<ul>
<li>授权协议： GPLv3</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：由守护进程执行，使用数据库存储网页信息</p>
</blockquote>
<h3 id="4、Heritrix"><a href="#4、Heritrix" class="headerlink" title="4、Heritrix"></a>4、Heritrix</h3><p>Heritrix 是一个由 java 开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。</p>
<p>Heritrix采用的是模块化的设计，各个模块由一个控制器类（CrawlController类）来协调，控制器是整体的核心。</p>
<ul>
<li>代码托管：<a href="https://github.com/internetarchive/heritrix3" target="_blank" rel="external">https://github.com/internetarchive/heritrix3</a></li>
<li>授权协议： Apache</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：严格遵照robots文件的排除指示和META robots标签</p>
</blockquote>
<h3 id="5、heyDr"><a href="#5、heyDr" class="headerlink" title="5、heyDr"></a>5、heyDr</h3><p>heyDr是一款基于java的轻量级开源多线程垂直检索爬虫框架，遵循GNU GPL V3协议。</p>
<p>用户可以通过heyDr构建自己的垂直资源爬虫，用于搭建垂直搜索引擎前期的数据准备。</p>
<ul>
<li>授权协议： GPLv3</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：轻量级开源多线程垂直检索爬虫框架</p>
</blockquote>
<h3 id="6、ItSucks"><a href="#6、ItSucks" class="headerlink" title="6、ItSucks"></a>6、ItSucks</h3><p>ItSucks是一个java web spider（web机器人，爬虫）开源项目。支持通过下载模板和正则表达式来定义下载规则。提供一个swing GUI操作界面。</p>
<blockquote>
<p>特点：提供swing GUI操作界面</p>
</blockquote>
<h3 id="7、jcrawl"><a href="#7、jcrawl" class="headerlink" title="7、jcrawl"></a>7、jcrawl</h3><p>jcrawl是一款小巧性能优良的的web爬虫,它可以从网页抓取各种类型的文件,基于用户定义的符号,比如email,qq.</p>
<ul>
<li>授权协议： Apache</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：轻量、性能优良，可以从网页抓取各种类型的文件</p>
</blockquote>
<h3 id="8、JSpider"><a href="#8、JSpider" class="headerlink" title="8、JSpider"></a>8、JSpider</h3><p>JSpider是一个用Java实现的WebSpider，JSpider的执行格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jspider [URL] [ConfigName]</div></pre></td></tr></table></figure></p>
<p>URL一定要加上协议名称，如：<a href="http://，否则会报错。如果省掉ConfigName，则采用默认配置。" target="_blank" rel="external">http://，否则会报错。如果省掉ConfigName，则采用默认配置。</a></p>
<p>JSpider 的行为是由配置文件具体配置的，比如采用什么插件，结果存储方式等等都在conf[ConfigName]\目录下设置。JSpider默认的配置种类 很少，用途也不大。但是JSpider非常容易扩展，可以利用它开发强大的网页抓取与数据分析工具。要做到这些，需要对JSpider的原理有深入的了 解，然后根据自己的需求开发插件，撰写配置文件。</p>
<ul>
<li>授权协议： LGPL</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：功能强大，容易扩展</p>
</blockquote>
<h3 id="9、Leopdo"><a href="#9、Leopdo" class="headerlink" title="9、Leopdo"></a>9、Leopdo</h3><p>用JAVA编写的web 搜索和爬虫，包括全文和分类垂直搜索，以及分词系统</p>
<ul>
<li>授权协议： Apache</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：包括全文和分类垂直搜索，以及分词系统</p>
</blockquote>
<h3 id="10、MetaSeeker"><a href="#10、MetaSeeker" class="headerlink" title="10、MetaSeeker"></a>10、MetaSeeker</h3><p>是一套完整的网页内容抓取、格式化、数据集成、存储管理和搜索解决方案。</p>
<p>网络爬虫有多种实现方法，如果按照部署在哪里分，可以分成：</p>
<ul>
<li><p>1，服务器侧：一般是一个多线程程序，同时下载多个目标HTML，可以用PHP， Java, Python(当前很流行）等做，可以速度做得很快，一般综合搜索引擎的爬虫这样做。但是，如果对方讨厌爬虫，很可能封掉你的IP，服务器IP又不容易 改，另外耗用的带宽也是挺贵的。建议看一下Beautiful soap。</p>
</li>
<li><p>2，客户端：一般实现定题爬虫，或者是聚焦爬虫，做综合搜索引擎不容易成功，而垂直搜诉或者比价服务或者推荐引擎，相对容易很多，这类爬虫不是什么页面都 取的，而是只取你关系的页面，而且只取页面上关心的内容，例如提取黄页信息，商品价格信息，还有提取竞争对手广告信息的，搜一下Spyfu，很有趣。这类 爬虫可以部署很多，而且可以很有侵略性，对方很难封锁。</p>
</li>
</ul>
<p>MetaSeeker中的网络爬虫就属于后者。</p>
<p>MetaSeeker工具包利用Mozilla平台的能力，只要是Firefox看到的东西，它都能提取。</p>
<p>MetaSeeker工具包是免费使用的，下载地址：www.gooseeker.com/cn/node/download/front</p>
<blockquote>
<p>特点：网页抓取、信息提取、数据抽取工具包，操作简单</p>
</blockquote>
<h3 id="11、Playfish"><a href="#11、Playfish" class="headerlink" title="11、Playfish"></a>11、Playfish</h3><p>playfish是一个采用java技术，综合应用多个开源java组件实现的网页抓取工具，通过XML配置文件实现高度可定制性与可扩展性的网页抓取工具</p>
<p>应用开源jar包包括httpclient(内容读取),dom4j（配置文件解析）,jericho（html解析），已经在 war包的lib下。</p>
<p>这个项目目前还很不成熟，但是功能基本都完成了。要求使用者熟悉XML，熟悉正则表达式。目前通过这个工具可以抓取各类论坛，贴吧，以及各类CMS系统。像Discuz!,phpbb,论坛跟博客的文章，通过本工具都可以轻松抓取。抓取定义完全采用XML，适合Java开发人员使用。</p>
<p>使用方法:</p>
<ul>
<li>1.下载右边的.war包导入到eclipse中，</li>
<li>2.使用WebContent/sql下的wcc.sql文件建立一个范例数据库，</li>
<li>3.修改src包下wcc.core的dbConfig.txt，将用户名与密码设置成你自己的mysql用户名密码。</li>
<li>4.然后运行SystemCore,运行时候会在控制台，无参数会执行默认的example.xml的配置文件，带参数时候名称为配置文件名。</li>
</ul>
<p>系统自带了3个例子，分别为baidu.xml抓取百度知道，example.xml抓取我的javaeye的博客，bbs.xml抓取一个采用 discuz论坛的内容。</p>
<ul>
<li>授权协议： MIT</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：通过XML配置文件实现高度可定制性与可扩展性</p>
</blockquote>
<h3 id="12、Spiderman"><a href="#12、Spiderman" class="headerlink" title="12、Spiderman"></a>12、Spiderman</h3><p>Spiderman 是一个基于微内核+插件式架构的网络蜘蛛，它的目标是通过简单的方法就能将复杂的目标网页信息抓取并解析为自己所需要的业务数据。</p>
<p>怎么使用？</p>
<ul>
<li>首先，确定好你的目标网站以及目标网页（即某一类你想要获取数据的网页，例如网易新闻的新闻页面）</li>
<li>然后，打开目标页面，分析页面的HTML结构，得到你想要数据的XPath，具体XPath怎么获取请看下文。</li>
<li>最后，在一个xml配置文件里填写好参数，运行Spiderman吧！</li>
</ul>
<ul>
<li>授权协议： Apache</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：灵活、扩展性强，微内核+插件式架构，通过简单的配置就可以完成数据抓取，无需编写一句代码</p>
</blockquote>
<h3 id="13、webmagic"><a href="#13、webmagic" class="headerlink" title="13、webmagic"></a>13、webmagic</h3><p>webmagic的是一个无须配置、便于二次开发的爬虫框架，它提供简单灵活的API，只需少量代码即可实现一个爬虫。</p>
<p>webmagic采用完全模块化的设计，功能覆盖整个爬虫的生命周期(链接提取、页面下载、内容抽取、持久化)，支持多线程抓取，分布式抓取，并支持自动重试、自定义UA/cookie等功能。</p>
<p>webmagic包含强大的页面抽取功能，开发者可以便捷的使用css selector、xpath和正则表达式进行链接和内容的提取，支持多个选择器链式调用。</p>
<ul>
<li>webmagic的使用文档：<a href="http://webmagic.io/docs/" target="_blank" rel="external">http://webmagic.io/docs/</a></li>
<li>查看源代码：<a href="http://git.oschina.net/flashsword20/webmagic" target="_blank" rel="external">http://git.oschina.net/flashsword20/webmagic</a></li>
<li>授权协议： Apache</li>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：功能覆盖整个爬虫生命周期，使用Xpath和正则表达式进行链接和内容的提取。</p>
</blockquote>
<p><em>备注：这是一款国产开源软件，由 黄亿华贡献</em></p>
<h3 id="14、Web-Harvest"><a href="#14、Web-Harvest" class="headerlink" title="14、Web-Harvest"></a>14、Web-Harvest</h3><p>Web-Harvest是一个Java开源Web数据抽取工具。它能够收集指定的Web页面并从这些页面中提取有用的数据。Web-Harvest主要是运用了像XSLT,XQuery,正则表达式等这些技术来实现对text/xml的操作。</p>
<p>其实现原理是，根据预先定义的配置文件用httpclient获取页面的全部内容（关于httpclient的内容，本博有些文章已介绍），然后运用XPath、XQuery、正则表达式等这些技术来实现对text/xml的内容筛选操作，选取精确的数据。前两年比较火的垂直搜索（比如：酷讯等）也是采用类似的原理实现的。Web-Harvest应用，关键就是理解和定义配置文件，其他的就是考虑怎么处理数据的Java代码。当然在爬虫开始前，也可以把Java变量填充到配置文件中，实现动态的配置。</p>
<ul>
<li>授权协议： BSD</li>
<li>开发语言： Java</li>
</ul>
<blockquote>
<p>特点：运用XSLT、XQuery、正则表达式等技术来实现对Text或XML的操作，具有可视化的界面</p>
</blockquote>
<h3 id="15、WebSPHINX"><a href="#15、WebSPHINX" class="headerlink" title="15、WebSPHINX"></a>15、WebSPHINX</h3><p>WebSPHINX是一个Java类包和Web爬虫的交互式开发环境。Web爬虫(也叫作机器人或蜘蛛)是可以自动浏览与处理Web页面的程序。WebSPHINX由两部分组成：爬虫工作平台和WebSPHINX类包。</p>
<ul>
<li>授权协议：Apache</li>
<li>开发语言：Java</li>
</ul>
<blockquote>
<p>特点：由两部分组成：爬虫工作平台和WebSPHINX类包</p>
</blockquote>
<h3 id="16、YaCy"><a href="#16、YaCy" class="headerlink" title="16、YaCy"></a>16、YaCy</h3><p>YaCy基于p2p的分布式Web搜索引擎.同时也是一个Http缓存代理服务器.这个项目是构建基于p2p Web索引网络的一个新方法.它可以搜索你自己的或全局的索引,也可以Crawl自己的网页或启动分布式Crawling等.</p>
<ul>
<li>授权协议： GPL</li>
<li>开发语言： Java Perl</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：基于P2P的分布式Web搜索引擎</p>
</blockquote>
<h2 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h2><hr>
<h3 id="17、QuickRecon"><a href="#17、QuickRecon" class="headerlink" title="17、QuickRecon"></a>17、QuickRecon</h3><p>QuickRecon是一个简单的信息收集工具,它可以帮助你查找子域名名称、perform zone transfe、收集电子邮件地址和使用microformats寻找人际关系等。QuickRecon使用python编写，支持linux和 windows操作系统。</p>
<ul>
<li>授权协议： GPLv3</li>
<li>开发语言： Python</li>
<li>操作系统： Windows Linux</li>
</ul>
<blockquote>
<p>特点：具有查找子域名名称、收集电子邮件地址并寻找人际关系等功能</p>
</blockquote>
<h3 id="18、PyRailgun"><a href="#18、PyRailgun" class="headerlink" title="18、PyRailgun"></a>18、PyRailgun</h3><p>这是一个非常简单易用的抓取工具。支持抓取javascript渲染的页面的简单实用高效的python网页爬虫抓取模块</p>
<ul>
<li>授权协议： MIT</li>
<li>开发语言： Python</li>
<li>操作系统： 跨平台 Windows Linux OS X</li>
</ul>
<blockquote>
<p>特点：简洁、轻量、高效的网页抓取框架</p>
</blockquote>
<p><em>备注：此软件也是由国人开放</em></p>
<ul>
<li>github下载：<a href="https://github.com/princehaku/pyrailgun#readme" target="_blank" rel="external">https://github.com/princehaku/pyrailgun#readme</a></li>
</ul>
<h3 id="19、Scrapy"><a href="#19、Scrapy" class="headerlink" title="19、Scrapy"></a>19、Scrapy</h3><p>Scrapy 是一套基于基于Twisted的异步处理框架，纯python实现的爬虫框架，用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容以及各种图片，非常之方便～</p>
<ul>
<li>授权协议： BSD</li>
<li>开发语言： Python</li>
<li><p>操作系统： 跨平台</p>
</li>
<li><p>github源代码：<a href="https://github.com/scrapy/scrapy" target="_blank" rel="external">https://github.com/scrapy/scrapy</a></p>
</li>
</ul>
<blockquote>
<p>特点：基于Twisted的异步处理框架，文档齐全</p>
</blockquote>
<h2 id="C-爬虫"><a href="#C-爬虫" class="headerlink" title="C++爬虫"></a>C++爬虫</h2><hr>
<h3 id="20、hispider"><a href="#20、hispider" class="headerlink" title="20、hispider"></a>20、hispider</h3><p>HiSpider is a fast and high performance spider with high speed</p>
<p>严格说只能是一个spider系统的框架, 没有细化需求, 目前只是能提取URL, URL排重, 异步DNS解析, 队列化任务, 支持N机分布式下载, 支持网站定向下载(需要配置hispiderd.ini whitelist).</p>
<p>特征和用法:</p>
<ul>
<li>基于unix/linux系统的开发</li>
<li>异步DNS解析</li>
<li>URL排重</li>
<li>支持HTTP 压缩编码传输 gzip/deflate</li>
<li>字符集判断自动转换成UTF-8编码</li>
<li>文档压缩存储</li>
<li>支持多下载节点分布式下载</li>
<li>支持网站定向下载(需要配置 hispiderd.ini whitelist )</li>
<li>可通过 <a href="http://127.0.0.1:3721/" target="_blank" rel="external">http://127.0.0.1:3721/</a> 查看下载情况统计,下载任务控制(可停止和恢复任务)</li>
<li>依赖基本通信库 libevbase 和 libsbase (安装的时候需要先安装这个两个库)、</li>
</ul>
<p>工作流程:</p>
<ul>
<li>从中心节点取URL(包括URL对应的任务号, IP和port,也可能需要自己解析)</li>
<li>连接服务器发送请求</li>
<li>等待数据头判断是否需要的数据(目前主要取text类型的数据)</li>
<li>等待完成数据(有length头的直接等待说明长度的数据否则等待比较大的数字然后设置超时)</li>
<li>数据完成或者超时, zlib压缩数据返回给中心服务器,数据可能包括自己解析DNS信息, 压缩后数据长度+压缩后数据, 如果出错就直接返回任务号以及相关信息</li>
<li>中心服务器收到带有任务号的数据, 查看是否包括数据, 如果没有数据直接置任务号对应的状态为错误, 如果有数据提取数据种link 然后存储数据到文档文件.<br>完成后返回一个新的任务.</li>
</ul>
<ul>
<li>授权协议： BSD</li>
<li>开发语言： C/C++</li>
<li>操作系统： Linux</li>
</ul>
<blockquote>
<p>特点：支持多机分布式下载, 支持网站定向下载</p>
</blockquote>
<h3 id="21、larbin"><a href="#21、larbin" class="headerlink" title="21、larbin"></a>21、larbin</h3><p>larbin是一种开源的网络爬虫/网络蜘蛛，由法国的年轻人 Sébastien Ailleret独立开发。larbin目的是能够跟踪页面的url进行扩展的抓取，最后为搜索引擎提供广泛的数据来源。Larbin只是一个爬虫，也就 是说larbin只抓取网页，至于如何parse的事情则由用户自己完成。另外，如何存储到数据库以及建立索引的事情 larbin也不提供。一个简单的larbin的爬虫可以每天获取５００万的网页。</p>
<p>利用larbin，我们可以轻易的获取/确定单个网站的所有链接，甚至可以镜像一个网站；也可以用它建立url 列表群，例如针对所有的网页进行 url retrive后，进行xml的联结的获取。或者是 mp3，或者定制larbin，可以作为搜索引擎的信息的来源。</p>
<ul>
<li>授权协议： GPL</li>
<li>开发语言： C/C++</li>
<li>操作系统： Linux</li>
</ul>
<blockquote>
<p>特点：高性能的爬虫软件，只负责抓取不负责解析</p>
</blockquote>
<h3 id="22、Methabot"><a href="#22、Methabot" class="headerlink" title="22、Methabot"></a>22、Methabot</h3><p>Methabot 是一个经过速度优化的高可配置的 WEB、FTP、本地文件系统的爬虫软件。</p>
<ul>
<li>授权协议： 未知</li>
<li>开发语言： C/C++</li>
<li>操作系统： Windows Linux</li>
</ul>
<blockquote>
<p>特点：过速度优化、可抓取WEB、FTP及本地文件系统</p>
</blockquote>
<ul>
<li>源代码：<a href="http://www.oschina.net/code/tag/methabot" target="_blank" rel="external">http://www.oschina.net/code/tag/methabot</a></li>
</ul>
<h2 id="C-爬虫-1"><a href="#C-爬虫-1" class="headerlink" title="C#爬虫"></a>C#爬虫</h2><hr>
<h3 id="23、NWebCrawler"><a href="#23、NWebCrawler" class="headerlink" title="23、NWebCrawler"></a>23、NWebCrawler</h3><p>NWebCrawler是一款开源，C#开发网络爬虫程序。</p>
<p>特性：</p>
<ul>
<li>可配置：线程数，等待时间，连接超时，允许MIME类型和优先级，下载文件夹。</li>
<li>统计信息：URL数量，总下载文件，总下载字节数，CPU利用率和可用内存。</li>
<li>Preferential crawler：用户可以设置优先级的MIME类型。</li>
<li><p>Robust: 10+ URL normalization rules, crawler trap avoiding rules.</p>
</li>
<li><p>授权协议： GPLv2</p>
</li>
<li>开发语言： C#</li>
<li><p>操作系统： Windows</p>
</li>
<li><p>项目主页：<a href="http://www.open-open.com/lib/view/home/1350117470448" target="_blank" rel="external">http://www.open-open.com/lib/view/home/1350117470448</a></p>
</li>
</ul>
<blockquote>
<p>特点：统计信息、执行过程可视化</p>
</blockquote>
<h3 id="24、Sinawler"><a href="#24、Sinawler" class="headerlink" title="24、Sinawler"></a>24、Sinawler</h3><p>国内第一个针对微博数据的爬虫程序！原名“新浪微博爬虫”。</p>
<p>登录后，可以指定用户为起点，以该用户的关注人、粉丝为线索，延人脉关系搜集用户基本信息、微博数据、评论数据。</p>
<p>该应用获取的数据可作为科研、与新浪微博相关的研发等的数据支持，但请勿用于商业用途。该应用基于.NET2.0框架，需SQL SERVER作为后台数据库，并提供了针对SQL Server的数据库脚本文件。</p>
<p>另外，由于新浪微博API的限制，爬取的数据可能不够完整（如获取粉丝数量的限制、获取微博数量的限制等）</p>
<p>本程序版权归作者所有。你可以免费: 拷贝、分发、呈现和表演当前作品,制作派生作品。 你不可将当前作品用于商业目的。</p>
<p>5.x版本已经发布！ 该版本共有6个后台工作线程：爬取用户基本信息的机器人、爬取用户关系的机器人、爬取用户标签的机器人、爬取微博内容的机器人、爬取微博评论的机器人，以及调节请求频率的机器人。更高的性能！最大限度挖掘爬虫潜力！ 以现在测试的结果看，已经能够满足自用。</p>
<p>本程序的特点：</p>
<ol>
<li>6个后台工作线程，最大限度挖掘爬虫性能潜力！</li>
<li>界面上提供参数设置，灵活方便</li>
<li>抛弃app.config配置文件，自己实现配置信息的加密存储，保护数据库帐号信息</li>
<li>自动调整请求频率，防止超限，也避免过慢，降低效率</li>
<li>任意对爬虫控制，可随时暂停、继续、停止爬虫</li>
<li>良好的用户体验</li>
</ol>
<ul>
<li>授权协议： GPLv3</li>
<li>开发语言： C# .NET</li>
<li>操作系统： Windows</li>
</ul>
<h3 id="25、spidernet"><a href="#25、spidernet" class="headerlink" title="25、spidernet"></a>25、spidernet</h3><p>spidernet是一个以递归树为模型的多线程web爬虫程序, 支持text/html资源的获取. 可以设定爬行深度, 最大下载字节数限制, 支持gzip解码, 支持以gbk(gb2312)和utf8编码的资源; 存储于sqlite数据文件.</p>
<p>源码中TODO:标记描述了未完成功能, 希望提交你的代码.</p>
<ul>
<li>授权协议： MIT</li>
<li>开发语言： C#</li>
<li><p>操作系统： Windows</p>
</li>
<li><p>github源代码：<a href="https://github.com/nsnail/spidernet" target="_blank" rel="external">https://github.com/nsnail/spidernet</a></p>
</li>
</ul>
<blockquote>
<p>特点：以递归树为模型的多线程web爬虫程序，支持以GBK (gb2312)和utf8编码的资源，使用sqlite存储数据</p>
</blockquote>
<h3 id="26、Web-Crawler"><a href="#26、Web-Crawler" class="headerlink" title="26、Web Crawler"></a>26、Web Crawler</h3><p>mart and Simple Web Crawler是一个Web爬虫框架。集成Lucene支持。该爬虫可以从单个链接或一个链接数组开始，提供两种遍历模式：最大迭代和最大深度。可以设置 过滤器限制爬回来的链接，默认提供三个过滤器ServerFilter、BeginningPathFilter和 RegularExpressionFilter，这三个过滤器可用AND、OR和NOT联合。在解析过程或页面加载前后都可以加监听器。介绍内容来自Open-Open</p>
<ul>
<li>开发语言： Java</li>
<li>操作系统： 跨平台</li>
<li>授权协议： LGPL</li>
</ul>
<blockquote>
<p>特点：多线程，支持抓取PDF/DOC/EXCEL等文档来源</p>
</blockquote>
<h3 id="27、网络矿工"><a href="#27、网络矿工" class="headerlink" title="27、网络矿工"></a>27、网络矿工</h3><p>网站数据采集软件 网络矿工采集器（原soukey采摘）</p>
<p>Soukey采摘网站数据采集软件是一款基于.Net平台的开源软件，也是网站数据采集软件类型中唯一一款开源软件。尽管Soukey采摘开源，但并不会影响软件功能的提供，甚至要比一些商用软件的功能还要丰富。</p>
<ul>
<li>授权协议： BSD</li>
<li>开发语言： C# .NET</li>
<li>操作系统： Windows</li>
</ul>
<blockquote>
<p>特点：功能丰富，毫不逊色于商业软件</p>
</blockquote>
<h2 id="PHP爬虫"><a href="#PHP爬虫" class="headerlink" title="PHP爬虫"></a>PHP爬虫</h2><hr>
<h3 id="28、OpenWebSpider"><a href="#28、OpenWebSpider" class="headerlink" title="28、OpenWebSpider"></a>28、OpenWebSpider</h3><p>OpenWebSpider是一个开源多线程Web Spider（robot：机器人，crawler：爬虫)和包含许多有趣功能的搜索引擎。</p>
<ul>
<li>授权协议： 未知</li>
<li>开发语言： PHP</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：开源多线程网络爬虫，有许多有趣的功能</p>
</blockquote>
<h3 id="29、PhpDig"><a href="#29、PhpDig" class="headerlink" title="29、PhpDig"></a>29、PhpDig</h3><p>PhpDig是一个采用PHP开发的Web爬虫和搜索引擎。通过对动态和静态页面进行索引建立一个词汇表。当搜索查询时，它将按一定的排序规则显示包含关 键字的搜索结果页面。PhpDig包含一个模板系统并能够索引PDF,Word,Excel,和PowerPoint文档。PHPdig适用于专业化更 强、层次更深的个性化搜索引擎，利用它打造针对某一领域的垂直搜索引擎是最好的选择。</p>
<p>演示：<a href="http://www.phpdig.net/navigation.php?action=demo" target="_blank" rel="external">http://www.phpdig.net/navigation.php?action=demo</a></p>
<ul>
<li>授权协议： GPL</li>
<li>开发语言： PHP</li>
<li>操作系统： 跨平台</li>
</ul>
<blockquote>
<p>特点：具有采集网页内容、提交表单功能</p>
</blockquote>
<h3 id="30、ThinkUp"><a href="#30、ThinkUp" class="headerlink" title="30、ThinkUp"></a>30、ThinkUp</h3><p>ThinkUp 是一个可以采集推特，facebook等社交网络数据的社会媒体视角引擎。通过采集个人的社交网络账号中的数据，对其存档以及处理的交互分析工具，并将数据图形化以便更直观的查看。</p>
<ul>
<li>授权协议： GPL</li>
<li>开发语言： PHP</li>
<li><p>操作系统： 跨平台</p>
</li>
<li><p>github源码：<a href="https://github.com/ThinkUpLLC/ThinkUp" target="_blank" rel="external">https://github.com/ThinkUpLLC/ThinkUp</a></p>
</li>
</ul>
<blockquote>
<p>特点：采集推特、脸谱等社交网络数据的社会媒体视角引擎，可进行交互分析并将结果以可视化形式展现</p>
</blockquote>
<h3 id="31、微购"><a href="#31、微购" class="headerlink" title="31、微购"></a>31、微购</h3><p>微购社会化购物系统是一款基于ThinkPHP框架开发的开源的购物分享系统，同时它也是一套针对站长、开源的的淘宝客网站程序，它整合了淘宝、天猫、淘宝客等300多家商品数据采集接口，为广大的淘宝客站长提供傻瓜式淘客建站服务，会HTML就会做程序模板，免费开放下载，是广大淘客站长的首选。</p>
<p>演示网址：<a href="http://tlx.wego360.com" target="_blank" rel="external">http://tlx.wego360.com</a></p>
<ul>
<li>授权协议： GPL</li>
<li>开发语言： PHP</li>
<li>操作系统： 跨平台</li>
</ul>
<h2 id="ErLang爬虫"><a href="#ErLang爬虫" class="headerlink" title="ErLang爬虫"></a>ErLang爬虫</h2><hr>
<h3 id="32、Ebot"><a href="#32、Ebot" class="headerlink" title="32、Ebot"></a>32、Ebot</h3><p>Ebot 是一个用 ErLang 语言开发的可伸缩的分布式网页爬虫，URLs 被保存在数据库中可通过 RESTful 的 HTTP 请求来查询。</p>
<ul>
<li>授权协议： GPLv3</li>
<li>开发语言： ErLang</li>
<li><p>操作系统： 跨平台</p>
</li>
<li><p>github源代码：<a href="https://github.com/matteoredaelli/ebot" target="_blank" rel="external">https://github.com/matteoredaelli/ebot</a></p>
</li>
<li><p>项目主页： <a href="http://www.redaelli.org/matteo/blog/projects/ebot" target="_blank" rel="external">http://www.redaelli.org/matteo/blog/projects/ebot</a></p>
</li>
</ul>
<blockquote>
<p>特点：可伸缩的分布式网页爬虫</p>
</blockquote>
<h2 id="Ruby爬虫"><a href="#Ruby爬虫" class="headerlink" title="Ruby爬虫"></a>Ruby爬虫</h2><hr>
<h3 id="33、Spidr"><a href="#33、Spidr" class="headerlink" title="33、Spidr"></a>33、Spidr</h3><p>Spidr 是一个Ruby 的网页爬虫库，可以将整个网站、多个网站、某个链接完全抓取到本地。</p>
<ul>
<li><p>开发语言： Ruby</p>
</li>
<li><p>授权协议：MIT</p>
</li>
</ul>
<blockquote>
<p>特点：可将一个或多个网站、某个链接完全抓取到本地</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对较为知名及常见的开源爬虫软件进行梳理，按开发语言进行汇总。虽然搜索引擎也有爬虫，但这里只是爬虫软件，而非大型、复杂的搜索引擎。&lt;/p&gt;
    
    </summary>
    
    
      <category term="COLLECTION" scheme="http://mingotang.github.io/tags/COLLECTION/"/>
    
  </entry>
  
  <entry>
    <title>数据集下载链接汇总</title>
    <link href="http://mingotang.github.io/2017/09/06/%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB/"/>
    <id>http://mingotang.github.io/2017/09/06/数据集下载链接汇总/</id>
    <published>2017-09-06T07:04:43.000Z</published>
    <updated>2017-09-25T03:12:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><ul>
<li><a href="http://www.sogou.com/labs/" target="_blank" rel="external">搜狗实验室</a></li>
<li><a href="https://www.ncdc.noaa.gov/data-access/quick-links" target="_blank" rel="external">气象数据集</a></li>
<li><a href="http://cdiac.ornl.gov/ftp/ndp026b" target="_blank" rel="external">气候监测数据集</a></li>
</ul>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>亚马逊网络服务数据<br><a href="http://aws.amazon.com/datasets" target="_blank" rel="external">http://aws.amazon.com/datasets</a><br>航空公司数据(2009年ASA挑战)<br><a href="http://stat-computing.org/dataexpo/2009/the-data.html" target="_blank" rel="external">http://stat-computing.org/dataexpo/2009/the-data.html</a><br>澳大利亚天气<br><a href="http://www.bom.gov.au/climate/dwo/" target="_blank" rel="external">http://www.bom.gov.au/climate/dwo/</a><br>因果关系工作台<br><a href="http://www.causality.inf.ethz.ch/repository.php" target="_blank" rel="external">http://www.causality.inf.ethz.ch/repository.php</a><br>Kaggle竞争数据<br><a href="https://www.kaggle.com/datasets" target="_blank" rel="external">https://www.kaggle.com/datasets</a><br>KDNuggets竞争网站<br>www.kdnuggets.com/datasets/<br>机器学习的数据集存储库<br><a href="http://mldata.org/" target="_blank" rel="external">http://mldata.org/</a><br>医疗保险数据文件<br><a href="http://go.cms.gov/19xxPN4" target="_blank" rel="external">http://go.cms.gov/19xxPN4</a><br>微软研究院<br><a href="http://research.microsoft.com/apps/dp/dl/downloads.aspx" target="_blank" rel="external">http://research.microsoft.com/apps/dp/dl/downloads.aspx</a><br>百万歌曲数据集<br><a href="http://blog.echonest.com/post/3639160982/million-song-dataset" target="_blank" rel="external">http://blog.echonest.com/post/3639160982/million-song-dataset</a><br>歌曲数据集<br><a href="http://labrosa.ee.columbia.edu/millionsong/pages/additional-datasets" target="_blank" rel="external">http://labrosa.ee.columbia.edu/millionsong/pages/additional-datasets</a><br>RDataMining.com R和数据挖掘电子书数据<br><a href="http://www.rdatamining.com/data" target="_blank" rel="external">http://www.rdatamining.com/data</a><br>革命分析集合<br><a href="http://www.revolutionanalytics.com/subscriptions/datasets/" target="_blank" rel="external">http://www.revolutionanalytics.com/subscriptions/datasets/</a><br>社交网络<br><a href="http://www.cs.cmu.edu//ancestry.com/" target="_blank" rel="external">http://www.cs.cmu.edu//ancestry.com/</a> ~ jelsas /数据<br>UCI机器学习库<br><a href="http://archive.ics.uci.edu/ml/" target="_blank" rel="external">http://archive.ics.uci.edu/ml/</a><br>535亿点击<br>1.<a href="http://cnets.indiana.edu/groups/nan/webtraffic/click-dataset" target="_blank" rel="external">http://cnets.indiana.edu/groups/nan/webtraffic/click-dataset</a><br>2.<a href="http://archive.ics.uci.edu/ml/" target="_blank" rel="external">http://archive.ics.uci.edu/ml/</a><br>3.<a href="http://www.ics.uci.edu/~mlearn//MLRepository.htm" target="_blank" rel="external">http://www.ics.uci.edu/~mlearn//MLRepository.htm</a><br>机器学习样本数据库<br>1.<a href="http://kdd.ics.uci.edu/" target="_blank" rel="external">http://kdd.ics.uci.edu/</a><br>2.<a href="http://www.ics.uci.edu/~mlearn/MLRepository.html" target="_blank" rel="external">http://www.ics.uci.edu/~mlearn/MLRepository.html</a><br>关于基金的数据挖掘的网站<br><a href="http://www.gotofund.com/index.asp" target="_blank" rel="external">http://www.gotofund.com/index.asp</a><br>数据生成器的链接<br><a href="http://www.cse.cuhk.edu.hk/~kdd/data_collection.html" target="_blank" rel="external">http://www.cse.cuhk.edu.hk/~kdd/data_collection.html</a><br>癌症基因<br><a href="http://www.broad.mit.edu/cgi-bin/cancer/datasets.cgi" target="_blank" rel="external">http://www.broad.mit.edu/cgi-bin/cancer/datasets.cgi</a><br>金融数据<br><a href="http://lisp.vse.cz/pkdd99/Challenge/chall.htm" target="_blank" rel="external">http://lisp.vse.cz/pkdd99/Challenge/chall.htm</a></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>斯坦福大学大型网络数据收集<br><a href="http://snap.stanford.edu/data/" target="_blank" rel="external">http://snap.stanford.edu/data/</a><br>微软匿名网络数据<br><a href="http://kdd.ics.uci.edu/databases/msweb/msweb.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/msweb/msweb.html</a><br>MSNBC匿名网络数据<br><a href="http://kdd.ics.uci.edu/databases/msnbc/msnbc.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/msnbc/msnbc.html</a><br>SyskillWebert Web数据<br><a href="http://kdd.ics.uci.edu/databases/SyskillWebert/SyskillWebert.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/SyskillWebert/SyskillWebert.html</a></p>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><p>ImageNet （包含1400万的图像）<br><a href="http://www.image-net.org/" target="_blank" rel="external">http://www.image-net.org/</a><br>Tiny Images Dataset （包含8000万的32x32图像）<br><a href="http://horatio.cs.nyu.edu/mit/tiny/data/index.html" target="_blank" rel="external">http://horatio.cs.nyu.edu/mit/tiny/data/index.html</a><br>MirFlickr1M （包含100万的图像）<br><a href="http://press.liacs.nl/mirflickr/" target="_blank" rel="external">http://press.liacs.nl/mirflickr/</a><br> CoPhIR （包含1亿600万的图像 ）<br><a href="http://cophir.isti.cnr.it/whatis.html" target="_blank" rel="external">http://cophir.isti.cnr.it/whatis.html</a><br>SBU captioned photo dataset （包含100万的图像）<br><a href="http://dsl1.cewit.stonybrook.edu/~vicente/sbucaptions/" target="_blank" rel="external">http://dsl1.cewit.stonybrook.edu/~vicente/sbucaptions/</a><br>Large-Scale Image Annotation using Visual Synset(ICCV 2011) （包含2亿图像 ）<br><a href="http://cpl.cc.gatech.edu/projects/VisualSynset/" target="_blank" rel="external">http://cpl.cc.gatech.edu/projects/VisualSynset/</a><br>NUS-WIDE（包含27万的图像）<br><a href="http://lms.comp.nus.edu.sg/research/NUS-WIDE.htm" target="_blank" rel="external">http://lms.comp.nus.edu.sg/research/NUS-WIDE.htm</a><br>SUN dataset （包含13万的图像）<br><a href="http://people.csail.mit.edu/jxiao/SUN/" target="_blank" rel="external">http://people.csail.mit.edu/jxiao/SUN/</a><br>MSRA-MM （包含100万的图像，23000视频 ）<br><a href="http://research.microsoft.com/enus/projects/msrammdata/" target="_blank" rel="external">http://research.microsoft.com/enus/projects/msrammdata/</a><br>TRECVID<br><a href="http://trecvid.nist.gov/" target="_blank" rel="external">http://trecvid.nist.gov/</a><br>卡耐基-梅隆的脸图片<br><a href="http://kdd.ics.uci.edu/databases/faces/faces.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/faces/faces.html</a><br>金星上的火山<br><a href="http://kdd.ics.uci.edu/databases/volcanoes/volcanoes.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/volcanoes/volcanoes.html</a><br>雅虎发布超大Flickr数据集 1亿的图片+视频<br><a href="http://yahoolabs.tumblr.com/post/89783581601/one-hundred-million-creative-commons-flickr-images-for" target="_blank" rel="external">http://yahoolabs.tumblr.com/post/89783581601/one-hundred-million-creative-commons-flickr-images-for</a><br>100多个有趣的数据集<br><a href="http://www.csdn.net/article/2014-06-06/2820111-100-Interesting-Data-Sets-for-Statistics" target="_blank" rel="external">http://www.csdn.net/article/2014-06-06/2820111-100-Interesting-Data-Sets-for-Statistics</a><br>图像处理相关个人主页、研究组及公开数据集网址<br><a href="http://blog.sciencenet.cn/blog-673472-759786.html" target="_blank" rel="external">http://blog.sciencenet.cn/blog-673472-759786.html</a></p>
<h2 id="Public-Domain-Collections"><a href="#Public-Domain-Collections" class="headerlink" title="Public Domain Collections"></a>Public Domain Collections</h2><p>Data360<br><a href="http://www.data360.org/index.aspx" target="_blank" rel="external">http://www.data360.org/index.aspx</a><br>Datamob.org<br> <a href="http://datamob.org/datasets" target="_blank" rel="external">http://datamob.org/datasets</a><br>Factual<br><a href="http://www.factual.com/topics/browse" target="_blank" rel="external">http://www.factual.com/topics/browse</a><br>Freebase<br><a href="http://www.freebase.com/" target="_blank" rel="external">http://www.freebase.com/</a><br>Google<br><a href="http://www.google.com/publicdata/directory" target="_blank" rel="external">http://www.google.com/publicdata/directory</a><br>infochimps: <a href="http://www.infochimps.com/" target="_blank" rel="external">http://www.infochimps.com/</a><br>numbray<br> <a href="http://numbrary.com/" target="_blank" rel="external">http://numbrary.com/</a><br>Quora<br><a href="https://www.quora.com/Data/Where-can-I-find-large-datasets-open-to-the-public" target="_blank" rel="external">https://www.quora.com/Data/Where-can-I-find-large-datasets-open-to-the-public</a><br>RS Collection 100+<br><a href="http://rs.io/2014/05/29/list-of-data-sets.html" target="_blank" rel="external">http://rs.io/2014/05/29/list-of-data-sets.html</a><br>Sample R data sets<br><a href="http://stat.ethz.ch/R-manual/R-patched/library/datasets/html/00Index.html" target="_blank" rel="external">http://stat.ethz.ch/R-manual/R-patched/library/datasets/html/00Index.html</a><br>SourceForge研究数据<br> <a href="http://www.nd.edu/" target="_blank" rel="external">http://www.nd.edu/</a> oss /数据/研究司<br>StatSci.org<br><a href="http://www.statsci.org/datasets.html" target="_blank" rel="external">http://www.statsci.org/datasets.html</a><br>UFO报告<br><a href="http://www.nuforc.org/webreports.html" target="_blank" rel="external">http://www.nuforc.org/webreports.html</a><br>维基解密911寻呼机截取<br> <a href="http://911.wikileaks.org/files/index.html" target="_blank" rel="external">http://911.wikileaks.org/files/index.html</a><br>Stats4Stem.org:R数据集<br><a href="http://www.stats4stem.org/data-sets.html" target="_blank" rel="external">http://www.stats4stem.org/data-sets.html</a><br>《华盛顿邮报》名单<br><a href="http://www.washingtonpost.com/wp-srv/metro/data/datapost.html" target="_blank" rel="external">http://www.washingtonpost.com/wp-srv/metro/data/datapost.html</a></p>
<h2 id="科学"><a href="#科学" class="headerlink" title="科学"></a>科学</h2><p>农业实验<br><a href="http://www.insider.org/packages/cran/agridat/docs/agridat" target="_blank" rel="external">http://www.insider.org/packages/cran/agridat/docs/agridat</a><br>气候数据<br><a href="http://www.cru.uea.ac.uk/cru/data/temperature/#datter" target="_blank" rel="external">http://www.cru.uea.ac.uk/cru/data/temperature/#datter</a><br>and ftp://ftp.cmdl.noaa.gov/<br>Gene Expression Omnibus<br><a href="http://www.ncbi.nlm.nih.gov/geo/" target="_blank" rel="external">http://www.ncbi.nlm.nih.gov/geo/</a><br>Geo Spatial Data<br><a href="http://geodacenter.asu.edu/datalist/" target="_blank" rel="external">http://geodacenter.asu.edu/datalist/</a><br>Human Microbiome Project<br><a href="http://www.hmpdacc.org/reference_genomes/reference_genomes.php" target="_blank" rel="external">http://www.hmpdacc.org/reference_genomes/reference_genomes.php</a><br>MIT Cancer Genomics Data<br><a href="http://www.broadinstitute.org/cgibin/cancer/datasets.cgi" target="_blank" rel="external">http://www.broadinstitute.org/cgibin/cancer/datasets.cgi</a><br>NASA<br><a href="http://nssdc.gsfc.nasa.gov/nssdc/obtaining_data.html" target="_blank" rel="external">http://nssdc.gsfc.nasa.gov/nssdc/obtaining_data.html</a><br>NIH Microarray data<br>ftp://ftp.ncbi.nih.gov/pub/geo/DATA/supplementary/series/GSE6532/(R)<br>Protein structure<br><a href="http://www.infobiotic.net/PSPbenchmarks/" target="_blank" rel="external">http://www.infobiotic.net/PSPbenchmarks/</a><br>Public Gene Data<br><a href="http://www.pubgene.org/" target="_blank" rel="external">http://www.pubgene.org/</a><br>斯坦福大学的微阵列数据<br><a href="http://smd.stanford.edu/" target="_blank" rel="external">http://smd.stanford.edu/</a></p>
<h2 id="社会科学"><a href="#社会科学" class="headerlink" title="社会科学"></a>社会科学</h2><p>综合社会调查<br><a href="http://www3.norc.org/GSS" target="_blank" rel="external">http://www3.norc.org/GSS</a> +网站/<br>ICPSR<br><a href="http://www.icpsr.umich.edu/icpsrweb/ICPSR/access/index.jsp" target="_blank" rel="external">http://www.icpsr.umich.edu/icpsrweb/ICPSR/access/index.jsp</a><br>皮尤研究<br><a href="http://www.pewinternet.org/datasets/pages/2/" target="_blank" rel="external">http://www.pewinternet.org/datasets/pages/2/</a><br>加州大学洛杉矶分校的社会科学档案<br><a href="http://dataarchives.ss.ucla.edu/Home.DataPortals.html" target="_blank" rel="external">http://dataarchives.ss.ucla.edu/Home.DataPortals.html</a><br>UPJOHN本月<br><a href="http://www.upjohn.org/erdc/erdc.html" target="_blank" rel="external">http://www.upjohn.org/erdc/erdc.html</a></p>
<h2 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h2><p>时间序列数据库<br><a href="http://robjhyndman.com/TSDL/" target="_blank" rel="external">http://robjhyndman.com/TSDL/</a><br>澳大利亚手语数据<br><a href="http://kdd.ics.uci.edu/databases/auslan/auslan.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/auslan/auslan.html</a><br>高质量的澳大利亚手语数据<br><a href="http://kdd.ics.uci.edu/databases/auslan2/auslan.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/auslan2/auslan.html</a><br>脑电图数据<br><a href="http://kdd.ics.uci.edu/databases/eeg/eeg.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/eeg/eeg.html</a><br>日本的元音<br><a href="http://kdd.ics.uci.edu/databases/JapaneseVowels/JapaneseVowels.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/JapaneseVowels/JapaneseVowels.html</a><br>Pioneer-1移动机器人数据<br><a href="http://kdd.ics.uci.edu/databases/pioneer/pioneer.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/pioneer/pioneer.html</a><br>伪周期合成时间序列<br><a href="http://kdd.ics.uci.edu/databases/synthetic/synthetic.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/synthetic/synthetic.html</a><br>合成控制图时间序列<br><a href="http://kdd.ics.uci.edu/databases/synthetic_control/synthetic_control.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/synthetic_control/synthetic_control.html</a></p>
<h2 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h2><p>卡内基梅隆大学安然电子邮件<br><a href="http://www.cs.cmu.edu/~安然/" target="_blank" rel="external">http://www.cs.cmu.edu/~安然/</a><br>卡内基梅隆大学StatLab<br><a href="http://lib.stat.cmu.edu/datasets/" target="_blank" rel="external">http://lib.stat.cmu.edu/datasets/</a><br>龙骨存储库<br><a href="http://sci2s.ugr.es/keel/datasets.php" target="_blank" rel="external">http://sci2s.ugr.es/keel/datasets.php</a><br>卡内基梅隆大学JASA数据归档<br><a href="http://lib.stat.cmu.edu/jasadata/" target="_blank" rel="external">http://lib.stat.cmu.edu/jasadata/</a><br>俄亥俄州立大学财务数据<br><a href="http://fisher.osu.edu/fin/osudata.htm" target="_blank" rel="external">http://fisher.osu.edu/fin/osudata.htm</a><br>加州大学伯克利分校<br><a href="http://ucdata.berkeley.edu/" target="_blank" rel="external">http://ucdata.berkeley.edu/</a><br>加州大学洛杉矶分校<br> <a href="http://aws.amazon.com/datasets" target="_blank" rel="external">http://aws.amazon.com/datasets</a><br>加州大学河滨分校时间序列<br><a href="http://www.cs.ucr.edu/" target="_blank" rel="external">http://www.cs.ucr.edu/</a> / time_series_data /<br>多伦多大学<br><a href="http://www.cs.toronto.edu/深入/数据/datasets.html" target="_blank" rel="external">http://www.cs.toronto.edu/深入/数据/datasets.html</a><br>UCI知识发现(KDD)归档<br><a href="http://kdd.ics.uci.edu/" target="_blank" rel="external">http://kdd.ics.uci.edu/</a><br>信息和计算机科学<br><a href="http://www.ics.uci.edu/" target="_blank" rel="external">http://www.ics.uci.edu/</a><br>加州大学欧文分校<br><a href="https://uci.edu/" target="_blank" rel="external">https://uci.edu/</a></p>
<h2 id="互联网相关数据集"><a href="#互联网相关数据集" class="headerlink" title="互联网相关数据集"></a>互联网相关数据集</h2><p>Dataset for “Statistics and SocialNetwork of YouTube Videos”<br><a href="http://netsg.cs.sfu.ca/youtubedata/" target="_blank" rel="external">http://netsg.cs.sfu.ca/youtubedata/</a><br>1998 World Cup Web Site Access Logs<br><a href="http://ita.ee.lbl.gov/html/contrib/WorldCup.html" target="_blank" rel="external">http://ita.ee.lbl.gov/html/contrib/WorldCup.html</a><br>（从1998/04/26 到 1998/07/26 的92天中，发生了 1,352,804,107次请求）<br>Page view statistics for Wikimedia projects<br><a href="http://dammit.lt/wikistats/" target="_blank" rel="external">http://dammit.lt/wikistats/</a><br>AOL Search Query Logs - RP<br><a href="http://www.researchpipeline.com/mediawiki/index.php?title=AOL_Search_Query_Logs" target="_blank" rel="external">http://www.researchpipeline.com/mediawiki/index.php?title=AOL_Search_Query_Logs</a><br>livedoor gourmet<br><a href="http://blog.livedoor.jp/techblog/archives/65836960.html" target="_blank" rel="external">http://blog.livedoor.jp/techblog/archives/65836960.html</a></p>
<h2 id="离散序列数据"><a href="#离散序列数据" class="headerlink" title="离散序列数据"></a>离散序列数据</h2><p>UNIX用户数据<br><a href="http://kdd.ics.uci.edu/databases/UNIX_user_data/UNIX_user_data.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/UNIX_user_data/UNIX_user_data.html</a><br>主菜芝加哥推荐数据<br><a href="http://kdd.ics.uci.edu/databases/entree/entree.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/entree/entree.html</a></p>
<h2 id="多元数据"><a href="#多元数据" class="headerlink" title="多元数据"></a>多元数据</h2><p>人口收入调查数据库<br><a href="http://kdd.ics.uci.edu/databases/census-income/census-income.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/census-income/census-income.html</a><br>线圈数据<br><a href="http://kdd.ics.uci.edu/databases/coil/coil.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/coil/coil.html</a><br>Corel图像特征<br><a href="http://kdd.ics.uci.edu/databases/CorelFeatures/CorelFeatures.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/CorelFeatures/CorelFeatures.html</a><br>森林CoverType<br><a href="http://kdd.ics.uci.edu/databases/covertype/covertype.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/covertype/covertype.html</a><br>保险公司基准(2000卷)<br><a href="http://kdd.ics.uci.edu/databases/tic/tic.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/tic/tic.html</a><br>互联网使用数据<br><a href="http://kdd.ics.uci.edu/databases/internet_usage/internet_usage.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/internet_usage/internet_usage.html</a><br>IPUMS人口普查数据<br><a href="http://kdd.ics.uci.edu/databases/ipums/ipums.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/ipums/ipums.html</a><br>KDD CUP 1998数据<br><a href="http://kdd.ics.uci.edu/databases/kddcup98/kddcup98.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/kddcup98/kddcup98.html</a><br>KDD CUP 1999数据<br><a href="http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/kddcup99/kddcup99.html</a><br>1990年美国人口普查数据<br><a href="http://kdd.ics.uci.edu/databases/census1990/USCensus1990.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/census1990/USCensus1990.html</a></p>
<h2 id="关系数据"><a href="#关系数据" class="headerlink" title="关系数据"></a>关系数据</h2><p>大肠杆菌基因<br><a href="http://kdd.ics.uci.edu/databases/ecoli/ecoli.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/ecoli/ecoli.html</a><br>结核分枝杆菌基因<br><a href="http://kdd.ics.uci.edu/databases/tb/tb.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/tb/tb.html</a><br>电影<br><a href="http://kdd.ics.uci.edu/databases/movies/movies.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/movies/movies.html</a><br>MovieLens数据集<br><a href="http://datahub.io/dataset/movielens" target="_blank" rel="external">http://datahub.io/dataset/movielens</a><br>厄尔尼诺现象的数据<br><a href="http://kdd.ics.uci.edu/databases/el_nino/el_nino.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/el_nino/el_nino.html</a></p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>20新闻组数据<br><a href="http://kdd.ics.uci.edu/databases/20newsgroups/20newsgroups.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/20newsgroups/20newsgroups.html</a><br>路透社- 21578文本分类收集<br><a href="http://kdd.ics.uci.edu/databases/reuters21578/reuters21578.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/reuters21578/reuters21578.html</a><br>路透转录子集<br><a href="http://kdd.ics.uci.edu/databases/reuters_transcribed/reuters_transcribed.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/reuters_transcribed/reuters_transcribed.html</a><br>摘要1990- 2003年NSF研究奖项<br><a href="http://kdd.ics.uci.edu/databases/nsfabs/nsfawards.html" target="_blank" rel="external">http://kdd.ics.uci.edu/databases/nsfabs/nsfawards.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大数据&quot;&gt;&lt;a href=&quot;#大数据&quot; class=&quot;headerlink&quot; title=&quot;大数据&quot;&gt;&lt;/a&gt;大数据&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.sogou.com/labs/&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
    
      <category term="COLLECTION" scheme="http://mingotang.github.io/tags/COLLECTION/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown表达</title>
    <link href="http://mingotang.github.io/2017/09/03/MarkDown%E8%A1%A8%E8%BE%BE/"/>
    <id>http://mingotang.github.io/2017/09/03/MarkDown表达/</id>
    <published>2017-09-03T06:43:19.000Z</published>
    <updated>2017-10-01T02:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><a id="TOC"></a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#heads">标题</a></li>
<li><a href="#pictures">插入图片</a></li>
<li><a href="#highlighting">高亮代码</a></li>
<li><a href="#latex">LaTeX公式</a></li>
<li><a href="#todolist">Todo 列表</a></li>
<li><a href="#excel">绘制表格</a></li>
<li><a href="#coloredtags">加重标签</a></li>
</ul>
<p><a id="heads"></a></p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 一级标题</div><div class="line">## 二级标题</div><div class="line">### 三级标题</div><div class="line">#### 四级标题</div></pre></td></tr></table></figure>
<p><a id="specified"></a></p>
<h2 id="重点与注意"><a href="#重点与注意" class="headerlink" title="重点与注意"></a>重点与注意</h2><p><em>加粗</em></p>
<p><strong>加斜</strong></p>
<p><code>注意</code></p>
<blockquote>
<p>注意</p>
</blockquote>
<p><u>Underlined Text</u></p>
<p><del>Deleted</del></p>
<blockquote>
<ul>
<li>加星重点</li>
</ul>
</blockquote>
<p><a id="pictures"></a></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><a href="http://mingotang.website" target="_blank" rel="external">链接</a></p>
<p><img src="http://mingotang.website/image/githubs.png" alt="图片名字"></p>
<p><a id="highlighting"></a></p>
<h2 id="高亮代码"><a href="#高亮代码" class="headerlink" title="高亮代码"></a>高亮代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># A comment</span></div><div class="line">    print(<span class="string">'hello world'</span>)</div></pre></td></tr></table></figure>
<p><a id="latex"></a></p>
<h2 id="LaTeX公式"><a href="#LaTeX公式" class="headerlink" title="LaTeX公式"></a>LaTeX公式</h2><p>$$E=mc^2$$</p>
<p><a id="todolist"></a></p>
<h2 id="Todo-列表"><a href="#Todo-列表" class="headerlink" title="Todo 列表"></a>Todo 列表</h2><ul>
<li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li>
<li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li>
<li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li>
<li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能</li>
</ul>
<p><a id="excel"></a></p>
<h2 id="绘制表格"><a href="#绘制表格" class="headerlink" title="绘制表格"></a>绘制表格</h2><table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格 (\$)</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">\$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">\$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">\$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<p><a id="coloredtags"></a></p>
<h2 id="加重标签"><a href="#加重标签" class="headerlink" title="加重标签"></a>加重标签</h2><div class="note"><br>    <h5>标题</h5><br>    <p>内容 note</p><br></div>



<div class="note info"><br>    <h5>标题</h5><br>    <p>内容 note info</p><br></div>




<div class="note warning"><br>    <h5>标题</h5><br>    <p>内容 note warning</p><br></div>



<div class="note unreleased"><br>    <h5>标题</h5><br>    <p>内容 note unreleased</p><br></div>


]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a id=&quot;TOC&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#heads&quot;&gt;标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>Hexo使用方式</title>
    <link href="http://mingotang.github.io/2015/10/19/Hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://mingotang.github.io/2015/10/19/Hexo使用方式/</id>
    <published>2015-10-19T02:34:12.000Z</published>
    <updated>2017-09-28T08:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/docs/" target="_blank" rel="external">Check documentation for more info.</a></p>
<a id="more"></a>
<hr>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo new [layout] title</div><div class="line">$ hexo n</div></pre></td></tr></table></figure>
<h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><table>
<thead>
<tr>
<th>Layout</th>
<th>Path</th>
</tr>
</thead>
<tbody>
<tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody>
</table>
<h3 id="Drafts"><a href="#Drafts" class="headerlink" title="Drafts"></a>Drafts</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo publish [layout] title</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<hr>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-server --save</div><div class="line"></div><div class="line">$ hexo server</div><div class="line">$ hexo s</div><div class="line"></div><div class="line">$ hexo server -p 5000</div><div class="line"></div><div class="line">$ hexo server -i 192.168.1.1</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<hr>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div><div class="line">$ hexo g</div></pre></td></tr></table></figure>
<h3 id="Watch-for-File-Changes"><a href="#Watch-for-File-Changes" class="headerlink" title="Watch for File Changes"></a>Watch for File Changes</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate --watch</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<hr>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line">$ hexo d</div></pre></td></tr></table></figure>
<h3 id="Deploy-After-Generating"><a href="#Deploy-After-Generating" class="headerlink" title="Deploy After Generating"></a>Deploy After Generating</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo generate --deploy</div><div class="line">$ hexo deploy --generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Check documentation for more info.&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="http://mingotang.github.io/tags/Notes/"/>
    
  </entry>
  
</feed>
